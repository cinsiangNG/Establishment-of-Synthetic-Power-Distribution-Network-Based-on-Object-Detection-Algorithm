# -*- coding: utf-8 -*-
"""Data_fusion

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cxC51TWAsjBiRh8QjO0L32Q2KRQRh0b2
"""

!pip install openpyxl
!pip install geopy
!pip install plotly
!pip install sktlearn

"""## **Link to GOOGLE CLOUD**"""

from google.colab import drive
drive.mount('/content/drive')

import os
os.environ["DATASET_DIRECTORY"] = "/content/drive/MyDrive/黃俊翔_論文研究📚/Aerial_view"

"""# **Reading an excel file**"""

import pandas as pd

# 读取 CSV 文件
satellite_data = pd.read_excel('/content/detected_poles_newdataset_11x.xlsx')
street_view_data = pd.read_excel('/content/AllPredictions.xlsx')

"""# **Concat data and get the center of each aggregation**"""

import numpy as np
from sklearn.cluster import DBSCAN

all_poles = pd.concat([satellite_data, street_view_data], ignore_index=True)

# 3. 数据融合
# 使用 DBSCAN 聚类算法来融合相近的点
coords = all_poles[['Lat', 'Lon']].values
print(np.argwhere(np.isnan(coords)))
epsilon = 0.0001  # 约 11 米，根据需要调整
min_samples = 1  # 每个聚类至少包含 1 个样本
db = DBSCAN(eps=epsilon, min_samples=min_samples).fit(coords)

# 为每个点添加聚类标签
all_poles['Cluster'] = db.labels_

# 计算每个聚类的中心点
fused_poles = all_poles.groupby('Cluster').agg({
    'Lat': 'mean',
    'Lon': 'mean'
}).reset_index()

"""# **Plot them and data visualization**"""

import plotly.graph_objects as go

def plot_poles(data, name, color):
    return go.Scattermapbox(
        lat=data['Lat'],
        lon=data['Lon'],
        mode='markers',
        marker=dict(size=8, color=color),
        name=name
    )

fig = go.Figure()

fig.add_trace(plot_poles(satellite_data, 'Satellite', 'blue'))
fig.add_trace(plot_poles(street_view_data, 'Street View', 'green'))
fig.add_trace(plot_poles(fused_poles, 'Fused', 'red'))

fig.update_layout(
    mapbox=dict(
        style="open-street-map",
        center=dict(lat=fused_poles['Lat'].mean(), lon=fused_poles['Lon'].mean()),
        zoom=14
    ),
    showlegend=True,
    height=800,
    title_text="Pole Detection Data Fusion"
)

fig.show()

"""# **Save the result**"""

fusion_T = pd.DataFrame(fused_poles,columns=['Lat','Lon'])
fusion_T.to_excel("/content/" + '/drive/MyDrive/黃俊翔_論文研究📚/' + 'fused_poles_newdataset_Yolo11x+OriginalStreetview.xlsx', index = False)

print(fusion_T)

"""# **Compare the result with the actual prediction**"""

def reset_and_create_new_figure():
    """
    重置并创建一个新的 Plotly 图形对象
    """
    # 创建一个新的空白图形
    fig = go.Figure()

    # 设置基本布局
    fig.update_layout(
        mapbox_style="open-street-map",
        height=800
    )

    return fig

fig = reset_and_create_new_figure()

WHPoleLoc = pd.read_excel('/content/' + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
import plotly.graph_objects as go
import pandas as pd

def plot_poles(data, name, color, size=10):
    return go.Scattermapbox(
        lat=data['Lat'],
        lon=data['Lon'],
        mode='markers',
        marker=dict(size=size, color=color),
        name=name
    )

# 读取 Excel 文件中的实际杆位置
actual_poles = pd.read_excel('/content/PoleLocationGT.xlsx', sheet_name='pole')
actual_poles.columns = ['Lat', 'Lon']  # 确保列名一致

# 创建图形
fig = go.Figure()

# 添加各类数据点
fig.add_trace(plot_poles(fused_poles, 'Fused', 'red', size=8))
fig.add_trace(plot_poles(actual_poles, 'Actual', 'yellow', size=6))  # 实际点稍大一些以便区分

# 更新布局
fig.update_layout(
    mapbox=dict(
        style="open-street-map",
        center=dict(lat=fused_poles['Lat'].mean(), lon=fused_poles['Lon'].mean()),
        zoom=14
    ),
    showlegend=True,
    height=800,
    title_text="Pole Detection Data Fusion and Comparison"
)

fig.show()