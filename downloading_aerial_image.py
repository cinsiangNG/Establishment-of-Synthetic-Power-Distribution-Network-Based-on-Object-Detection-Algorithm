# -*- coding: utf-8 -*-
"""Downloading_Aerial_image.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HiwAKZh9ES91tzgCiMiSfaq2COU6PizS
"""

! git clone https://github.com/doersino/aerialbot
! python3 -m venv aerialbot
! cd aerialbot
! source bin/activate
! pip3 install -r /content/aerialbot/requirements.txt

! python3 /content/aerialbot/aerialbot.py --help

! python3 /content/aerialbot/aerialbot.py /content/aerialbot/config.sample.ini -p29.18943033,-94.98234459	 --image_width 1000 --image_height 1000 -w 35 -h 35
# image_path_template = "/content/aerialbot/aerialbot-{latitude}-{longitude}-{width}-{height}-{max_meters_per_pixel}.jpg"
# image_path_template = "/content/drive/MyDrive/黃俊翔_論文研究📚/Aerial_view/Junior_project/{latitude}-{longitude}-{width}-{height}-{max_meters_per_pixel}.jpg"

! python3 /content/aerialbot/aerialbot.py /content/aerialbot/config.sample.ini -p29.19172943,-94.97851689 --image_width 1000 --image_height 1000 -w 60 -h 60

import cv2
from google.colab.patches import cv2_imshow

# 读取图像
image = cv2.imread('/content/aerialbot/aerialbot-38.90207751--76.92485159-30.0-30.0-0.03.jpg')

# 定义左上和右下点的坐标
point1 = (250, 0)  # 左上角点的坐标 (x1, y1)
point2 = (600, 600)  # 右下角点的坐标 (x2, y2)

# 在图像上绘制边界框
color = (0, 255, 0)  # BGR颜色，这里是绿色
thickness = 2  # 线条宽度
image_with_bbox = cv2.rectangle(image, point1, point2, color, thickness)

# 显示带有边界框的图像
cv2_imshow(image_with_bbox)
cv2.waitKey(0)
cv2.destroyAllWindows()

import pandas as pd
import subprocess

# 讀取 CSV 文件
df = pd.read_excel('/content/Utility_Poles.xlsx')

# 定義下載地圖的函數
def download_map(latitude, longitude, image_width=1000, image_height=1000, width=35, height=35):
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        f'--image_width', str(image_width),
        f'--image_height', str(image_height),
        f'-w', str(width),
        f'-h', str(height)
    ]
    subprocess.run(command)

# 遍歷每一行，並對每個坐標執行下載操作
for index, row in df.iterrows():
    x = row['X']
    y = row['Y']
    print(f"Downloading map for coordinates: ({y}, {x})")
    download_map(latitude=y, longitude=x)

import pandas as pd
import subprocess
import matplotlib.pyplot as plt
import cv2
from google.colab.patches import cv2_imshow

# 读取 CSV 文件
df = pd.read_csv('/content/Utility_Poles.csv')

# 定义下载地图的函数
def download_map(latitude, longitude, image_width=1000, image_height=1000, width=30, height=30):
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p {latitude}', f'{longitude}',
        f'--image_width', str(image_width),
        f'--image_height', str(image_height),
        f'-w', str(width),
        f'-h', str(height)
    ]
    subprocess.run(command)

# 初始化一个新列来存储检测结果
df['Detection'] = ''

for index, row in df.iterrows():
    latitude = row['Y']
    longitude = row['X']

    print(f"Downloading map for coordinates: ({latitude}, {longitude})")
    download_map(latitude, longitude)

    # 生成下载图片的路径
    image_path = f"/content/aerialbot/aerialbot-{latitude}-{longitude}-60.0-60.0-0.03.jpg"

    # 使用训练好的模型检测是否有电线杆
    results = model(image_path)

    # 检查是否有检测结果
    if results:
        df.at[index, 'Detection'] = '✔'
    else:
        df.at[index, 'Detection'] = 'x'

    # 显示带有边界框的结果图像（可选）
    result_image = results[0].plot()
    plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()

# 保存新的 Excel 文件
df.to_excel('/Result.xlsx', index=False)

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

# 讀取 CSV 文件
df = pd.read_excel('/content/Utility_Poles.xlsx')

# 隨機選擇 2000 個唯一的坐標
selected_coordinates = df.sample(n=2000, replace=False, random_state=42)

import subprocess
import random
import os
from math import sin, cos, radians, degrees, atan2, asin, atan

n=0

# 定義下載地圖的函數
def download_map(latitude, longitude):
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        '--image_width', '1000',
        '--image_height', '1000',
        '-w', '35',
        '-h', '35'
    ]
    subprocess.run(command, check=True)

# 計算新坐標的函數
def calculate_new_coordinates(lat, lon, distance):
    R = 6371000  # 地球半徑（米）

    # 隨機選擇一個方向（0-360度）
    bearing = radians(random.uniform(0, 360))

    # 將距離轉換為弧度
    angular_distance = distance / R

    lat1 = radians(lat)
    lon1 = radians(lon)

    lat2 = asin(sin(lat1) * cos(angular_distance) +
                cos(lat1) * sin(angular_distance) * cos(bearing))

    lon2 = lon1 + atan2(sin(bearing) * sin(angular_distance) * cos(lat1),
                        cos(angular_distance) - sin(lat1) * sin(lat2))

    return degrees(lat2), degrees(lon2)

# 遍歷選中的坐標，並對每個坐標執行下載操作
for index, row in selected_coordinates[832:].iterrows():
    x = row['X']
    y = row['Y']

    # 生成 5 到 10 米之間的隨機距離
    distance = random.uniform(5, 10)

    # 計算新的坐標
    new_y, new_x = calculate_new_coordinates(y, x, distance)
    download_map(latitude=new_y, longitude=new_x)
    n += 1
    print(n)