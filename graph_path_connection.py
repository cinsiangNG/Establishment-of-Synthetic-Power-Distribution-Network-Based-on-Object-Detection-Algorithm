# -*- coding: utf-8 -*-
"""Graph_path_connection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15kBVW6uX6WaePxnithUr7PzOwFlYLbZV
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
coordinates = pd.read_excel('/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/fused_poles_newdataset_Yolo11x+OriginalStreetview.xlsx')

lat = coordinates['Lat']
lon = coordinates['Lon']
coordinates = list(zip(lat, lon))
print(coordinates)

import numpy as np
import networkx as nx
from geopy.distance import geodesic
import plotly.graph_objects as go


# è¨ˆç®—åœ°ç†è·é›¢çš„è·é›¢çŸ©é™£
n = len(coordinates)
dist_matrix = np.zeros((n, n))
for i in range(n):
    for j in range(i + 1, n):
        dist = geodesic(coordinates[i], coordinates[j]).meters  # è¨ˆç®—å…©é»ä¹‹é–“çš„è·é›¢ï¼ˆä»¥ç±³ç‚ºå–®ä½ï¼‰
        dist_matrix[i, j] = dist_matrix[j, i] = dist

# å»ºç«‹åœ–ï¼ˆæ‰€æœ‰é»ç›¸é€£ï¼Œæ¬Šé‡ç‚ºåœ°ç†è·é›¢ï¼‰
G = nx.Graph()
for i in range(n):
    for j in range(i + 1, n):
        G.add_edge(i, j, weight=dist_matrix[i, j])

# è¨ˆç®— MSTï¼ˆæœ€å°ç”Ÿæˆæ¨¹ï¼‰
MST = nx.minimum_spanning_tree(G, algorithm='prim')

# å–å‡º MST é€£ç·šçš„é»
lats, lons = zip(*coordinates)  # æ‹†åˆ†ç·¯åº¦å’Œç¶“åº¦
edges_x = []
edges_y = []

# é€£ç·šçš„ x, y åº§æ¨™
for edge in MST.edges():
    i, j = edge
    edges_x.append([lons[i], lons[j]])
    edges_y.append([lats[i], lats[j]])

# ç•«åœ–
fig = go.Figure()

# ç•«å‡ºé›»ç·šæ†åº§æ¨™
fig.add_trace(go.Scattermapbox(
    lat=lats,
    lon=lons,
    mode='markers',
    name='Electric Poles',
    marker=dict(
        size=7,
        color='red',
        opacity=0.8
    )
))

# ç•«å‡º MST é€£ç·š
for x, y in zip(edges_x, edges_y):
    fig.add_trace(go.Scattermapbox(
        lat=y,
        lon=x,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='MST Connections'
    ))

# æ›´æ–°å¸ƒå±€
fig.update_layout(
    mapbox=dict(
        style='carto-positron',
        zoom=15,
        center=dict(
            lat=np.mean(lats),
            lon=np.mean(lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# é¡¯ç¤ºåœ–
fig.show()

# å®‰è£…æ‰€éœ€åº“
!pip install osmnx networkx pandas openpyxl

import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from scipy.spatial import distance_matrix

# è¯»å–ç”µçº¿æ†åæ ‡æ•°æ®
file_path = "/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/fused_poles_newdataset_Yolo11x+OriginalStreetview.xlsx"
df = pd.read_excel(file_path)

# åªä¿ç•™ Lat å’Œ Lonï¼Œå¹¶åˆ é™¤ç¼ºå¤±å€¼
df = df[['Lat', 'Lon']].dropna()

# è½¬æ¢æˆåˆ—è¡¨æ ¼å¼ [(lat, lon), ...]
pole_coordinates = list(zip(df['Lat'], df['Lon']))

# 1ï¸âƒ£ è·å–é“è·¯ç½‘ç»œ
place_name = "Jamaica Beach, Texas, USA"
G = ox.graph_from_place(place_name, network_type='drive')

# 2ï¸âƒ£ è®¡ç®— MSTï¼ˆæœ€å°ç”Ÿæˆæ ‘ï¼‰
pole_array = np.array(pole_coordinates)  # è½¬ NumPy æ•°ç»„
dist_matrix = distance_matrix(pole_array, pole_array)  # è®¡ç®—è·ç¦»çŸ©é˜µ

# åˆ›å»ºæ— å‘å›¾å¹¶æ·»åŠ  MST è¾¹
pole_graph = nx.Graph()
num_poles = len(pole_coordinates)
for i in range(num_poles):
    for j in range(i + 1, num_poles):
        pole_graph.add_edge(i, j, weight=dist_matrix[i, j])

# è®¡ç®—æœ€å°ç”Ÿæˆæ ‘ï¼ˆMSTï¼‰
mst = nx.minimum_spanning_tree(pole_graph)

# åˆ›å»ºç´¢å¼• â†’ åæ ‡æ˜ å°„
pole_index_to_coord = {i: pole_coordinates[i] for i in range(num_poles)}

# 3ï¸âƒ£ è®¡ç®—ç”µçº¿æ†æœ€è¿‘çš„é“è·¯èŠ‚ç‚¹
pole_nearest_nodes = [ox.distance.nearest_nodes(G, lon, lat) for lat, lon in pole_coordinates]

# 4ï¸âƒ£ ç»˜åˆ¶åœ°å›¾
fig, ax = ox.plot_graph(G, bgcolor="white", edge_color="blue", show=False, close=False)

# ç»˜åˆ¶ç”µçº¿æ†ï¼ˆçº¢è‰²ç‚¹ï¼‰
x_poles, y_poles = zip(*[(lon, lat) for lat, lon in pole_coordinates])
ax.scatter(x_poles, y_poles, c="red", s=7, label="ç”µçº¿æ†")

# ç»˜åˆ¶ MST çº¿æ®µï¼ˆç»¿è‰²ï¼‰
for i, (idx1, idx2) in enumerate(mst.edges()):
    lat1, lon1 = pole_index_to_coord[idx1]
    lat2, lon2 = pole_index_to_coord[idx2]
    ax.plot([lon1, lon2], [lat1, lat2], "g-", linewidth=2, label="æœ€å°ç”Ÿæˆæ ‘" if i == 0 else "")

# ç»˜åˆ¶ç”µçº¿æ†åˆ°é“è·¯çš„è¿æ¥ï¼ˆæ©™è‰²è™šçº¿ï¼‰
# for i, (pole, road_node) in enumerate(zip(pole_coordinates, pole_nearest_nodes)):
#     road_lat, road_lon = G.nodes[road_node]['y'], G.nodes[road_node]['x']
#     pole_lat, pole_lon = pole
#     ax.plot([pole_lon, road_lon], [pole_lat, road_lat], "orange", linestyle="dashed", linewidth=1.5, label="è¿æ¥åˆ°é“è·¯" if i == 0 else "")

plt.legend()
plt.show()