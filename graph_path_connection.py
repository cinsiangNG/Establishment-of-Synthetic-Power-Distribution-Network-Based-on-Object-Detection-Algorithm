# -*- coding: utf-8 -*-
"""Graph_path_connection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15kBVW6uX6WaePxnithUr7PzOwFlYLbZV
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
coordinates = pd.read_excel('/content/drive/MyDrive/黃俊翔_論文研究📚/fused_poles_newdataset_Yolo11x+OriginalStreetview.xlsx')

lat = coordinates['Lat']
lon = coordinates['Lon']
coordinates = list(zip(lat, lon))
print(coordinates)

import numpy as np
import networkx as nx
from geopy.distance import geodesic
import plotly.graph_objects as go


# 計算地理距離的距離矩陣
n = len(coordinates)
dist_matrix = np.zeros((n, n))
for i in range(n):
    for j in range(i + 1, n):
        dist = geodesic(coordinates[i], coordinates[j]).meters  # 計算兩點之間的距離（以米為單位）
        dist_matrix[i, j] = dist_matrix[j, i] = dist

# 建立圖（所有點相連，權重為地理距離）
G = nx.Graph()
for i in range(n):
    for j in range(i + 1, n):
        G.add_edge(i, j, weight=dist_matrix[i, j])

# 計算 MST（最小生成樹）
MST = nx.minimum_spanning_tree(G, algorithm='prim')

# 取出 MST 連線的點
lats, lons = zip(*coordinates)  # 拆分緯度和經度
edges_x = []
edges_y = []

# 連線的 x, y 座標
for edge in MST.edges():
    i, j = edge
    edges_x.append([lons[i], lons[j]])
    edges_y.append([lats[i], lats[j]])

# 畫圖
fig = go.Figure()

# 畫出電線杆座標
fig.add_trace(go.Scattermapbox(
    lat=lats,
    lon=lons,
    mode='markers',
    name='Electric Poles',
    marker=dict(
        size=7,
        color='red',
        opacity=0.8
    )
))

# 畫出 MST 連線
for x, y in zip(edges_x, edges_y):
    fig.add_trace(go.Scattermapbox(
        lat=y,
        lon=x,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='MST Connections'
    ))

# 更新布局
fig.update_layout(
    mapbox=dict(
        style='carto-positron',
        zoom=15,
        center=dict(
            lat=np.mean(lats),
            lon=np.mean(lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖
fig.show()

# 安装所需库
!pip install osmnx networkx pandas openpyxl

import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from scipy.spatial import distance_matrix

# 读取电线杆坐标数据
file_path = "/content/drive/MyDrive/黃俊翔_論文研究📚/fused_poles_newdataset_Yolo11x+OriginalStreetview.xlsx"
df = pd.read_excel(file_path)

# 只保留 Lat 和 Lon，并删除缺失值
df = df[['Lat', 'Lon']].dropna()

# 转换成列表格式 [(lat, lon), ...]
pole_coordinates = list(zip(df['Lat'], df['Lon']))

# 1️⃣ 获取道路网络
place_name = "Jamaica Beach, Texas, USA"
G = ox.graph_from_place(place_name, network_type='drive')

# 2️⃣ 计算 MST（最小生成树）
pole_array = np.array(pole_coordinates)  # 转 NumPy 数组
dist_matrix = distance_matrix(pole_array, pole_array)  # 计算距离矩阵

# 创建无向图并添加 MST 边
pole_graph = nx.Graph()
num_poles = len(pole_coordinates)
for i in range(num_poles):
    for j in range(i + 1, num_poles):
        pole_graph.add_edge(i, j, weight=dist_matrix[i, j])

# 计算最小生成树（MST）
mst = nx.minimum_spanning_tree(pole_graph)

# 创建索引 → 坐标映射
pole_index_to_coord = {i: pole_coordinates[i] for i in range(num_poles)}

# 3️⃣ 计算电线杆最近的道路节点
pole_nearest_nodes = [ox.distance.nearest_nodes(G, lon, lat) for lat, lon in pole_coordinates]

# 4️⃣ 绘制地图
fig, ax = ox.plot_graph(G, bgcolor="white", edge_color="blue", show=False, close=False)

# 绘制电线杆（红色点）
x_poles, y_poles = zip(*[(lon, lat) for lat, lon in pole_coordinates])
ax.scatter(x_poles, y_poles, c="red", s=7, label="电线杆")

# 绘制 MST 线段（绿色）
for i, (idx1, idx2) in enumerate(mst.edges()):
    lat1, lon1 = pole_index_to_coord[idx1]
    lat2, lon2 = pole_index_to_coord[idx2]
    ax.plot([lon1, lon2], [lat1, lat2], "g-", linewidth=2, label="最小生成树" if i == 0 else "")

# 绘制电线杆到道路的连接（橙色虚线）
# for i, (pole, road_node) in enumerate(zip(pole_coordinates, pole_nearest_nodes)):
#     road_lat, road_lon = G.nodes[road_node]['y'], G.nodes[road_node]['x']
#     pole_lat, pole_lon = pole
#     ax.plot([pole_lon, road_lon], [pole_lat, road_lat], "orange", linestyle="dashed", linewidth=1.5, label="连接到道路" if i == 0 else "")

plt.legend()
plt.show()