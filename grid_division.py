# -*- coding: utf-8 -*-
"""Grid_Division.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kUdY5RXUfLJYgWUuLh1rJhisgDaitZTd
"""

!pip install streetlevel

import pandas as pd
# read ROI route points (locations to download street view images)

workingdirectory = '/content/'

LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv")
# LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv",converters={'panoid':str})
# RouteIDs = LumbertonRoutesPoints['RTE_NM'].unique() # unique route ID
LumbertonRoutesPoints = LumbertonRoutesPoints.drop_duplicates()
LumbertonRoutesPoints.info()

# prepare required functions
import math

def decode_polyline(polyline_str):
    '''Pass a Google Maps encoded polyline string; returns list of lat/lon pairs'''
    index, lat, lng = 0, 0, 0
    coordinates = []
    changes = {'latitude': 0, 'longitude': 0}

    # Coordinates have variable length when encoded, so just keep
    # track of whether we've hit the end of the string. In each
    # while loop iteration, a single coordinate is decoded.
    while index < len(polyline_str):
        # Gather lat/lon changes, store them in a dictionary to apply them later
        for unit in ['latitude', 'longitude']:
            shift, result = 0, 0
            while True:
                byte = ord(polyline_str[index]) - 63
                index += 1
                result |= (byte & 0x1f) << shift
                shift += 5
                if not byte >= 0x20:
                    break
            if (result & 1):
                changes[unit] = ~(result >> 1)
            else:
                changes[unit] = (result >> 1)
        lat += changes['latitude']
        lng += changes['longitude']
        coordinates.append((lat / 100000.0, lng / 100000.0))
    return coordinates

def getpathpoints(dirs,pts_distance=50):
  # polypath = dirs[0]['legs'][0]['steps'][0]['polyline']['points']
  polypath = dirs[0]['overview_polyline']['points']
  polypath_pts = decode_polyline(polypath)
  pts_coords = []
  for pt in range(1, len(polypath_pts)):
    lat1 = polypath_pts[pt-1][0]
    lng1 = polypath_pts[pt-1][1]
    lat2 = polypath_pts[pt][0]
    lng2 = polypath_pts[pt][1]
    azimuth = calculateBearing(lat1,lng1,lat2,lng2)
    coords = getInnerPoints(pts_distance,azimuth,lat1,lng1,lat2,lng2)
    if pt==1:
      pts_coords.append(coords)
    else:
      pts_coords.append(coords[1:])
  flatten_pts_coords = []
  for subl in pts_coords:
      for item in subl:
          flatten_pts_coords.append(item)
  return flatten_pts_coords

def getPathLength(lat1,lng1,lat2,lng2):
    '''calculates the distance between two lat, long coordinate pairs'''
    R = 6371000 # radius of earth in m
    lat1rads = math.radians(lat1)
    lat2rads = math.radians(lat2)
    deltaLat = math.radians((lat2-lat1))
    deltaLng = math.radians((lng2-lng1))
    a = math.sin(deltaLat/2) * math.sin(deltaLat/2) + math.cos(lat1rads) * math.cos(lat2rads) * math.sin(deltaLng/2) * math.sin(deltaLng/2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = R * c
    return d

def getDestinationLatLong(lat,lng,azimuth,distance):
    '''returns the lat an long of destination point
    given the start lat, long, aziuth, and distance'''
    R = 6378.1 #Radius of the Earth in km
    brng = math.radians(azimuth) #Bearing is degrees converted to radians.
    d = distance/1000 #Distance m converted to km
    lat1 = math.radians(lat) #Current dd lat point converted to radians
    lon1 = math.radians(lng) #Current dd long point converted to radians
    lat2 = math.asin(math.sin(lat1) * math.cos(d/R) + math.cos(lat1)* math.sin(d/R)* math.cos(brng))
    lon2 = lon1 + math.atan2(math.sin(brng) * math.sin(d/R)* math.cos(lat1), math.cos(d/R)- math.sin(lat1)* math.sin(lat2))
    #convert back to degrees
    lat2 = math.degrees(lat2)
    lon2 = math.degrees(lon2)
    return[lat2, lon2]

def calculateBearing(lat1,lng1,lat2,lng2):
    '''calculates the azimuth in degrees from start point to end point'''
    startLat = math.radians(lat1)
    startLong = math.radians(lng1)
    endLat = math.radians(lat2)
    endLong = math.radians(lng2)
    dLong = endLong - startLong
    dPhi = math.log(math.tan(endLat/2.0+math.pi/4.0)/math.tan(startLat/2.0+math.pi/4.0))
    if abs(dLong) > math.pi:
         if dLong > 0.0:
             dLong = -(2.0 * math.pi - dLong)
         else:
             dLong = (2.0 * math.pi + dLong)
    bearing = (math.degrees(math.atan2(dLong, dPhi)) + 360.0) % 360.0;
    return bearing

def getInnerPoints(interval,azimuth,lat1,lng1,lat2,lng2):
    '''returns every coordinate pair inbetween two coordinate
    pairs given the desired interval'''

    d = getPathLength(lat1,lng1,lat2,lng2)
    remainder, dist = math.modf((d / interval))
    counter = float(interval)
    coords = []
    coords.append([lat1,lng1])
    for distance in range(0,int(dist)):
        coord = getDestinationLatLong(lat1,lng1,azimuth,counter)
        counter = counter + float(interval)
        coords.append(coord)
    coords.append([lat2,lng2])
    return coords

def samepoint(line1, line2):
  result = False
  for x in line1:
    for y in line2:
      if x == y:
        result = True
        return x
        break
  return result

def find_intersection(p0, p1, p2, p3):
    # line1 = [p0.tolist(),p1.tolist()]
    # line2 = [p2.tolist(),p3.tolist()]
    line1 = [p0,p1]
    line2 = [p2,p3]
    samept = samepoint(line1,line2)
    if samept is not False:
      intersection_point = samept
    else:
      s10_x = p1[0] - p0[0]
      s10_y = p1[1] - p0[1]
      s32_x = p3[0] - p2[0]
      s32_y = p3[1] - p2[1]
      denom = s10_x * s32_y - s32_x * s10_y
      if denom == 0 : return math.nan # collinear
      denom_is_positive = denom > 0
      s02_x = p0[0] - p2[0]
      s02_y = p0[1] - p2[1]
      s_numer = s10_x * s02_y - s10_y * s02_x
      if (s_numer < 0) == denom_is_positive : return math.nan # no collision
      t_numer = s32_x * s02_y - s32_y * s02_x
      if (t_numer < 0) == denom_is_positive : return math.nan # no collision
      if (s_numer > denom) == denom_is_positive or (t_numer > denom) == denom_is_positive : return math.nan # no collision
      # collision detected
      t = t_numer / denom
      intersection_point = [ p0[0] + (t * s10_x), p0[1] + (t * s10_y) ]
    return intersection_point

import numpy as np
import math

def calculate_baseline_length(trajectory_points):
    """
    计算轨迹基线长度

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon],...]

    Returns:
        baseline: 基线长度(米)
    """
    total_length = 0
    for i in range(len(trajectory_points)-1):
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[i+1]
        # 使用已有的getPathLength函数计算两点间距离
        length = getPathLength(pt1[0], pt1[1], pt2[0], pt2[1])
        total_length += length

    # 返回平均段长作为基线长度
    return total_length / (len(trajectory_points)-1)

from geopy.distance import geodesic

def calculate_mst_baseline(trajectory_points, MST):
    """
    计算 MST 的基线长度

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon],...]
        MST: NetworkX 计算出的最小生成树 (Minimum Spanning Tree)

    Returns:
        baseline: 基线长度(米)
    """
    total_length = 0
    edge_count = 0

    for i, j in MST.edges():
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[j]
        length = geodesic(pt1, pt2).meters  # 計算地理距離
        total_length += length
        edge_count += 1
        print(i,j, trajectory_points[i], trajectory_points[j])

    # 返回平均邊長作為基線
    return total_length / edge_count if edge_count > 0 else 0


def create_grid_cells(trajectory_points, effective_distance):
    """
    基于轨迹点划分自适应网格

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon], ...]
        effective_distance: 影响范围（用于计算网格大小）

    Returns:
        grid_cells: 自适应网格划分的结果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
    """

    bl = calculate_baseline_length(trajectory_points)
    grid_cells = []
    # 计算轨迹的边界范围
    min_lon = min(pt[1] for pt in trajectory_points)  # 经度
    max_lon = max(pt[1] for pt in trajectory_points)
    min_lat = min(pt[0] for pt in trajectory_points)  # 纬度
    max_lat = max(pt[0] for pt in trajectory_points)
    lat_start = min_lat
    lon_start = min_lon
    lat_end = max_lat
    lon_end = max_lon
    grid = [
        [lat_start, lon_start],
        [lat_end, lon_start],
        [lat_end, lon_end],
        [lat_start, lon_end]
        ]
    grid_cells.append(grid)
    print(grid_cells)
    return grid_cells

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory_and_grid(trajectory_points, grid_cells):
    """
    視覺化行駛軌跡點與不同顏色的自適應網格

    Args:
        trajectory_points: 行駛軌跡點 (list of [lat, lon])
        grid_cells:  自适应网格划分的结果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
    """
    # 創建地圖
    fig = go.Figure()

    # 1️⃣ 添加行駛軌跡點 (藍色線條)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        # mode='lines+markers',
        name='Trajectory',
        # line=dict(width=2, color='blue'),
        marker=dict(size=5, color='blue')
    ))

    # 2️⃣ 生成不同顏色的網格
    colors = ['red', 'green', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'lime', 'teal', 'orange']

    for i, cell in enumerate(grid_cells):
        cell.append(cell[0])  # 闭合多边形
        grid_color = random.choice(colors)  # 隨機選擇顏色
        fig.add_trace(go.Scattermapbox(
            lat=[pt[0] for pt in cell],
            lon=[pt[1] for pt in cell],
            mode='lines',
            line=dict(width=2, color=grid_color),
            name=f'Grid {i+1}'
        ))

    # 3️⃣ 更新地圖布局
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory(trajectory_points):
    """
    視覺化行駛軌跡點與不同顏色的自適應網格

    Args:
        trajectory_points: 行駛軌跡點 (list of [lat, lon])
        grid_cells:  自适应网格划分的结果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
    """
    # 創建地圖
    fig = go.Figure()

    # 1️⃣ 添加行駛軌跡點 (藍色線條)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        mode='markers',
        name='Trajectory',
        marker=dict(size=5, color='blue')
    ))


    # 3️⃣ 更新地圖布局
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

import numpy as np
import pandas as pd
from streetlevel import streetview

# 参数设置
dist_para = [40*304.8, 1.5, 4.55, 10]
size = (640, 640)
EFFECTIVE_DISTANCE = 50  # 有效采集距离(米)

# 文件路径
path1 = workingdirectory + 'StreetViewImages/'
path2 = workingdirectory + 'resized/'
savepreddir = workingdirectory + 'PolePredictionResults/'

totaldownload = 0

for rr in range(0,len(RouteIDs)):
    routeid = RouteIDs[rr]
    routepoints = LumbertonRoutesPoints.loc[LumbertonRoutesPoints['RTE_NM'] == routeid]
    Pts2downloadPano = routepoints[['Lat','Lon']].values.tolist()

    # 获取街景全景信息
    allpanoid = []
    for panoLatLon in Pts2downloadPano:
        pano = streetview.find_panorama(lat=panoLatLon[0], lon=panoLatLon[1])
        if bool(pano):
            allpanoid.append([pano.id, pano.lat, pano.lon])
    PanoInfoFinal = pd.DataFrame(allpanoid,columns=['panoid','lat','lon']).drop_duplicates()
    print(PanoInfoFinal)

    # 只处理超过3个全景点的路段
    if len(PanoInfoFinal) > 3:
        poleview = []  # 路径上的结果 [相机坐标, 杆体方位角]
        poleLOB = []   # 建议的LOB [起点坐标(相机), 终点坐标]

        # 自适应网格划分
        trajectory_points = PanoInfoFinal[['lat','lon']].values.tolist()
        grid_cells = create_grid_cells(trajectory_points, EFFECTIVE_DISTANCE)
        fig = plot_trajectory_and_grid(trajectory_points, grid_cells)
        fig.show()

"""# **Create outer grid and do grid division(divide outer large grid into several small grid)**"""

import numpy as np
import pandas as pd
from streetlevel import streetview

# 参数设置
dist_para = [40*304.8, 1.5, 4.55, 10]
size = (640, 640)
EFFECTIVE_DISTANCE = 50  # 有效采集距离(米)

# 文件路径
path1 = workingdirectory + 'StreetViewImages/'
path2 = workingdirectory + 'resized/'
savepreddir = workingdirectory + 'PolePredictionResults/'

totaldownload = 0
trajectory_points = LumbertonRoutesPoints[['Lat','Lon']].values.tolist()
print(len(trajectory_points))
grid_cells = create_grid_cells(trajectory_points,EFFECTIVE_DISTANCE)

fig = plot_trajectory_and_grid(trajectory_points, grid_cells)
fig.show()

"""***- use MST to link the trajectory point and stored them in edge_x and edge_y in increasing order of length(m).***"""

import numpy as np
import networkx as nx
from geopy.distance import geodesic
import plotly.graph_objects as go

print(len(trajectory_points))
# 計算地理距離的距離矩陣
n = len(trajectory_points)
dist_matrix = np.zeros((n, n))
for i in range(n):
    for j in range(i + 1, n):
        dist = geodesic(trajectory_points[i], trajectory_points[j]).meters  # 計算兩點之間的距離（以米為單位）
        dist_matrix[i, j] = dist_matrix[j, i] = dist

# 建立圖（所有點相連，權重為地理距離）
G = nx.Graph()
for i in range(n):
    for j in range(i + 1, n):
        G.add_edge(i, j, weight=dist_matrix[i, j])

# 計算 MST（最小生成樹）
MST = nx.minimum_spanning_tree(G, algorithm='prim')

# 取出 MST 連線的點
lats, lons = zip(*trajectory_points)  # 拆分緯度和經度
edges_x = []
edges_y = []

# 連線的 x, y 座標
for edge in MST.edges():
    i, j = edge
    edges_x.append([lons[i], lons[j]])
    edges_y.append([lats[i], lats[j]])

# 畫圖
# fig = go.Figure()

# # 畫出電線杆座標
# fig.add_trace(go.Scattermapbox(
#     lat=lats,
#     lon=lons,
#     mode='markers',
#     name='Electric Poles',
#     marker=dict(
#         size=7,
#         color='red',
#         opacity=0.8
#     )
# ))

# # 畫出 MST 連線
# for x, y in zip(edges_x, edges_y):
#     fig.add_trace(go.Scattermapbox(
#         lat=y,
#         lon=x,
#         mode='lines',
#         line=dict(width=2, color='blue'),
#         name='MST Connections'
#     ))

# # 更新布局
# fig.update_layout(
#     mapbox=dict(
#         style='carto-positron',
#         zoom=15,
#         center=dict(
#             lat=np.mean(lats),
#             lon=np.mean(lons)
#         )
#     ),
#     height=800,
#     margin=dict(l=0, r=0, t=0, b=0),
#     showlegend=True,
#     legend=dict(
#         yanchor="top",
#         y=0.99,
#         xanchor="left",
#         x=0.01,
#         bgcolor='rgba(255,255,255,0.8)'
#     )
# )

# # 顯示圖
# fig.show()

# 計算基線長度
baseline_length = calculate_mst_baseline(trajectory_points, MST)
print("MST Baseline Length:", baseline_length, "meters")

"""***- calculate k, dist_y, dist_x, nrow and ncol.***"""

grid_cells_flatten = grid_cells[0]
print(grid_cells_flatten)
#左下，左上，右上，右下
k = (1+(50/(2*math.sqrt(2)*baseline_length)))/2
print(50/(2*math.sqrt(2)*baseline_length))
print(k)
dist_y = geodesic(grid_cells_flatten[1],grid_cells_flatten[0]).meters
dist_x = geodesic(grid_cells_flatten[2],grid_cells_flatten[1]).meters
print("垂直距離：",dist_y, "\n水平距離：",dist_x)
nrow = math.ceil(dist_y/(k*baseline_length))
ncol = math.ceil(dist_x/(k*baseline_length))
print("nrow: ",nrow, "\nncol: ",ncol)

import numpy as np
from geopy.distance import geodesic

# 获取四个角点
p1, p2, p3, p4 = grid_cells_flatten[:4]

# 计算步长
step_y = dist_y / nrow
step_x = dist_x / ncol

# 生成网格点
lat_values = np.linspace(p1[0], p2[0], nrow + 1)  # 纵向切分点
lon_values = np.linspace(p1[1], p3[1], ncol + 1)  # 横向切分点

# 存储所有 grid cells
each_grid_cells = []

# 迭代生成所有小网格
for i in range(nrow):
    for j in range(ncol):
        lat1, lat2 = lat_values[i], lat_values[i + 1]
        lon1, lon2 = lon_values[j], lon_values[j + 1]

        # 构造一个 grid cell
        grid_cell = [
            [lat1, lon1],  # 左下角
            [lat2, lon1],  # 左上角
            [lat2, lon2],  # 右上角
            [lat1, lon2],  # 右下角
            [lat1, lon1]
        ]

        each_grid_cells.append(grid_cell)

# 输出示例
print(f"总网格数: {len(each_grid_cells)}")
print("示例网格:", each_grid_cells)

"""# **Visualise the grid cell**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()


for grid_cell in grid_cells:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Outer Grid Cell'
    ))

for grid_cell in each_grid_cells[15500:16000]:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='green'),
        name='Grid Cell'
    ))

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='carto-positron',
        zoom=15,
        center=dict(
            lat=np.mean([pt[0] for cell in each_grid_cells for pt in cell]),
            lon=np.mean([pt[1] for cell in each_grid_cells for pt in cell])
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖
fig.show()

"""# **Create grid_info which contain the grid for record and also calculation.**"""

import numpy as np

# 計算每個 MST 點所屬的 grid(recorded)
min_lon = min(pt[1] for pt in trajectory_points)  # 经度
max_lon = max(pt[1] for pt in trajectory_points)
min_lat = min(pt[0] for pt in trajectory_points)  # 纬度
max_lat = max(pt[0] for pt in trajectory_points)
bl=baseline_length

# 記錄每個 MST 點對應的 grid(recorded) 及其周圍的 grid(calculation)
grid_info = []

# 轉換比例
def meters_to_lat(meters):
    return meters / 110540  # 1度緯度約110540米

def meters_to_lon(meters, lat):
    return meters / (111320 * np.cos(np.radians(lat)))  # 1度經度約111320米 * cos(緯度)

for lat, lon in zip(lats, lons):
    delta_lat = meters_to_lat(k * bl)
    delta_lon = meters_to_lon(k * bl, lat)

    col = int((lon - min_lon) / delta_lon)
    row = int((lat - min_lat) / delta_lat)

    grid_recorded = {
        "row": row,
        "col": col,
        "grid": [
            [min_lon + col * delta_lon, min_lat + row * delta_lat],  # 左下
            [min_lon + (col + 1) * delta_lon, min_lat + row * delta_lat],  # 右下
            [min_lon + (col + 1) * delta_lon, min_lat + (row + 1) * delta_lat],  # 右上
            [min_lon + col * delta_lon, min_lat + (row + 1) * delta_lat],  # 左上
            [min_lon + col * delta_lon, min_lat + row * delta_lat]  # 回到左下
        ]
    }

    # 計算 grid(calculation) 範圍 (包含周圍8個 grid)
    grid_calculation = [
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat],  # 左下
        [min_lon + (col + 2) * delta_lon, min_lat + (row - 1) * delta_lat],  # 右下
        [min_lon + (col + 2) * delta_lon, min_lat + (row + 2) * delta_lat],  # 右上
        [min_lon + (col - 1) * delta_lon, min_lat + (row + 2) * delta_lat],  # 左上
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat]  # 回到左下
    ]

    grid_info.append({
        "recorded": grid_recorded,
        "calculation": grid_calculation
    })


# 這樣每個 MST 點都會對應一個 grid(recorded) 及其周圍 9 個 grid(calculation)

"""# **Visualise grid for record and also calculation**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 取得第一個 grid_calculation 和 grid_recorded
first_grid_info = grid_info[50]

# 畫出 grid_calculation（藍色）
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]  # 緯度
lon_values = [pt[0] for pt in grid_calculation]  # 經度
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# 畫出 grid_recorded（紅色）
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]  # 緯度
lon_values = [pt[0] for pt in grid_recorded]  # 經度
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# 計算地圖中心點
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # 使用免費地圖
        zoom=12,  # 減少 zoom 避免太靠近
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖
print(first_grid_info)
fig.show()

print(grid_info[0]['calculation'])

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 記錄所有點的經緯度，以便計算地圖中心
all_lats = []
all_lons = []

# 遍歷 grid_info[50:100]
for grid_data in grid_info[1150:1175]:
    # 繪製 grid_calculation（藍色）
    grid_calculation = grid_data["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]  # 緯度
    lon_values = [pt[0] for pt in grid_calculation]  # 經度
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation'
    ))

    # 繪製 grid_recorded（紅色）
    grid_recorded = grid_data["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]  # 緯度
    lon_values = [pt[0] for pt in grid_recorded]  # 經度
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded'
    ))

    # 累積所有點的經緯度
    all_lats.extend([pt[1] for pt in grid_calculation + grid_recorded])
    all_lons.extend([pt[0] for pt in grid_calculation + grid_recorded])

# 設定地圖中心
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # 使用免費地圖
        zoom=12,  # 適當縮放
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖表
fig.show()

from google.colab import drive
drive.mount("/content/drive")

LOBS = pd.read_csv("/content/poleLOB_original.csv")
print(len(LOBS))
LOBS = LOBS.drop_duplicates(subset=["start_lat", "start_lon", "end_lat", "end_lon"])
# LOBS.to_csv("/content/poleLOB_drop_duplicates.csv")
print(len(LOBS))

"""# **Remove duplicate of LOBS and also categorize them in proper grid respectively.**"""

from shapely.geometry import Point, Polygon

for grid in grid_info:
    grid_polygon_coords = grid['calculation']
    polygon = Polygon(grid_polygon_coords)
    lobs_in_polygon = set()  # 使用 set 自動去除重複

    for _, row in LOBS.iterrows():
        start_point = Point(row["start_lon"], row["start_lat"])
        end_point = Point(row["end_lon"], row["end_lat"])

        if polygon.contains(start_point) or polygon.contains(end_point):
            lob = (
                row["start_lat"], row["start_lon"],
                row["end_lat"], row["end_lon"]
            )
            lobs_in_polygon.add(lob)  # 加入 set，自動去除重複

    # 將 set 轉為 list 存入 grid 中
    grid['lobs_in_polygon'] = list(lobs_in_polygon)

print(len(grid_info[1151]['lobs_in_polygon']))
print(grid_info[1151]['lobs_in_polygon'])

"""# **Visualise the grid for calculation and LOBs inside the grid**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 取得指定 grid_info
first_grid_info = grid_info[1151]

# 畫出 grid_calculation（藍色）
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]
lon_values = [pt[0] for pt in grid_calculation]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],  # 閉合多邊形
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# 畫出 grid_recorded（紅色）
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]
lon_values = [pt[0] for pt in grid_recorded]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# 畫出 intersecting LOBs（綠色）
for lob in first_grid_info["lobs_in_polygon"]:
    start_lat, start_lon, end_lat, end_lon = lob
    fig.add_trace(go.Scattermapbox(
        lat=[start_lat, end_lat],
        lon=[start_lon, end_lon],
        mode='lines+markers',
        line=dict(width=2, color='green'),
        marker=dict(size=6, color='green'),
        name='LOB in Grid',
        showlegend=False  # 避免重複圖例
    ))

# 計算地圖中心
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖與確認資料
print(first_grid_info)
fig.show()

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 記錄所有經緯度以便計算地圖中心
all_lats = []
all_lons = []

# 取得多個 grid_info
for grid in grid_info[1150:1175]:
    # 畫出 grid_calculation（藍色）
    grid_calculation = grid["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]
    lon_values = [pt[0] for pt in grid_calculation]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation',
        showlegend=False
    ))

    # 畫出 grid_recorded（紅色）
    grid_recorded = grid["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]
    lon_values = [pt[0] for pt in grid_recorded]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded',
        showlegend=False
    ))

    # 畫出 intersecting LOBs（綠色）
    for lob in grid["lobs_in_polygon"]:
        start_lat, start_lon, end_lat, end_lon = lob
        fig.add_trace(go.Scattermapbox(
            lat=[start_lat, end_lat],
            lon=[start_lon, end_lon],
            mode='lines+markers',
            line=dict(width=2, color='green'),
            marker=dict(size=6, color='green'),
            name='LOB in Grid',
            showlegend=False
        ))

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

"""# **Append 2 tupple in grid_info(intersections and lobs_intersection)**
***- to find the intersection of LOBs in grid***
"""

from shapely.geometry import LineString

for grid in grid_info:
    grid_polygon_coords = grid['calculation']
    polygon = Polygon(grid_polygon_coords)

    lobs = grid.get('lobs_in_polygon', [])
    intersections = set()
    intersection_lobs = set()

    # 兩兩配對找交點
    for i in range(len(lobs)):
        for j in range(i + 1, len(lobs)):
            lob1 = lobs[i]
            lob2 = lobs[j]

            line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])  # (lon, lat)
            line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

            if line1.intersects(line2):
                intersection = line1.intersection(line2)

                # 檢查是否為點，並且該點在 grid polygon 裡
                if intersection.geom_type == 'Point' and polygon.contains(intersection):
                    intersections.add((intersection.y, intersection.x))  # 存為 (lat, lon)
                    intersection_lobs.add(tuple(lob1))
                    intersection_lobs.add(tuple(lob2))

    # 存回 grid
    grid['intersections'] = [list(pt) for pt in intersections]
    grid['intersection_lobs'] = [list(lob) for lob in intersection_lobs]

print(len(grid_info[1151]['intersections']))
print(len(grid_info[1151]['intersection_lobs']))

"""# **Visualise the grid for calculation and intersectinon_LOBs inside the grid**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 記錄所有經緯度以便計算地圖中心
all_lats = []
all_lons = []

# 取得多個 grid_info
for grid in grid_info[1151:1152]:
    # 畫出 grid_calculation（藍色）
    grid_calculation = grid["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]
    lon_values = [pt[0] for pt in grid_calculation]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation',
        showlegend=False
    ))

    # 畫出 grid_recorded（紅色）
    grid_recorded = grid["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]
    lon_values = [pt[0] for pt in grid_recorded]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded',
        showlegend=False
    ))

    # 畫出 intersecting LOBs（綠色）
    for lob in grid["intersection_lobs"]:
        start_lat, start_lon, end_lat, end_lon = lob
        fig.add_trace(go.Scattermapbox(
            lat=[start_lat, end_lat],
            lon=[start_lon, end_lon],
            mode='lines+markers',
            line=dict(width=2, color='green'),
            marker=dict(size=6, color='green'),
            name='LOB in Grid',
            showlegend=False
        ))

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

print(grid_info[1151]['intersection_lobs'])

"""# **Create Intersection Matrix**"""

import pandas as pd
import numpy as np
from shapely.geometry import LineString, Point
from collections import defaultdict
import matplotlib.pyplot as plt

intersection_lobs = [
    [float(a), float(b), float(c), float(d)]
    for a, b, c, d in grid_info[1151]['intersection_lobs']
]

start_point_groups = defaultdict(list)

for lob in intersection_lobs:
    start = (lob[0], lob[1])
    start_point_groups[start].append(lob)

labels = {}
label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
lob_list = []
label_index = 0

for group_start, lobs in sorted(start_point_groups.items()):
    for i, lob in enumerate(lobs):
        label = f"{label_prefix[label_index]}{i+1}"
        labels[tuple(lob)] = label
        lob_list.append((lob, label))
    label_index += 1

n = len(lob_list)
matrix = [['-' for _ in range(n)] for _ in range(n)]
label_list = [label for _, label in lob_list]

for i in range(n):
    for j in range(n):
        if i == j:
            matrix[i][j] = '—'
            continue
        lob1, label1 = lob_list[i]
        lob2, label2 = lob_list[j]
        line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])
        line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

        if line1.intersects(line2):
            matrix[i][j] = f"P({label1}x{label2})"

df_matrix = pd.DataFrame(matrix, columns=label_list, index=label_list)
display(df_matrix)

import pandas as pd
import numpy as np
from shapely.geometry import LineString, Point
from collections import defaultdict
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN

# 设定距离阈值 t (单位：公里或米)
t = 0.0001  # 示例值，可以根据实际需求调整

# 获取交点 LOB 数据
intersection_lobs = [
    [float(a), float(b), float(c), float(d)]
    for a, b, c, d in grid_info[1151]['intersection_lobs']
]

# 按起点对 LOB 数据进行分组
start_point_groups = defaultdict(list)

for lob in intersection_lobs:
    start = (lob[0], lob[1])
    start_point_groups[start].append(lob)

# 为每个 LOB 加上标签
labels = {}
label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
lob_list = []
label_index = 0

for group_start, lobs in sorted(start_point_groups.items()):
    for i, lob in enumerate(lobs):
        label = f"{label_prefix[label_index]}{i+1}"
        labels[tuple(lob)] = label
        lob_list.append((lob, label))
    label_index += 1

# 计算交点矩阵并初始化
n = len(lob_list)
matrix = [['-' for _ in range(n)] for _ in range(n)]
label_list = [label for _, label in lob_list]

# 创建交点矩阵
for i in range(n):
    for j in range(n):
        if i == j:
            matrix[i][j] = '—'
            continue
        lob1, label1 = lob_list[i]
        lob2, label2 = lob_list[j]
        line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])
        line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

        if line1.intersects(line2):
            matrix[i][j] = f"P({label1}x{label2})"

# 计算交点的坐标并聚类
points = []
for lob in lob_list:
    line = LineString([(lob[1], lob[0]), (lob[3], lob[2])])
    if line.intersects:
        intersection_point = line.intersection(line)
        if isinstance(intersection_point, Point):
            points.append([intersection_point.x, intersection_point.y])

# 使用 DBSCAN 聚类算法按距离 t 进行聚类
db = DBSCAN(eps=t, min_samples=1, metric='euclidean')
clusters = db.fit_predict(points)

# 将聚类结果添加到交点矩阵中，并为每个交点根据聚类上色
cluster_colors = {i: plt.cm.get_cmap('tab20', len(set(clusters)))(i) for i in range(len(set(clusters)))}
cluster_labels = {lob_list[i][1]: clusters[i] for i in range(n)}

# 根据聚类结果为交点矩阵上色
fig, ax = plt.subplots(figsize=(10, 8))
ax.axis('tight')
ax.axis('off')

# 绘制矩阵并根据聚类为交点添加颜色
for i in range(n):
    for j in range(n):
        if matrix[i][j] != '-':
            cluster1 = cluster_labels[lob_list[i][1]]
            cluster2 = cluster_labels[lob_list[j][1]]
            color = cluster_colors[min(cluster1, cluster2)]  # 可以根据交点的聚类关系决定颜色
            ax.text(j, i, matrix[i][j], ha='center', va='center', fontsize=12,
                    bbox=dict(facecolor=color, edgecolor='none', boxstyle='round,pad=0.5'))

# 绘制结果矩阵
plt.show()

# 将结果转换为 DataFrame 并显示
df_matrix = pd.DataFrame(matrix, columns=label_list, index=label_list)
display(df_matrix)