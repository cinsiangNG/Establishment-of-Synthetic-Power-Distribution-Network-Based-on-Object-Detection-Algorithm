# -*- coding: utf-8 -*-
"""Grid_Division.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kUdY5RXUfLJYgWUuLh1rJhisgDaitZTd
"""

!pip install streetlevel

import pandas as pd
# read ROI route points (locations to download street view images)

workingdirectory = '/content/'

LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv")
# LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv",converters={'panoid':str})
# RouteIDs = LumbertonRoutesPoints['RTE_NM'].unique() # unique route ID
LumbertonRoutesPoints = LumbertonRoutesPoints.drop_duplicates()
LumbertonRoutesPoints.info()

# prepare required functions
import math

def decode_polyline(polyline_str):
    '''Pass a Google Maps encoded polyline string; returns list of lat/lon pairs'''
    index, lat, lng = 0, 0, 0
    coordinates = []
    changes = {'latitude': 0, 'longitude': 0}

    # Coordinates have variable length when encoded, so just keep
    # track of whether we've hit the end of the string. In each
    # while loop iteration, a single coordinate is decoded.
    while index < len(polyline_str):
        # Gather lat/lon changes, store them in a dictionary to apply them later
        for unit in ['latitude', 'longitude']:
            shift, result = 0, 0
            while True:
                byte = ord(polyline_str[index]) - 63
                index += 1
                result |= (byte & 0x1f) << shift
                shift += 5
                if not byte >= 0x20:
                    break
            if (result & 1):
                changes[unit] = ~(result >> 1)
            else:
                changes[unit] = (result >> 1)
        lat += changes['latitude']
        lng += changes['longitude']
        coordinates.append((lat / 100000.0, lng / 100000.0))
    return coordinates

def getpathpoints(dirs,pts_distance=50):
  # polypath = dirs[0]['legs'][0]['steps'][0]['polyline']['points']
  polypath = dirs[0]['overview_polyline']['points']
  polypath_pts = decode_polyline(polypath)
  pts_coords = []
  for pt in range(1, len(polypath_pts)):
    lat1 = polypath_pts[pt-1][0]
    lng1 = polypath_pts[pt-1][1]
    lat2 = polypath_pts[pt][0]
    lng2 = polypath_pts[pt][1]
    azimuth = calculateBearing(lat1,lng1,lat2,lng2)
    coords = getInnerPoints(pts_distance,azimuth,lat1,lng1,lat2,lng2)
    if pt==1:
      pts_coords.append(coords)
    else:
      pts_coords.append(coords[1:])
  flatten_pts_coords = []
  for subl in pts_coords:
      for item in subl:
          flatten_pts_coords.append(item)
  return flatten_pts_coords

def getPathLength(lat1,lng1,lat2,lng2):
    '''calculates the distance between two lat, long coordinate pairs'''
    R = 6371000 # radius of earth in m
    lat1rads = math.radians(lat1)
    lat2rads = math.radians(lat2)
    deltaLat = math.radians((lat2-lat1))
    deltaLng = math.radians((lng2-lng1))
    a = math.sin(deltaLat/2) * math.sin(deltaLat/2) + math.cos(lat1rads) * math.cos(lat2rads) * math.sin(deltaLng/2) * math.sin(deltaLng/2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = R * c
    return d

def getDestinationLatLong(lat,lng,azimuth,distance):
    '''returns the lat an long of destination point
    given the start lat, long, aziuth, and distance'''
    R = 6378.1 #Radius of the Earth in km
    brng = math.radians(azimuth) #Bearing is degrees converted to radians.
    d = distance/1000 #Distance m converted to km
    lat1 = math.radians(lat) #Current dd lat point converted to radians
    lon1 = math.radians(lng) #Current dd long point converted to radians
    lat2 = math.asin(math.sin(lat1) * math.cos(d/R) + math.cos(lat1)* math.sin(d/R)* math.cos(brng))
    lon2 = lon1 + math.atan2(math.sin(brng) * math.sin(d/R)* math.cos(lat1), math.cos(d/R)- math.sin(lat1)* math.sin(lat2))
    #convert back to degrees
    lat2 = math.degrees(lat2)
    lon2 = math.degrees(lon2)
    return[lat2, lon2]

def calculateBearing(lat1,lng1,lat2,lng2):
    '''calculates the azimuth in degrees from start point to end point'''
    startLat = math.radians(lat1)
    startLong = math.radians(lng1)
    endLat = math.radians(lat2)
    endLong = math.radians(lng2)
    dLong = endLong - startLong
    dPhi = math.log(math.tan(endLat/2.0+math.pi/4.0)/math.tan(startLat/2.0+math.pi/4.0))
    if abs(dLong) > math.pi:
         if dLong > 0.0:
             dLong = -(2.0 * math.pi - dLong)
         else:
             dLong = (2.0 * math.pi + dLong)
    bearing = (math.degrees(math.atan2(dLong, dPhi)) + 360.0) % 360.0;
    return bearing

def getInnerPoints(interval,azimuth,lat1,lng1,lat2,lng2):
    '''returns every coordinate pair inbetween two coordinate
    pairs given the desired interval'''

    d = getPathLength(lat1,lng1,lat2,lng2)
    remainder, dist = math.modf((d / interval))
    counter = float(interval)
    coords = []
    coords.append([lat1,lng1])
    for distance in range(0,int(dist)):
        coord = getDestinationLatLong(lat1,lng1,azimuth,counter)
        counter = counter + float(interval)
        coords.append(coord)
    coords.append([lat2,lng2])
    return coords

def samepoint(line1, line2):
  result = False
  for x in line1:
    for y in line2:
      if x == y:
        result = True
        return x
        break
  return result

def find_intersection(p0, p1, p2, p3):
    # line1 = [p0.tolist(),p1.tolist()]
    # line2 = [p2.tolist(),p3.tolist()]
    line1 = [p0,p1]
    line2 = [p2,p3]
    samept = samepoint(line1,line2)
    if samept is not False:
      intersection_point = samept
    else:
      s10_x = p1[0] - p0[0]
      s10_y = p1[1] - p0[1]
      s32_x = p3[0] - p2[0]
      s32_y = p3[1] - p2[1]
      denom = s10_x * s32_y - s32_x * s10_y
      if denom == 0 : return math.nan # collinear
      denom_is_positive = denom > 0
      s02_x = p0[0] - p2[0]
      s02_y = p0[1] - p2[1]
      s_numer = s10_x * s02_y - s10_y * s02_x
      if (s_numer < 0) == denom_is_positive : return math.nan # no collision
      t_numer = s32_x * s02_y - s32_y * s02_x
      if (t_numer < 0) == denom_is_positive : return math.nan # no collision
      if (s_numer > denom) == denom_is_positive or (t_numer > denom) == denom_is_positive : return math.nan # no collision
      # collision detected
      t = t_numer / denom
      intersection_point = [ p0[0] + (t * s10_x), p0[1] + (t * s10_y) ]
    return intersection_point

import numpy as np
import math

def calculate_baseline_length(trajectory_points):
    """
    è®¡ç®—è½¨è¿¹åŸºçº¿é•¿åº¦

    Args:
        trajectory_points: è½¨è¿¹ç‚¹åˆ—è¡¨ [[lat, lon],...]

    Returns:
        baseline: åŸºçº¿é•¿åº¦(ç±³)
    """
    total_length = 0
    for i in range(len(trajectory_points)-1):
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[i+1]
        # ä½¿ç”¨å·²æœ‰çš„getPathLengthå‡½æ•°è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
        length = getPathLength(pt1[0], pt1[1], pt2[0], pt2[1])
        total_length += length

    # è¿”å›å¹³å‡æ®µé•¿ä½œä¸ºåŸºçº¿é•¿åº¦
    return total_length / (len(trajectory_points)-1)

from geopy.distance import geodesic

def calculate_mst_baseline(trajectory_points, MST):
    """
    è®¡ç®— MST çš„åŸºçº¿é•¿åº¦

    Args:
        trajectory_points: è½¨è¿¹ç‚¹åˆ—è¡¨ [[lat, lon],...]
        MST: NetworkX è®¡ç®—å‡ºçš„æœ€å°ç”Ÿæˆæ ‘ (Minimum Spanning Tree)

    Returns:
        baseline: åŸºçº¿é•¿åº¦(ç±³)
    """
    total_length = 0
    edge_count = 0

    for i, j in MST.edges():
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[j]
        length = geodesic(pt1, pt2).meters  # è¨ˆç®—åœ°ç†è·é›¢
        total_length += length
        edge_count += 1
        print(i,j, trajectory_points[i], trajectory_points[j])

    # è¿”å›å¹³å‡é‚Šé•·ä½œç‚ºåŸºç·š
    return total_length / edge_count if edge_count > 0 else 0


def create_grid_cells(trajectory_points, effective_distance):
    """
    åŸºäºè½¨è¿¹ç‚¹åˆ’åˆ†è‡ªé€‚åº”ç½‘æ ¼

    Args:
        trajectory_points: è½¨è¿¹ç‚¹åˆ—è¡¨ [[lat, lon], ...]
        effective_distance: å½±å“èŒƒå›´ï¼ˆç”¨äºè®¡ç®—ç½‘æ ¼å¤§å°ï¼‰

    Returns:
        grid_cells: è‡ªé€‚åº”ç½‘æ ¼åˆ’åˆ†çš„ç»“æœï¼Œæ¯ä¸ªå•å…ƒæ˜¯ [[lat1, lon1], [lat2, lon2], ...]
    """

    bl = calculate_baseline_length(trajectory_points)
    grid_cells = []
    # è®¡ç®—è½¨è¿¹çš„è¾¹ç•ŒèŒƒå›´
    min_lon = min(pt[1] for pt in trajectory_points)  # ç»åº¦
    max_lon = max(pt[1] for pt in trajectory_points)
    min_lat = min(pt[0] for pt in trajectory_points)  # çº¬åº¦
    max_lat = max(pt[0] for pt in trajectory_points)
    lat_start = min_lat
    lon_start = min_lon
    lat_end = max_lat
    lon_end = max_lon
    grid = [
        [lat_start, lon_start],
        [lat_end, lon_start],
        [lat_end, lon_end],
        [lat_start, lon_end]
        ]
    grid_cells.append(grid)
    print(grid_cells)
    return grid_cells

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory_and_grid(trajectory_points, grid_cells):
    """
    è¦–è¦ºåŒ–è¡Œé§›è»Œè·¡é»èˆ‡ä¸åŒé¡è‰²çš„è‡ªé©æ‡‰ç¶²æ ¼

    Args:
        trajectory_points: è¡Œé§›è»Œè·¡é» (list of [lat, lon])
        grid_cells:  è‡ªé€‚åº”ç½‘æ ¼åˆ’åˆ†çš„ç»“æœï¼Œæ¯ä¸ªå•å…ƒæ˜¯ [[lat1, lon1], [lat2, lon2], ...]
    """
    # å‰µå»ºåœ°åœ–
    fig = go.Figure()

    # 1ï¸âƒ£ æ·»åŠ è¡Œé§›è»Œè·¡é» (è—è‰²ç·šæ¢)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        # mode='lines+markers',
        name='Trajectory',
        # line=dict(width=2, color='blue'),
        marker=dict(size=5, color='blue')
    ))

    # 2ï¸âƒ£ ç”Ÿæˆä¸åŒé¡è‰²çš„ç¶²æ ¼
    colors = ['red', 'green', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'lime', 'teal', 'orange']

    for i, cell in enumerate(grid_cells):
        cell.append(cell[0])  # é—­åˆå¤šè¾¹å½¢
        grid_color = random.choice(colors)  # éš¨æ©Ÿé¸æ“‡é¡è‰²
        fig.add_trace(go.Scattermapbox(
            lat=[pt[0] for pt in cell],
            lon=[pt[1] for pt in cell],
            mode='lines',
            line=dict(width=2, color=grid_color),
            name=f'Grid {i+1}'
        ))

    # 3ï¸âƒ£ æ›´æ–°åœ°åœ–å¸ƒå±€
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory(trajectory_points):
    """
    è¦–è¦ºåŒ–è¡Œé§›è»Œè·¡é»èˆ‡ä¸åŒé¡è‰²çš„è‡ªé©æ‡‰ç¶²æ ¼

    Args:
        trajectory_points: è¡Œé§›è»Œè·¡é» (list of [lat, lon])
        grid_cells:  è‡ªé€‚åº”ç½‘æ ¼åˆ’åˆ†çš„ç»“æœï¼Œæ¯ä¸ªå•å…ƒæ˜¯ [[lat1, lon1], [lat2, lon2], ...]
    """
    # å‰µå»ºåœ°åœ–
    fig = go.Figure()

    # 1ï¸âƒ£ æ·»åŠ è¡Œé§›è»Œè·¡é» (è—è‰²ç·šæ¢)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        mode='markers',
        name='Trajectory',
        marker=dict(size=5, color='blue')
    ))


    # 3ï¸âƒ£ æ›´æ–°åœ°åœ–å¸ƒå±€
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

"""# **Create outer grid and do grid division(divide outer large grid into several small grid)**"""

import numpy as np
import pandas as pd
from streetlevel import streetview

# å‚æ•°è®¾ç½®
dist_para = [40*304.8, 1.5, 4.55, 10]
size = (640, 640)
EFFECTIVE_DISTANCE = 50  # æœ‰æ•ˆé‡‡é›†è·ç¦»(ç±³)

# æ–‡ä»¶è·¯å¾„
path1 = workingdirectory + 'StreetViewImages/'
path2 = workingdirectory + 'resized/'
savepreddir = workingdirectory + 'PolePredictionResults/'

totaldownload = 0
trajectory_points = LumbertonRoutesPoints[['Lat','Lon']].values.tolist()
print(len(trajectory_points))
grid_cells = create_grid_cells(trajectory_points,EFFECTIVE_DISTANCE)

fig = plot_trajectory_and_grid(trajectory_points, grid_cells)
fig.show()

"""***- use MST to link the trajectory point and stored them in edge_x and edge_y in increasing order of length(m).***"""

import numpy as np
import networkx as nx
from geopy.distance import geodesic
import plotly.graph_objects as go

print(len(trajectory_points))
# è¨ˆç®—åœ°ç†è·é›¢çš„è·é›¢çŸ©é™£
n = len(trajectory_points)
dist_matrix = np.zeros((n, n))
for i in range(n):
    for j in range(i + 1, n):
        dist = geodesic(trajectory_points[i], trajectory_points[j]).meters  # è¨ˆç®—å…©é»ä¹‹é–“çš„è·é›¢ï¼ˆä»¥ç±³ç‚ºå–®ä½ï¼‰
        dist_matrix[i, j] = dist_matrix[j, i] = dist

# å»ºç«‹åœ–ï¼ˆæ‰€æœ‰é»ç›¸é€£ï¼Œæ¬Šé‡ç‚ºåœ°ç†è·é›¢ï¼‰
G = nx.Graph()
for i in range(n):
    for j in range(i + 1, n):
        G.add_edge(i, j, weight=dist_matrix[i, j])

# è¨ˆç®— MSTï¼ˆæœ€å°ç”Ÿæˆæ¨¹ï¼‰
MST = nx.minimum_spanning_tree(G, algorithm='prim')

# å–å‡º MST é€£ç·šçš„é»
lats, lons = zip(*trajectory_points)  # æ‹†åˆ†ç·¯åº¦å’Œç¶“åº¦
edges_x = []
edges_y = []

# é€£ç·šçš„ x, y åº§æ¨™
for edge in MST.edges():
    i, j = edge
    edges_x.append([lons[i], lons[j]])
    edges_y.append([lats[i], lats[j]])

# ç•«åœ–
# fig = go.Figure()

# # ç•«å‡ºé›»ç·šæ†åº§æ¨™
# fig.add_trace(go.Scattermapbox(
#     lat=lats,
#     lon=lons,
#     mode='markers',
#     name='Electric Poles',
#     marker=dict(
#         size=7,
#         color='red',
#         opacity=0.8
#     )
# ))

# # ç•«å‡º MST é€£ç·š
# for x, y in zip(edges_x, edges_y):
#     fig.add_trace(go.Scattermapbox(
#         lat=y,
#         lon=x,
#         mode='lines',
#         line=dict(width=2, color='blue'),
#         name='MST Connections'
#     ))

# # æ›´æ–°å¸ƒå±€
# fig.update_layout(
#     mapbox=dict(
#         style='carto-positron',
#         zoom=15,
#         center=dict(
#             lat=np.mean(lats),
#             lon=np.mean(lons)
#         )
#     ),
#     height=800,
#     margin=dict(l=0, r=0, t=0, b=0),
#     showlegend=True,
#     legend=dict(
#         yanchor="top",
#         y=0.99,
#         xanchor="left",
#         x=0.01,
#         bgcolor='rgba(255,255,255,0.8)'
#     )
# )

# # é¡¯ç¤ºåœ–
# fig.show()

# è¨ˆç®—åŸºç·šé•·åº¦
baseline_length = calculate_mst_baseline(trajectory_points, MST)
print("MST Baseline Length:", baseline_length, "meters")

"""***- calculate k, dist_y, dist_x, nrow and ncol.***"""

grid_cells_flatten = grid_cells[0]
print(grid_cells_flatten)
#å·¦ä¸‹ï¼Œå·¦ä¸Šï¼Œå³ä¸Šï¼Œå³ä¸‹
k = (1+(50/(2*math.sqrt(2)*baseline_length)))/2
print(50/(2*math.sqrt(2)*baseline_length))
print(k)
dist_y = geodesic(grid_cells_flatten[1],grid_cells_flatten[0]).meters
dist_x = geodesic(grid_cells_flatten[2],grid_cells_flatten[1]).meters
print("å‚ç›´è·é›¢ï¼š",dist_y, "\næ°´å¹³è·é›¢ï¼š",dist_x)
nrow = math.ceil(dist_y/(k*baseline_length))
ncol = math.ceil(dist_x/(k*baseline_length))
print("nrow: ",nrow, "\nncol: ",ncol)

import numpy as np
from geopy.distance import geodesic

# è·å–å››ä¸ªè§’ç‚¹
p1, p2, p3, p4 = grid_cells_flatten[:4]

# è®¡ç®—æ­¥é•¿
step_y = dist_y / nrow
step_x = dist_x / ncol

# ç”Ÿæˆç½‘æ ¼ç‚¹
lat_values = np.linspace(p1[0], p2[0], nrow + 1)  # çºµå‘åˆ‡åˆ†ç‚¹
lon_values = np.linspace(p1[1], p3[1], ncol + 1)  # æ¨ªå‘åˆ‡åˆ†ç‚¹

# å­˜å‚¨æ‰€æœ‰ grid cells
each_grid_cells = []

# è¿­ä»£ç”Ÿæˆæ‰€æœ‰å°ç½‘æ ¼
for i in range(nrow):
    for j in range(ncol):
        lat1, lat2 = lat_values[i], lat_values[i + 1]
        lon1, lon2 = lon_values[j], lon_values[j + 1]

        # æ„é€ ä¸€ä¸ª grid cell
        grid_cell = [
            [lat1, lon1],  # å·¦ä¸‹è§’
            [lat2, lon1],  # å·¦ä¸Šè§’
            [lat2, lon2],  # å³ä¸Šè§’
            [lat1, lon2],  # å³ä¸‹è§’
            [lat1, lon1]
        ]

        each_grid_cells.append(grid_cell)

# è¾“å‡ºç¤ºä¾‹
print(f"æ€»ç½‘æ ¼æ•°: {len(each_grid_cells)}")
print("ç¤ºä¾‹ç½‘æ ¼:", each_grid_cells)

"""# **Visualise the grid cell**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()


for grid_cell in grid_cells:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Outer Grid Cell'
    ))

for grid_cell in each_grid_cells[15500:16000]:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='green'),
        name='Grid Cell'
    ))

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='carto-positron',
        zoom=15,
        center=dict(
            lat=np.mean([pt[0] for cell in each_grid_cells for pt in cell]),
            lon=np.mean([pt[1] for cell in each_grid_cells for pt in cell])
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# é¡¯ç¤ºåœ–
fig.show()

"""# **Create grid_info which contain the grid for record and also calculation.**"""

import numpy as np

# è¨ˆç®—æ¯å€‹ MST é»æ‰€å±¬çš„ grid(recorded)
min_lon = min(pt[1] for pt in trajectory_points)  # ç»åº¦
max_lon = max(pt[1] for pt in trajectory_points)
min_lat = min(pt[0] for pt in trajectory_points)  # çº¬åº¦
max_lat = max(pt[0] for pt in trajectory_points)
bl=baseline_length

# è¨˜éŒ„æ¯å€‹ MST é»å°æ‡‰çš„ grid(recorded) åŠå…¶å‘¨åœçš„ grid(calculation)
grid_info = []

# è½‰æ›æ¯”ä¾‹
def meters_to_lat(meters):
    return meters / 110540  # 1åº¦ç·¯åº¦ç´„110540ç±³

def meters_to_lon(meters, lat):
    return meters / (111320 * np.cos(np.radians(lat)))  # 1åº¦ç¶“åº¦ç´„111320ç±³ * cos(ç·¯åº¦)

for lat, lon in zip(lats, lons):
    delta_lat = meters_to_lat(k * bl)
    delta_lon = meters_to_lon(k * bl, lat)

    col = int((lon - min_lon) / delta_lon)
    row = int((lat - min_lat) / delta_lat)

    grid_recorded = {
        "row": row,
        "col": col,
        "grid": [
            [min_lon + col * delta_lon, min_lat + row * delta_lat],  # å·¦ä¸‹
            [min_lon + (col + 1) * delta_lon, min_lat + row * delta_lat],  # å³ä¸‹
            [min_lon + (col + 1) * delta_lon, min_lat + (row + 1) * delta_lat],  # å³ä¸Š
            [min_lon + col * delta_lon, min_lat + (row + 1) * delta_lat],  # å·¦ä¸Š
            [min_lon + col * delta_lon, min_lat + row * delta_lat]  # å›åˆ°å·¦ä¸‹
        ]
    }

    # è¨ˆç®— grid(calculation) ç¯„åœ (åŒ…å«å‘¨åœ8å€‹ grid)
    grid_calculation = [
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat],  # å·¦ä¸‹
        [min_lon + (col + 2) * delta_lon, min_lat + (row - 1) * delta_lat],  # å³ä¸‹
        [min_lon + (col + 2) * delta_lon, min_lat + (row + 2) * delta_lat],  # å³ä¸Š
        [min_lon + (col - 1) * delta_lon, min_lat + (row + 2) * delta_lat],  # å·¦ä¸Š
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat]  # å›åˆ°å·¦ä¸‹
    ]

    grid_info.append({
        "recorded": grid_recorded,
        "calculation": grid_calculation
    })


# é€™æ¨£æ¯å€‹ MST é»éƒ½æœƒå°æ‡‰ä¸€å€‹ grid(recorded) åŠå…¶å‘¨åœ 9 å€‹ grid(calculation)

"""# **Visualise grid for record and also calculation**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# å–å¾—ç¬¬ä¸€å€‹ grid_calculation å’Œ grid_recorded
first_grid_info = grid_info[1884]

# ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]  # ç·¯åº¦
lon_values = [pt[0] for pt in grid_calculation]  # ç¶“åº¦
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]  # ç·¯åº¦
lon_values = [pt[0] for pt in grid_recorded]  # ç¶“åº¦
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# è¨ˆç®—åœ°åœ–ä¸­å¿ƒé»
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # ä½¿ç”¨å…è²»åœ°åœ–
        zoom=12,  # æ¸›å°‘ zoom é¿å…å¤ªé è¿‘
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# é¡¯ç¤ºåœ–
print(first_grid_info)
fig.show()

print(grid_info[0]['calculation'])

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# è¨˜éŒ„æ‰€æœ‰é»çš„ç¶“ç·¯åº¦ï¼Œä»¥ä¾¿è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = []
all_lons = []

# éæ­· grid_info[50:100]
for grid_data in grid_info[1150:1175]:
    # ç¹ªè£½ grid_calculationï¼ˆè—è‰²ï¼‰
    grid_calculation = grid_data["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]  # ç·¯åº¦
    lon_values = [pt[0] for pt in grid_calculation]  # ç¶“åº¦
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation'
    ))

    # ç¹ªè£½ grid_recordedï¼ˆç´…è‰²ï¼‰
    grid_recorded = grid_data["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]  # ç·¯åº¦
    lon_values = [pt[0] for pt in grid_recorded]  # ç¶“åº¦
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded'
    ))

    # ç´¯ç©æ‰€æœ‰é»çš„ç¶“ç·¯åº¦
    all_lats.extend([pt[1] for pt in grid_calculation + grid_recorded])
    all_lons.extend([pt[0] for pt in grid_calculation + grid_recorded])

# è¨­å®šåœ°åœ–ä¸­å¿ƒ
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # ä½¿ç”¨å…è²»åœ°åœ–
        zoom=12,  # é©ç•¶ç¸®æ”¾
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# é¡¯ç¤ºåœ–è¡¨
fig.show()

from google.colab import drive
drive.mount("/content/drive")

LOBS = pd.read_csv("/content/poleLOB_original.csv")
print(len(LOBS))
LOBS = LOBS.drop_duplicates(subset=["start_lat", "start_lon", "end_lat", "end_lon"])
# LOBS.to_csv("/content/poleLOB_drop_duplicates.csv")
print(len(LOBS))

"""# **Remove duplicate of LOBS and also categorize them in proper grid respectively.**"""

from shapely.geometry import Point, Polygon

for grid in grid_info:
    grid_polygon_coords = grid['calculation']
    polygon = Polygon(grid_polygon_coords)
    lobs_in_polygon = set()  # ä½¿ç”¨ set è‡ªå‹•å»é™¤é‡è¤‡

    for _, row in LOBS.iterrows():
        start_point = Point(row["start_lon"], row["start_lat"])
        end_point = Point(row["end_lon"], row["end_lat"])

        if polygon.contains(start_point) or polygon.contains(end_point):
            lob = (
                row["start_lat"], row["start_lon"],
                row["end_lat"], row["end_lon"]
            )
            lobs_in_polygon.add(lob)  # åŠ å…¥ setï¼Œè‡ªå‹•å»é™¤é‡è¤‡

    # å°‡ set è½‰ç‚º list å­˜å…¥ grid ä¸­
    grid['lobs_in_polygon'] = list(lobs_in_polygon)

print(len(grid_info[1151]['lobs_in_polygon']))
print(grid_info[1151]['lobs_in_polygon'])

"""# **Visualise the grid for calculation and LOBs inside the grid**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# å–å¾—æŒ‡å®š grid_info
first_grid_info = grid_info[1155]

# ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]
lon_values = [pt[0] for pt in grid_calculation]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],  # é–‰åˆå¤šé‚Šå½¢
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]
lon_values = [pt[0] for pt in grid_recorded]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# ç•«å‡º intersecting LOBsï¼ˆç¶ è‰²ï¼‰
for lob in first_grid_info["lobs_in_polygon"]:
    start_lat, start_lon, end_lat, end_lon = lob
    fig.add_trace(go.Scattermapbox(
        lat=[start_lat, end_lat],
        lon=[start_lon, end_lon],
        mode='lines+markers',
        line=dict(width=2, color='green'),
        marker=dict(size=6, color='green'),
        name='LOB in Grid',
        showlegend=False  # é¿å…é‡è¤‡åœ–ä¾‹
    ))

# è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# é¡¯ç¤ºåœ–èˆ‡ç¢ºèªè³‡æ–™
print(first_grid_info)
fig.show()

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# è¨˜éŒ„æ‰€æœ‰ç¶“ç·¯åº¦ä»¥ä¾¿è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = []
all_lons = []

# å–å¾—å¤šå€‹ grid_info
for grid in grid_info[1150:1175]:
    # ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
    grid_calculation = grid["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]
    lon_values = [pt[0] for pt in grid_calculation]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation',
        showlegend=False
    ))

    # ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
    grid_recorded = grid["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]
    lon_values = [pt[0] for pt in grid_recorded]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded',
        showlegend=False
    ))

    # ç•«å‡º intersecting LOBsï¼ˆç¶ è‰²ï¼‰
    for lob in grid["lobs_in_polygon"]:
        start_lat, start_lon, end_lat, end_lon = lob
        fig.add_trace(go.Scattermapbox(
            lat=[start_lat, end_lat],
            lon=[start_lon, end_lon],
            mode='lines+markers',
            line=dict(width=2, color='green'),
            marker=dict(size=6, color='green'),
            name='LOB in Grid',
            showlegend=False
        ))

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

"""# **Append 2 tupple in grid_info(intersections and lobs_intersection)**
***- to find the intersection of LOBs in grid***
"""

from shapely.geometry import LineString

for grid in grid_info:
    grid_polygon_coords = grid['calculation']
    polygon = Polygon(grid_polygon_coords)

    lobs = grid.get('lobs_in_polygon', [])
    intersections = set()
    intersection_lobs = set()

    # å…©å…©é…å°æ‰¾äº¤é»
    for i in range(len(lobs)):
        for j in range(i + 1, len(lobs)):
            lob1 = lobs[i]
            lob2 = lobs[j]

            line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])  # (lon, lat)
            line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

            if line1.intersects(line2):
                intersection = line1.intersection(line2)

                # æª¢æŸ¥æ˜¯å¦ç‚ºé»ï¼Œä¸¦ä¸”è©²é»åœ¨ grid polygon è£¡
                if intersection.geom_type == 'Point' and polygon.contains(intersection):
                    intersections.add((intersection.y, intersection.x))  # å­˜ç‚º (lat, lon)
                    intersection_lobs.add(tuple(lob1))
                    intersection_lobs.add(tuple(lob2))

    # å­˜å› grid
    grid['intersections'] = [list(pt) for pt in intersections]
    grid['intersection_lobs'] = [list(lob) for lob in intersection_lobs]

print((grid_info[1155]['intersections']))
print((grid_info[1155]['intersection_lobs']))

"""# **Visualise the grid for calculation and intersectinon_LOBs inside the grid**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# è¨˜éŒ„æ‰€æœ‰ç¶“ç·¯åº¦ä»¥ä¾¿è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = []
all_lons = []

# å–å¾—å¤šå€‹ grid_info
for grid in grid_info[1151:1152]:
    # ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
    grid_calculation = grid["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]
    lon_values = [pt[0] for pt in grid_calculation]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation',
        showlegend=False
    ))

    # ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
    grid_recorded = grid["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]
    lon_values = [pt[0] for pt in grid_recorded]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded',
        showlegend=False
    ))

    # ç•«å‡º intersecting LOBsï¼ˆç¶ è‰²ï¼‰
    for lob in grid["intersection_lobs"]:
        start_lat, start_lon, end_lat, end_lon = lob
        fig.add_trace(go.Scattermapbox(
            lat=[start_lat, end_lat],
            lon=[start_lon, end_lon],
            mode='lines+markers',
            line=dict(width=2, color='green'),
            marker=dict(size=6, color='green'),
            name='LOB in Grid',
            showlegend=False
        ))

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

print(grid_info[1151]['intersection_lobs'])

"""# **Create Intersection Matrix**

Save the intersection between each set of LOBS in a dictionaries
"""

import pandas as pd
import numpy as np
from shapely.geometry import LineString, Point
from collections import defaultdict

# è™•ç† intersection_lobs
intersection_lobs = [
    [float(a), float(b), float(c), float(d)]
    for a, b, c, d in grid_info[1151]['intersection_lobs']
]

# åˆ†ç¾¤æ ¹æ“šèµ·é»
start_point_groups = defaultdict(list)
for lob in intersection_lobs:
    start = (lob[0], lob[1])  # (lat, lon)
    start_point_groups[start].append(lob)

# æ¨™è¨˜ A1, A2, ..., B1, ...
labels = {}
label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
lob_list = []
label_index = 0
for group_start, lobs in sorted(start_point_groups.items()):
    for i, lob in enumerate(lobs):
        label = f"{label_prefix[label_index]}{i+1}"
        labels[tuple(lob)] = label
        lob_list.append((lob, label))
    label_index += 1

# åˆå§‹åŒ– matrix å’Œäº¤é»è¨˜éŒ„ dict
n = len(lob_list)
matrix = [['-' for _ in range(n)] for _ in range(n)]
label_list = [label for _, label in lob_list]
intersection_points_dict = {}

# æ¯”å°äº¤é»
for i in range(n):
    for j in range(n):
        if i == j:
            matrix[i][j] = 'â€”'
            continue

        lob1, label1 = lob_list[i]
        lob2, label2 = lob_list[j]
        line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])  # (lon, lat)
        line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

        if line1.intersects(line2):
            intersection = line1.intersection(line2)
            if intersection.geom_type == 'Point':
                matrix[i][j] = f"P({label1}x{label2})"
                intersection_points_dict[(label1, label2)] = (intersection.y, intersection.x)  # lat, lon
                intersection_points_dict[(label2, label1)] = (intersection.y, intersection.x)

# é¡¯ç¤ºçŸ©é™£
df_matrix = pd.DataFrame(matrix, columns=label_list, index=label_list)
display(df_matrix)

# å°å‡ºæ‰€æœ‰äº¤é»
print("æ‰€æœ‰äº¤é»ï¼ˆlabel å°æ‡‰çš„äº¤é»åº§æ¨™ï¼‰:")
for (label_a, label_b), point in intersection_points_dict.items():
    print(f"{label_a} x {label_b} -> äº¤é»åº§æ¨™: (lat={point[0]:.6f}, lon={point[1]:.6f})")

from sklearn.cluster import DBSCAN
import numpy as np
from math import radians, cos, sin, asin, sqrt
from collections import defaultdict

# å°‡æ‰€æœ‰äº¤é»åº§æ¨™è½‰ç‚º numpy array
coords = np.array(list(intersection_points_dict.values()))  # [[lat, lon], ...]

# è¨ˆç®— haversine è·é›¢
def haversine(lat1, lon1, lat2, lon2):
    R = 6371000  # åœ°çƒåŠå¾‘ (å…¬å°º)
    dlat = radians(lat2 - lat1)
    dlon = radians(lon2 - lon1)
    a = sin(dlat / 2)**2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2)**2
    return 2 * R * asin(sqrt(a))

# è‡ªè¨‚ haversine è·é›¢çŸ©é™£
def haversine_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                dist_matrix[i][j] = haversine(coords[i][0], coords[i][1], coords[j][0], coords[j][1])
    return dist_matrix

# DBSCAN èšé¡ï¼ˆeps = 2.5 å…¬å°ºï¼Œmin_samples=1 è¡¨ç¤ºè‡ªå·±ä¹Ÿèƒ½æˆä¸€ç¾¤ï¼‰
distance_matrix = haversine_distance_matrix(coords)
db = DBSCAN(eps=2.5, min_samples=1, metric='precomputed')
labels = db.fit_predict(distance_matrix)

# ç‚ºæ¯å€‹ cluster è¨ˆç®— centroid
cluster_points = defaultdict(list)
for i, label in enumerate(labels):
    cluster_points[label].append(coords[i])

cluster_centroids = {
    label: np.mean(np.array(pts), axis=0)  # å¹³å‡ lat/lon
    for label, pts in cluster_points.items()
}

# å°‡æ‰€æœ‰äº¤é»æ›´æ–°ç‚º centroid
label_keys = list(intersection_points_dict.keys())
for i, key in enumerate(label_keys):
    cluster_id = labels[i]
    centroid = cluster_centroids[cluster_id]
    intersection_points_dict[key] = tuple(centroid)

# å°å‡ºçµæœ
print("èšé¡å¾Œäº¤é»ï¼ˆä½¿ç”¨ centroid æ›´æ–°ï¼‰:")
for (label_a, label_b), point in intersection_points_dict.items():
    print(f"{label_a} x {label_b} -> ç¾¤ä¸­å¿ƒ: (lat={point[0]:.6f}, lon={point[1]:.6f})")

import plotly.graph_objects as go
import numpy as np
import plotly.express as px

fig = go.Figure()

# å–å¾—æŒ‡å®š grid_info
first_grid_info = grid_info[1151]

# ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]
lon_values = [pt[0] for pt in grid_calculation]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]
lon_values = [pt[0] for pt in grid_recorded]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# ğŸ“Œ é¡¯ç¤º intersection pointsï¼Œæ ¹æ“š cluster ä¸Šè‰²
unique_cluster_ids = set(labels)
color_scale = px.colors.qualitative.Alphabet  # æˆ– Set3ã€Plotly ç­‰é…è‰²æ–¹æ¡ˆ

for cluster_id in unique_cluster_ids:
    # æ‰€æœ‰å±¬æ–¼é€™å€‹ cluster çš„äº¤é»ç´¢å¼•
    indices = np.where(labels == cluster_id)[0]
    cluster_color = color_scale[cluster_id % len(color_scale)]

    # æå–äº¤é»ä¸¦åŠ åˆ°åœ–ä¸Š
    for idx in indices:
        label_pair = list(intersection_points_dict.keys())[idx]
        point = intersection_points_dict[label_pair]
        fig.add_trace(go.Scattermapbox(
            lat=[point[0]],
            lon=[point[1]],
            mode='markers+text',
            marker=dict(size=10, color=cluster_color),
            text=[f"Cluster {cluster_id}"],
            textposition="top right",
            name=f"Intersection Cluster {cluster_id}",
            showlegend=False
        ))

# è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

import pandas as pd
import numpy as np
import plotly.express as px

# å»ºç«‹é¡è‰²è¡¨ï¼Œæ¯å€‹ cluster å°æ‡‰ä¸€å€‹é¡è‰²
unique_cluster_ids = sorted(set(labels))
color_palette = px.colors.qualitative.Alphabet
cluster_colors = {
    cid: color_palette[cid % len(color_palette)]
    for cid in unique_cluster_ids
}

# å»ºç«‹ intersection å°æ‡‰çš„ cluster å­—å…¸ï¼Œè®“æˆ‘å€‘çŸ¥é“å“ªå€‹äº¤é»å±¬æ–¼å“ªå€‹ cluster
intersection_to_cluster = {
    key: cluster_id
    for key, cluster_id in zip(intersection_points_dict.keys(), labels)
}

# æ¨£å¼å‡½æ•¸ï¼Œæ ¹æ“šä½ç½® i, j æ±ºå®šæ˜¯å¦è¦ä¸Šè‰²
def highlight_intersections(val, row_idx, col_idx):
    label1 = df_matrix.index[row_idx]
    label2 = df_matrix.columns[col_idx]

    # äº¤é»å­—å…¸çš„ key æœ‰å…©ç¨®æ’åˆ—é †åº
    key1 = (label1, label2)
    key2 = (label2, label1)

    if key1 in intersection_to_cluster:
        cluster_id = intersection_to_cluster[key1]
    elif key2 in intersection_to_cluster:
        cluster_id = intersection_to_cluster[key2]
    else:
        return ''  # ç„¡äº¤é»ï¼Œä¸ä¸Šè‰²

    color = cluster_colors[cluster_id]
    return f'background-color: {color}; color: black;'

# å»ºç«‹æ¨£å¼ DataFrame
def style_df(df):
    styled = df.style

    for i in range(df.shape[0]):
        for j in range(df.shape[1]):
            styled = styled.set_properties(
                subset=pd.IndexSlice[df.index[i], df.columns[j]],
                **{
                    'background-color': highlight_intersections(df.iat[i, j], i, j).replace('background-color:', '').split(';')[0],
                    'color': 'black'
                }
            )
    return styled

# é¡¯ç¤ºåŠ è‰²å¾Œçš„çŸ©é™£
styled_df = style_df(df_matrix)
styled_df

def simplify_matrix(matrix_df, intersection_to_cluster, cluster_colors):
    n = matrix_df.shape[0]
    simplified = matrix_df.copy()

    for i in range(n):
        for j in range(n):
            if i >= j:
                simplified.iat[i, j] = ''  # æ¸…é™¤å°è§’ç·šèˆ‡ä¸‹ä¸‰è§’
    return simplified

def style_simplified_df(df, intersection_to_cluster, cluster_colors):
    def highlight(val, row_idx, col_idx):
        label1 = df.index[row_idx]
        label2 = df.columns[col_idx]
        key1 = (label1, label2)
        key2 = (label2, label1)

        if key1 in intersection_to_cluster:
            cid = intersection_to_cluster[key1]
        elif key2 in intersection_to_cluster:
            cid = intersection_to_cluster[key2]
        else:
            return ''
        return f'background-color: {cluster_colors[cid]}; color: black'

    styled = df.style
    for i in range(df.shape[0]):
        for j in range(df.shape[1]):
            if i < j:
                color_style = highlight(df.iat[i, j], i, j)
                styled = styled.set_properties(
                    subset=pd.IndexSlice[df.index[i], df.columns[j]],
                    **{
                        'background-color': color_style.replace('background-color:', '').split(';')[0],
                        'color': 'black'
                    }
                )
    return styled

# ç°¡åŒ–çŸ©é™£ï¼ˆä¸Šä¸‰è§’ + ç„¡å°è§’ç·šï¼‰
df_simplified = simplify_matrix(df_matrix, intersection_to_cluster, cluster_colors)
styled_df_simplified = style_simplified_df(df_simplified, intersection_to_cluster, cluster_colors)
styled_df_simplified

def filter_row_lonely_intersections(df_simplified, intersection_to_cluster):
    df_filtered = df_simplified.copy()

    for i in range(df_filtered.shape[0]):
        row_label = df_filtered.index[i]
        # è¨˜éŒ„æ¯å€‹ cluster åœ¨é€™ä¸€ row å‡ºç¾å¹¾æ¬¡
        cluster_count = {}

        for j in range(df_filtered.shape[1]):
            if i >= j:
                continue  # åªè™•ç†ä¸Šä¸‰è§’

            col_label = df_filtered.columns[j]
            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            cluster_count[cluster_id] = cluster_count.get(cluster_id, 0) + 1

        # å†æ¬¡èµ°éé€™ä¸€ rowï¼ŒæŠŠå­¤ç«‹çš„ intersection æ¸…é™¤
        for j in range(df_filtered.shape[1]):
            if i >= j:
                continue

            col_label = df_filtered.columns[j]
            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            if cluster_count[cluster_id] <= 1:
                # å¦‚æœé€™å€‹ cluster åªå‡ºç¾ 1 æ¬¡ï¼Œå°±æ¸…é™¤å®ƒ
                df_filtered.iat[i, j] = 'â€”'

    return df_filtered

df_filtered = filter_row_lonely_intersections(df_simplified, intersection_to_cluster)

# å†ä¸Šè‰²
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
styled_filtered

def filter_lonely_column_intersections(df_simplified, intersection_to_cluster):
    df_filtered = df_simplified.copy()

    for j in range(df_filtered.shape[1]):
        col_label = df_filtered.columns[j]
        # è¨˜éŒ„æ¯å€‹ cluster åœ¨é€™ä¸€ col å‡ºç¾å¹¾æ¬¡
        cluster_count = {}

        for i in range(df_filtered.shape[0]):
            if i >= j:
                continue  # åªè™•ç†ä¸Šä¸‰è§’

            row_label = df_filtered.index[i]
            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            cluster_count[cluster_id] = cluster_count.get(cluster_id, 0) + 1

        # å†æ¬¡èµ°éé€™ä¸€ columnï¼ŒæŠŠå­¤ç«‹çš„ intersection æ¸…é™¤
        for i in range(df_filtered.shape[0]):
            if i >= j:
                continue

            row_label = df_filtered.index[i]
            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            if cluster_count[cluster_id] <= 1:
                df_filtered.iat[i, j] = 'â€”'

    return df_filtered

df_filtered_column = filter_lonely_column_intersections(df_simplified, intersection_to_cluster)

# ä¸Šè‰²é¡¯ç¤º
styled_filtered_column = style_simplified_df(df_filtered_column, intersection_to_cluster, cluster_colors)
styled_filtered_column

def filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster):
    df_filtered = df_simplified.copy()

    # è¨˜éŒ„æ¯å€‹ row å’Œ column ä¸­ï¼Œæ¯å€‹ cluster å‡ºç¾æ¬¡æ•¸
    row_cluster_count = {}
    col_cluster_count = {}

    # å…ˆèµ°éä¸€æ¬¡ï¼Œçµ±è¨ˆ row å’Œ column çš„ cluster æ•¸é‡
    for i in range(df_filtered.shape[0]):
        row_label = df_filtered.index[i]
        for j in range(df_filtered.shape[1]):
            col_label = df_filtered.columns[j]
            if i >= j:
                continue  # åªçœ‹ä¸Šä¸‰è§’

            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]

            row_cluster_count.setdefault(row_label, {}).setdefault(cluster_id, 0)
            row_cluster_count[row_label][cluster_id] += 1

            col_cluster_count.setdefault(col_label, {}).setdefault(cluster_id, 0)
            col_cluster_count[col_label][cluster_id] += 1

    # å†èµ°ä¸€æ¬¡ï¼Œæ¸…æ‰ row å’Œ column éƒ½åªæœ‰1å€‹çš„äº¤é»
    for i in range(df_filtered.shape[0]):
        row_label = df_filtered.index[i]
        for j in range(df_filtered.shape[1]):
            col_label = df_filtered.columns[j]
            if i >= j:
                continue  # åªçœ‹ä¸Šä¸‰è§’

            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]

            # å¦‚æœåœ¨ row å’Œ column ä¸Šï¼Œé€™å€‹ cluster éƒ½åªæœ‰å‡ºç¾ 1 æ¬¡
            if row_cluster_count[row_label][cluster_id] <= 1 and col_cluster_count[col_label][cluster_id] <= 1:
                df_filtered.iat[i, j] = 'â€”'

    return df_filtered

df_filtered = filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster)

# ä¸Šè‰²
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
styled_filtered

def filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0):
    df_result = df_filtered.copy()

    for j in range(start_col_idx, df_result.shape[1]):
        col_label = df_result.columns[j]
        clusters_in_column = set()

        for i in range(df_result.shape[0]):
            row_label = df_result.index[i]
            if i >= j:
                continue

            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            clusters_in_column.add(cluster_id)

        if len(clusters_in_column) > 1:
            print(f"Column '{col_label}' (index {j}) has multiple clusters: {clusters_in_column}. Marking and stopping.")
            for i in range(df_result.shape[0]):
                if i >= j:
                    continue
                df_result.iat[i, j] = 'â€”'
            return df_result, j + 1  # å›å‚³ä¸‹ä¸€æ¬¡è¦å¾å“ªå€‹ column é–‹å§‹

    print("No more columns with multiple clusters.")
    return df_result, df_result.shape[1]


# ç¬¬ä¸€æ¬¡è™•ç†
df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0)

# ä¸Šè‰²
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
styled_filtered

df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=next_col_idx)
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
styled_filtered

# from collections import Counter

# def filter_columns_with_dominant_cluster(df_filtered, intersection_to_cluster, start_col_idx=0):
#     df_result = df_filtered.copy()

#     for j in range(start_col_idx, df_result.shape[1]):
#         col_label = df_result.columns[j]
#         cluster_counter = Counter()

#         # çµ±è¨ˆè©² column ä¸­æ‰€æœ‰ cluster çš„å‡ºç¾æ¬¡æ•¸
#         for i in range(df_result.shape[0]):
#             row_label = df_result.index[i]
#             if i >= j:
#                 continue

#             key = (row_label, col_label)
#             if key in intersection_to_cluster:
#                 cluster_id = intersection_to_cluster[key]
#                 cluster_counter[cluster_id] += 1

#         if len(cluster_counter) > 1:
#             # æ‰¾å‡ºæœ€å¤šæ¬¡çš„ cluster
#             most_common = cluster_counter.most_common()
#             top_count = most_common[0][1]
#             top_clusters = [cid for cid, count in most_common if count == top_count]

#             if len(top_clusters) == 1:
#                 dominant_cluster = top_clusters[0]
#                 print(f"Column '{col_label}' (index {j}) has dominant cluster: {dominant_cluster}. Keeping only that cluster.")
#                 for i in range(df_result.shape[0]):
#                     if i >= j:
#                         continue
#                     key = (df_result.index[i], col_label)
#                     if intersection_to_cluster.get(key) != dominant_cluster:
#                         df_result.iat[i, j] = 'â€”'
#             else:
#                 print(f"Column '{col_label}' (index {j}) has no unique dominant cluster: {top_clusters}. Removing entire column.")
#                 for i in range(df_result.shape[0]):
#                     if i >= j:
#                         continue
#                     df_result.iat[i, j] = 'â€”'

#             return df_result, j + 1  # å›å‚³ä¸‹ä¸€æ¬¡è¦å¾å“ªå€‹ column é–‹å§‹

#     print("No more columns with multiple clusters.")
#     return df_result, df_result.shape[1]


# # ç¬¬ä¸€æ¬¡è™•ç†
# df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0)

# # ä¸Šè‰²
# styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
# styled_filtered

# df_filtered, next_col_idx = filter_columns_with_dominant_cluster(df_filtered, intersection_to_cluster, start_col_idx=next_col_idx)
# styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
# styled_filtered

start_col = 0
df_simplified = simplify_matrix(df_matrix, intersection_to_cluster, cluster_colors)
styled_df_simplified = style_simplified_df(df_simplified, intersection_to_cluster, cluster_colors)
# styled_df_simplified

df_filtered = filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster)
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
# styled_filtered


df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0)
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
# styled_filtered

while(next_col_idx!=df_filtered.shape[1]):
    print(next_col_idx)
    df_filtered = filter_lonely_row_column_intersections(df_filtered, intersection_to_cluster)
    styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)

    df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=next_col_idx)
    styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)

styled_filtered

# import pandas as pd

# def save_remaining_coordinates(df_filtered, intersection_points_dict, output_filename="remaining_coordinates.xlsx"):
#     remaining_coords = []

#     for i in range(df_filtered.shape[0]):
#         for j in range(df_filtered.shape[1]):
#             if i >= j:
#                 continue  # åªçœ‹ä¸Šä¸‰è§’

#             row_label = df_filtered.index[i]
#             col_label = df_filtered.columns[j]

#             if df_filtered.iat[i, j] != 'â€”':
#                 key = (row_label, col_label)
#                 if key in intersection_points_dict:
#                     lat, lon = intersection_points_dict[key]
#                     remaining_coords.append({
#                         "row": row_label,
#                         "col": col_label,
#                         "Latitude": round(lat, 7),   # å¯é¸ï¼šå¢åŠ ç²¾åº¦æ§åˆ¶é¿å…æµ®é»å¾®å°å·®ç•°å½±éŸ¿
#                         "Longitude": round(lon, 7)
#                     })

#     if remaining_coords:
#         df_coords = pd.DataFrame(remaining_coords)

#         # æ ¹æ“š Latitude å’Œ Longitude ç§»é™¤é‡è¤‡é»
#         df_coords_unique = df_coords.drop_duplicates(subset=["Latitude", "Longitude"])

#         df_coords_unique.to_excel(output_filename, index=False)
#         print(f"âœ… å·²ç§»é™¤é‡è¤‡ç¶“ç·¯åº¦ä¸¦å„²å­˜è‡³ {output_filename}ï¼Œå…± {len(df_coords_unique)} ç­†")
#     else:
#         print("âš ï¸ æ²’æœ‰å¯å„²å­˜çš„äº¤é»åº§æ¨™ï¼ˆæ‰€æœ‰éƒ½è¢«åˆªé™¤ï¼‰")

# # ä½¿ç”¨ç¯„ä¾‹
# save_remaining_coordinates(df_filtered, intersection_points_dict)

import os
import pandas as pd
from openpyxl import load_workbook

def save_remaining_coordinates(df_filtered, intersection_points_dict, output_filename="remaining_coordinates.xlsx"):
    remaining_coords = []

    for i in range(df_filtered.shape[0]):
        for j in range(df_filtered.shape[1]):
            if i >= j:
                continue  # åªçœ‹ä¸Šä¸‰è§’

            row_label = df_filtered.index[i]
            col_label = df_filtered.columns[j]

            if df_filtered.iat[i, j] != 'â€”':
                key = (row_label, col_label)
                if key in intersection_points_dict:
                    lat, lon = intersection_points_dict[key]
                    remaining_coords.append({
                        "Lat": round(lat, 8),
                        "Lon": round(lon, 8)
                    })

    if not remaining_coords:
        print("âš ï¸ æ²’æœ‰å¯å„²å­˜çš„äº¤é»åº§æ¨™ï¼ˆæ‰€æœ‰éƒ½è¢«åˆªé™¤ï¼‰")
        return

    df_coords = pd.DataFrame(remaining_coords)
    df_coords_unique = df_coords.drop_duplicates(subset=["Lat", "Lon"])

    if os.path.exists(output_filename):
        # è‹¥æª”æ¡ˆå­˜åœ¨ï¼Œé™„åŠ è³‡æ–™
        with pd.ExcelWriter(output_filename, mode='a', engine='openpyxl', if_sheet_exists='overlay') as writer:
            # è®€å–ç¾æœ‰è³‡æ–™
            existing_df = pd.read_excel(output_filename)
            # åˆä½µä¸¦å»é‡
            combined_df = pd.concat([existing_df, df_coords_unique], ignore_index=True)
            combined_df = combined_df.drop_duplicates(subset=["Lat", "Lon"])
            combined_df.to_excel(writer, index=False)
        print(f"âœ… å·²ç§»é™¤é‡è¤‡ç¶“ç·¯åº¦ä¸¦å„²å­˜è‡³ {output_filename}ï¼Œå…± {len(df_coords_unique)} ç­†")
        print(f"ğŸ“Œ å·²é™„åŠ ä¸¦å„²å­˜è‡³ {output_filename}ï¼Œç›®å‰å…± {len(combined_df)} ç­†")
    else:
        # æª”æ¡ˆä¸å­˜åœ¨ï¼Œå»ºç«‹æ–°æª”
        df_coords_unique.to_excel(output_filename, index=False)
        print(f"âœ… å»ºç«‹æ–°æª”ä¸¦å„²å­˜è‡³ {output_filename}ï¼Œå…± {len(df_coords_unique)} ç­†")

# import pandas as pd
# import numpy as np
# from shapely.geometry import LineString, Point
# from collections import defaultdict
# import matplotlib.pyplot as plt
# import plotly.graph_objects as go
# import numpy as np
# import plotly.express as px

# for grid_id in grid_info:
#   intersection_lobs = [
#       [float(a), float(b), float(c), float(d)]
#       for a, b, c, d in grid_id['intersection_lobs']
#   ]

#   # åˆ†ç¾¤æ ¹æ“šèµ·é»
#   start_point_groups = defaultdict(list)
#   for lob in intersection_lobs:
#       start = (lob[0], lob[1])  # (lat, lon)
#       start_point_groups[start].append(lob)

#   # æ¨™è¨˜ A1, A2, ..., B1, ...
#   labels = {}
#   label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
#   lob_list = []
#   label_index = 0
#   for group_start, lobs in sorted(start_point_groups.items()):
#       for i, lob in enumerate(lobs):
#           label = f"{label_prefix[label_index]}{i+1}"
#           labels[tuple(lob)] = label
#           lob_list.append((lob, label))
#       label_index += 1

#   # åˆå§‹åŒ– matrix å’Œäº¤é»è¨˜éŒ„ dict
#   n = len(lob_list)
#   matrix = [['-' for _ in range(n)] for _ in range(n)]
#   label_list = [label for _, label in lob_list]
#   intersection_points_dict = {}

#   # æ¯”å°äº¤é»
#   for i in range(n):
#       for j in range(n):
#           if i == j:
#               matrix[i][j] = 'â€”'
#               continue

#           lob1, label1 = lob_list[i]
#           lob2, label2 = lob_list[j]
#           line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])  # (lon, lat)
#           line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

#           if line1.intersects(line2):
#               intersection = line1.intersection(line2)
#               if intersection.geom_type == 'Point':
#                   matrix[i][j] = f"P({label1}x{label2})"
#                   intersection_points_dict[(label1, label2)] = (intersection.y, intersection.x)  # lat, lon
#                   intersection_points_dict[(label2, label1)] = (intersection.y, intersection.x)

#   # é¡¯ç¤ºçŸ©é™£
#   df_matrix = pd.DataFrame(matrix, columns=label_list, index=label_list)
#   display(df_matrix)

#   # # DBSCAN èšé¡ï¼ˆeps = 2.5 å…¬å°ºï¼Œmin_samples=1 è¡¨ç¤ºè‡ªå·±ä¹Ÿèƒ½æˆä¸€ç¾¤ï¼‰
#   # distance_matrix = haversine_distance_matrix(coords)
#   # db = DBSCAN(eps=2.5, min_samples=1, metric='precomputed')
#   # labels = db.fit_predict(distance_matrix)

#   # # ç‚ºæ¯å€‹ cluster è¨ˆç®— centroid
#   # cluster_points = defaultdict(list)
#   # for i, label in enumerate(labels):
#   #     cluster_points[label].append(coords[i])

#   # cluster_centroids = {
#   #     label: np.mean(np.array(pts), axis=0)  # å¹³å‡ lat/lon
#   #     for label, pts in cluster_points.items()
#   # }

#   # # å°‡æ‰€æœ‰äº¤é»æ›´æ–°ç‚º centroid
#   # label_keys = list(intersection_points_dict.keys())
#   # for i, key in enumerate(label_keys):
#   #     cluster_id = labels[i]
#   #     centroid = cluster_centroids[cluster_id]
#   #     intersection_points_dict[key] = tuple(centroid)

#   # fig = go.Figure()

#   coords = []
#   label_pair_list = []

#   for key, point in intersection_points_dict.items():
#       coords.append(point)
#       label_pair_list.append(key)

#   distance_matrix = haversine_distance_matrix(coords)
#   db = DBSCAN(eps=2.5, min_samples=1, metric='precomputed')
#   labels = db.fit_predict(distance_matrix)

#   # å»ºç«‹ label_pair å°æ‡‰ cluster_id çš„ dict
#   intersection_to_cluster = {
#       label_pair_list[i]: labels[i]
#       for i in range(len(labels))
#   }

#   cluster_points = defaultdict(list)
#   for i, label in enumerate(labels):
#       cluster_points[label].append(coords[i])

#   cluster_centroids = {
#       label: np.mean(np.array(pts), axis=0)  # (lat, lon)
#       for label, pts in cluster_points.items()
#   }

#   for key in intersection_points_dict.keys():
#       cluster_id = intersection_to_cluster[key]
#       centroid = cluster_centroids[cluster_id]
#       intersection_points_dict[key] = tuple(centroid)

#   # å–å¾—æŒ‡å®š grid_info
#   first_grid_info = grid_id

#   # ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
#   grid_calculation = first_grid_info["calculation"]
#   lat_values = [pt[1] for pt in grid_calculation]
#   lon_values = [pt[0] for pt in grid_calculation]
#   fig.add_trace(go.Scattermapbox(
#       lat=lat_values + [lat_values[0]],
#       lon=lon_values + [lon_values[0]],
#       mode='lines',
#       line=dict(width=2, color='blue'),
#       name='Grid Calculation'
#   ))

#   # ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
#   grid_recorded = first_grid_info["recorded"]["grid"]
#   lat_values = [pt[1] for pt in grid_recorded]
#   lon_values = [pt[0] for pt in grid_recorded]
#   fig.add_trace(go.Scattermapbox(
#       lat=lat_values + [lat_values[0]],
#       lon=lon_values + [lon_values[0]],
#       mode='lines',
#       line=dict(width=2, color='red'),
#       name='Grid Recorded'
#   ))

#   # ğŸ“Œ é¡¯ç¤º intersection pointsï¼Œæ ¹æ“š cluster ä¸Šè‰²
#   unique_cluster_ids = set(labels)
#   color_scale = px.colors.qualitative.Alphabet  # æˆ– Set3ã€Plotly ç­‰é…è‰²æ–¹æ¡ˆ

#   for cluster_id in unique_cluster_ids:
#       # æ‰€æœ‰å±¬æ–¼é€™å€‹ cluster çš„äº¤é»ç´¢å¼•
#       indices = np.where(labels == cluster_id)[0]
#       cluster_color = color_scale[cluster_id % len(color_scale)]

#       # æå–äº¤é»ä¸¦åŠ åˆ°åœ–ä¸Š
#       for idx in indices:
#           label_pair = list(intersection_points_dict.keys())[idx]
#           point = intersection_points_dict[label_pair]
#           fig.add_trace(go.Scattermapbox(
#               lat=[point[0]],
#               lon=[point[1]],
#               mode='markers+text',
#               marker=dict(size=10, color=cluster_color),
#               text=[f"Cluster {cluster_id}"],
#               textposition="top right",
#               name=f"Intersection Cluster {cluster_id}",
#               showlegend=False
#           ))

#   # è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
#   all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
#   all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

#   fig.update_layout(
#       mapbox=dict(
#           style='open-street-map',
#           zoom=15,
#           center=dict(
#               lat=np.mean(all_lats),
#               lon=np.mean(all_lons)
#           )
#       ),
#       height=800,
#       margin=dict(l=0, r=0, t=0, b=0),
#       showlegend=True,
#       legend=dict(
#           yanchor="top",
#           y=0.99,
#           xanchor="left",
#           x=0.01,
#           bgcolor='rgba(255,255,255,0.8)'
#       )
#   )

#   fig.show()

#   start_col = 0
#   df_simplified = simplify_matrix(df_matrix, intersection_to_cluster, cluster_colors)
#   styled_df_simplified = style_simplified_df(df_simplified, intersection_to_cluster, cluster_colors)
#   # styled_df_simplified

#   df_filtered = filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster)
#   styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
#   # styled_filtered


#   df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0)
#   styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
#   # styled_filtered

#   while(next_col_idx!=df_filtered.shape[1]):
#       print(next_col_idx)
#       df_filtered = filter_lonely_row_column_intersections(df_filtered, intersection_to_cluster)
#       styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)

#       df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=next_col_idx)
#       styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)

#   styled_filtered
#   save_remaining_coordinates(df_filtered, intersection_points_dict)

import pandas as pd
import numpy as np
from shapely.geometry import LineString
from collections import defaultdict
import plotly.graph_objects as go
import plotly.express as px
from sklearn.cluster import DBSCAN

for grid_id in grid_info:
    intersection_lobs = [
        [float(a), float(b), float(c), float(d)]
        for a, b, c, d in grid_id['intersection_lobs']
    ]

    # Group LOBs by start point
    start_point_groups = defaultdict(list)
    for lob in intersection_lobs:
        start = (lob[0], lob[1])
        start_point_groups[start].append(lob)

    labels = {}
    label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    lob_list = []
    label_index = 0
    for _, lobs in sorted(start_point_groups.items()):
        for i, lob in enumerate(lobs):
            label = f"{label_prefix[label_index]}{i+1}"
            labels[tuple(lob)] = label
            lob_list.append((lob, label))
        label_index += 1

    n = len(lob_list)
    matrix = [['-' for _ in range(n)] for _ in range(n)]
    label_list = [label for _, label in lob_list]
    intersection_points_dict = {}

    for i in range(n):
        for j in range(n):
            if i == j:
                matrix[i][j] = 'â€”'
                continue
            lob1, label1 = lob_list[i]
            lob2, label2 = lob_list[j]
            line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])
            line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])
            if line1.intersects(line2):
                inter = line1.intersection(line2)
                if inter.geom_type == 'Point':
                    matrix[i][j] = f"P({label1}x{label2})"
                    intersection_points_dict[(label1, label2)] = (inter.y, inter.x)
                    intersection_points_dict[(label2, label1)] = (inter.y, inter.x)

    if intersection_points_dict:
        coords = list(intersection_points_dict.values())
        label_pair_list = list(intersection_points_dict.keys())

        distance_matrix = haversine_distance_matrix(coords)
        db = DBSCAN(eps=2, min_samples=1, metric="precomputed")
        cluster_labels = db.fit_predict(distance_matrix)

        # ... (Rest of the code for clustering, centroid calculation, etc.)

    else:
        print(f"No intersection points found in grid ID: {grid_id}")
        # Handle the case where there are no intersections, e.g., skip processing or assign a default value
        continue  # Skip to the next grid_id

    intersection_to_cluster = {
        label_pair_list[i]: cluster_labels[i]
        for i in range(len(cluster_labels))
    }

    cluster_points = defaultdict(list)
    for i, cluster_id in enumerate(cluster_labels):
        cluster_points[cluster_id].append(coords[i])

    cluster_centroids = {
        cid: np.mean(np.array(pts), axis=0)
        for cid, pts in cluster_points.items()
    }

    for key in intersection_points_dict:
        cid = intersection_to_cluster[key]
        intersection_points_dict[key] = tuple(cluster_centroids[cid])

    fig = go.Figure()

    for key in ['calculation', 'recorded']:
        grid = grid_id[key]['grid'] if key == 'recorded' else grid_id[key]
        lats = [pt[1] for pt in grid] + [grid[0][1]]
        lons = [pt[0] for pt in grid] + [grid[0][0]]
        fig.add_trace(go.Scattermapbox(
            lat=lats, lon=lons, mode='lines',
            line=dict(width=2, color='blue' if key == 'calculation' else 'red'),
            name=f"Grid {key.title()}"
        ))

    unique_clusters = set(cluster_labels)
    color_scale = px.colors.qualitative.Alphabet

    for cid in unique_clusters:
        idxs = np.where(cluster_labels == cid)[0]
        color = color_scale[cid % len(color_scale)]
        for i in idxs:
            pt = cluster_centroids[cid]
            # fig.add_trace(go.Scattermapbox(
            #     lat=[pt[0]], lon=[pt[1]], mode='markers+text',
            #     marker=dict(size=10, color=color),
            #     text=[f"Cluster {cid}"],
            #     textposition="top right", showlegend=False
            # ))

    all_lats = [pt[1] for pt in grid_id['recorded']['grid'] + grid_id['calculation']]
    all_lons = [pt[0] for pt in grid_id['recorded']['grid'] + grid_id['calculation']]

    # fig.update_layout(
    #     mapbox=dict(style='open-street-map', zoom=15,
    #                 center=dict(lat=np.mean(all_lats), lon=np.mean(all_lons))),
    #     height=800, margin=dict(l=0, r=0, t=0, b=0), showlegend=True
    # )

    # fig.show()

    df_simplified = simplify_matrix(df_matrix, intersection_to_cluster, cluster_colors)
    df_filtered = filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster)
    df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, 0)

    while next_col_idx != df_filtered.shape[1]:
        df_filtered = filter_lonely_row_column_intersections(df_filtered, intersection_to_cluster)
        df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, next_col_idx)

    save_remaining_coordinates(df_filtered, intersection_points_dict)