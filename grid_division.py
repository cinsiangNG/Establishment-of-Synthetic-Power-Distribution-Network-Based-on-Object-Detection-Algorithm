# -*- coding: utf-8 -*-
"""Grid_Division.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kUdY5RXUfLJYgWUuLh1rJhisgDaitZTd
"""

!pip install streetlevel

import pandas as pd
# read ROI route points (locations to download street view images)

workingdirectory = '/content/'

LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv")
# LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv",converters={'panoid':str})
# RouteIDs = LumbertonRoutesPoints['RTE_NM'].unique() # unique route ID
LumbertonRoutesPoints = LumbertonRoutesPoints.drop_duplicates()
LumbertonRoutesPoints.info()

# prepare required functions
import math

def decode_polyline(polyline_str):
    '''Pass a Google Maps encoded polyline string; returns list of lat/lon pairs'''
    index, lat, lng = 0, 0, 0
    coordinates = []
    changes = {'latitude': 0, 'longitude': 0}

    # Coordinates have variable length when encoded, so just keep
    # track of whether we've hit the end of the string. In each
    # while loop iteration, a single coordinate is decoded.
    while index < len(polyline_str):
        # Gather lat/lon changes, store them in a dictionary to apply them later
        for unit in ['latitude', 'longitude']:
            shift, result = 0, 0
            while True:
                byte = ord(polyline_str[index]) - 63
                index += 1
                result |= (byte & 0x1f) << shift
                shift += 5
                if not byte >= 0x20:
                    break
            if (result & 1):
                changes[unit] = ~(result >> 1)
            else:
                changes[unit] = (result >> 1)
        lat += changes['latitude']
        lng += changes['longitude']
        coordinates.append((lat / 100000.0, lng / 100000.0))
    return coordinates

def getpathpoints(dirs,pts_distance=50):
  # polypath = dirs[0]['legs'][0]['steps'][0]['polyline']['points']
  polypath = dirs[0]['overview_polyline']['points']
  polypath_pts = decode_polyline(polypath)
  pts_coords = []
  for pt in range(1, len(polypath_pts)):
    lat1 = polypath_pts[pt-1][0]
    lng1 = polypath_pts[pt-1][1]
    lat2 = polypath_pts[pt][0]
    lng2 = polypath_pts[pt][1]
    azimuth = calculateBearing(lat1,lng1,lat2,lng2)
    coords = getInnerPoints(pts_distance,azimuth,lat1,lng1,lat2,lng2)
    if pt==1:
      pts_coords.append(coords)
    else:
      pts_coords.append(coords[1:])
  flatten_pts_coords = []
  for subl in pts_coords:
      for item in subl:
          flatten_pts_coords.append(item)
  return flatten_pts_coords

def getPathLength(lat1,lng1,lat2,lng2):
    '''calculates the distance between two lat, long coordinate pairs'''
    R = 6371000 # radius of earth in m
    lat1rads = math.radians(lat1)
    lat2rads = math.radians(lat2)
    deltaLat = math.radians((lat2-lat1))
    deltaLng = math.radians((lng2-lng1))
    a = math.sin(deltaLat/2) * math.sin(deltaLat/2) + math.cos(lat1rads) * math.cos(lat2rads) * math.sin(deltaLng/2) * math.sin(deltaLng/2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = R * c
    return d

def getDestinationLatLong(lat,lng,azimuth,distance):
    '''returns the lat an long of destination point
    given the start lat, long, aziuth, and distance'''
    R = 6378.1 #Radius of the Earth in km
    brng = math.radians(azimuth) #Bearing is degrees converted to radians.
    d = distance/1000 #Distance m converted to km
    lat1 = math.radians(lat) #Current dd lat point converted to radians
    lon1 = math.radians(lng) #Current dd long point converted to radians
    lat2 = math.asin(math.sin(lat1) * math.cos(d/R) + math.cos(lat1)* math.sin(d/R)* math.cos(brng))
    lon2 = lon1 + math.atan2(math.sin(brng) * math.sin(d/R)* math.cos(lat1), math.cos(d/R)- math.sin(lat1)* math.sin(lat2))
    #convert back to degrees
    lat2 = math.degrees(lat2)
    lon2 = math.degrees(lon2)
    return[lat2, lon2]

def calculateBearing(lat1,lng1,lat2,lng2):
    '''calculates the azimuth in degrees from start point to end point'''
    startLat = math.radians(lat1)
    startLong = math.radians(lng1)
    endLat = math.radians(lat2)
    endLong = math.radians(lng2)
    dLong = endLong - startLong
    dPhi = math.log(math.tan(endLat/2.0+math.pi/4.0)/math.tan(startLat/2.0+math.pi/4.0))
    if abs(dLong) > math.pi:
         if dLong > 0.0:
             dLong = -(2.0 * math.pi - dLong)
         else:
             dLong = (2.0 * math.pi + dLong)
    bearing = (math.degrees(math.atan2(dLong, dPhi)) + 360.0) % 360.0;
    return bearing

def getInnerPoints(interval,azimuth,lat1,lng1,lat2,lng2):
    '''returns every coordinate pair inbetween two coordinate
    pairs given the desired interval'''

    d = getPathLength(lat1,lng1,lat2,lng2)
    remainder, dist = math.modf((d / interval))
    counter = float(interval)
    coords = []
    coords.append([lat1,lng1])
    for distance in range(0,int(dist)):
        coord = getDestinationLatLong(lat1,lng1,azimuth,counter)
        counter = counter + float(interval)
        coords.append(coord)
    coords.append([lat2,lng2])
    return coords

def samepoint(line1, line2):
  result = False
  for x in line1:
    for y in line2:
      if x == y:
        result = True
        return x
        break
  return result

def find_intersection(p0, p1, p2, p3):
    # line1 = [p0.tolist(),p1.tolist()]
    # line2 = [p2.tolist(),p3.tolist()]
    line1 = [p0,p1]
    line2 = [p2,p3]
    samept = samepoint(line1,line2)
    if samept is not False:
      intersection_point = samept
    else:
      s10_x = p1[0] - p0[0]
      s10_y = p1[1] - p0[1]
      s32_x = p3[0] - p2[0]
      s32_y = p3[1] - p2[1]
      denom = s10_x * s32_y - s32_x * s10_y
      if denom == 0 : return math.nan # collinear
      denom_is_positive = denom > 0
      s02_x = p0[0] - p2[0]
      s02_y = p0[1] - p2[1]
      s_numer = s10_x * s02_y - s10_y * s02_x
      if (s_numer < 0) == denom_is_positive : return math.nan # no collision
      t_numer = s32_x * s02_y - s32_y * s02_x
      if (t_numer < 0) == denom_is_positive : return math.nan # no collision
      if (s_numer > denom) == denom_is_positive or (t_numer > denom) == denom_is_positive : return math.nan # no collision
      # collision detected
      t = t_numer / denom
      intersection_point = [ p0[0] + (t * s10_x), p0[1] + (t * s10_y) ]
    return intersection_point

import numpy as np
import math

def calculate_baseline_length(trajectory_points):
    """
    计算轨迹基线长度

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon],...]

    Returns:
        baseline: 基线长度(米)
    """
    total_length = 0
    for i in range(len(trajectory_points)-1):
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[i+1]
        # 使用已有的getPathLength函数计算两点间距离
        length = getPathLength(pt1[0], pt1[1], pt2[0], pt2[1])
        total_length += length

    # 返回平均段长作为基线长度
    return total_length / (len(trajectory_points)-1)

from geopy.distance import geodesic

def calculate_mst_baseline(trajectory_points, MST):
    """
    计算 MST 的基线长度

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon],...]
        MST: NetworkX 计算出的最小生成树 (Minimum Spanning Tree)

    Returns:
        baseline: 基线长度(米)
    """
    total_length = 0
    edge_count = 0

    for i, j in MST.edges():
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[j]
        length = geodesic(pt1, pt2).meters  # 計算地理距離
        total_length += length
        edge_count += 1
        print(i,j, trajectory_points[i], trajectory_points[j])

    # 返回平均邊長作為基線
    return total_length / edge_count if edge_count > 0 else 0



def create_grid_cell(pt1, pt2, grid_size, bearing):
    """
    创建单个网格单元

    Args:
        pt1, pt2: 网格两端点坐标 [lat, lon]
        grid_size: 网格大小(米)
        bearing: 方位角(度)

    Returns:
        grid_vertices: 网格顶点坐标列表
    """
    # 计算垂直于行驶方向的偏移
    perpendicular_bearing1 = (bearing + 90) % 360
    perpendicular_bearing2 = (bearing - 90) % 360

    # 计算网格四个顶点
    v1 = getDestinationLatLong(pt1[0], pt1[1], perpendicular_bearing1, grid_size/2)
    v2 = getDestinationLatLong(pt1[0], pt1[1], perpendicular_bearing2, grid_size/2)
    v3 = getDestinationLatLong(pt2[0], pt2[1], perpendicular_bearing1, grid_size/2)
    v4 = getDestinationLatLong(pt2[0], pt2[1], perpendicular_bearing2, grid_size/2)

    return [v1, v2, v4, v3, v1]  # 闭合多边形

#論文方法
def ceil_div(a, b):
    """向上取整除法"""
    return math.ceil(a / b)

import math

def create_grid_cells(trajectory_points, effective_distance):
    """
    基于轨迹点划分自适应网格

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon], ...]
        effective_distance: 影响范围（用于计算网格大小）

    Returns:
        grid_cells: 自适应网格划分的结果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
    """

    bl = calculate_baseline_length(trajectory_points)

    # 计算轨迹的边界范围
    min_lon = min(pt[1] for pt in trajectory_points)  # 经度
    max_lon = max(pt[1] for pt in trajectory_points)
    min_lat = min(pt[0] for pt in trajectory_points)  # 纬度
    max_lat = max(pt[0] for pt in trajectory_points)

    # 计算网格大小
    k = max(1, effective_distance / (4.9 * bl))
    grid_size = k * bl
    print("Answer: k =", k, "grid_size =", grid_size, "baseline =", bl)
    grid_cells = []
    # 计算网格的行数和列数
    # n_cols = math.ceil((max_lon - min_lon) / grid_size)
    # n_rows = math.ceil((max_lat - min_lat) / grid_size)
    # grid_cells = []
    # for row in range(n_rows):
    #     for col in range(n_cols):
    #         lon_start = col * grid_size + min_lon
    #         lon_end = (col + 1) * grid_size + min_lon
    #         lat_start = row * grid_size + min_lat
    #         lat_end = (row + 1) * grid_size + min_lat

    #         grid = [
    #             [lat_start, lon_start],
    #             [lat_end, lon_start],
    #             [lat_end, lon_end],
    #             [lat_start, lon_end]
                # ]
    #
    lat_start = min_lat
    lon_start = min_lon
    lat_end = max_lat
    lon_end = max_lon
    grid = [
        [lat_start, lon_start],
        [lat_end, lon_start],
        [lat_end, lon_end],
        [lat_start, lon_end]
        ]
    grid_cells.append(grid)
    print(grid_cells)
    return grid_cells



def adaptive_grid_division(trajectory_points, effective_distance):
    """
    根据行驶轨迹自适应划分计算区域

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon],...]
        effective_distance: 有效采集距离(米)

    Returns:
        grid_cells: 网格单元列表
    """
    # 计算基线长度
    baseline = calculate_baseline_length(trajectory_points)
    # 计算网格大小

    k = max(1, effective_distance/(4.9*baseline))
    grid_size = baseline * k
    print("Answer:k= ", k,"grid_size= ", grid_size, "baseline= ", baseline)

    # 划分网格
    grid_cells = []
    for i in range(len(trajectory_points)-1):
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[i+1]

        # 计算方位角
        bearing = calculateBearing(pt1[0], pt1[1], pt2[0], pt2[1])

        # 创建网格单元
        grid = create_grid_cell(pt1, pt2, grid_size, bearing)
        print(grid)
        grid_cells.append(grid)

    return grid_cells

def LOBintersections(poleLOB, startpoint, nvg = 4, plotresult=False):
  def unnestlist(alist):
    unnestedlist = []
    for subl in alist:
      for item in subl:
        unnestedlist.append(item)
    return unnestedlist

  allintxn = []
  for gg in range(0,len(poleLOB)-nvg+1):
    subLOB = poleLOB[gg:gg+nvg] # subset of LOB group
    intxninsub = [] # all intersections in this subgroup
    for sg in range(0,nvg-1):
      vc = subLOB[sg] # current LOB group
      vo_temp = [x for i,x in enumerate(subLOB) if i!=sg] # all other LOB groups
      vo = unnestlist(vo_temp) # all other LOBs
      for i in range(0,len(vc)):
        for j in range(0,len(vo)):
          intersect = find_intersection(vc[i][0:2], vc[i][2:], vo[j][0:2], vo[j][2:])
          if not intersect is math.nan:
            intxninsub.append(intersect)
    # a[gg] = intxninsub
    allintxn.append(intxninsub)

  # extract unique intersections
  intxn_unnest = unnestlist(allintxn)
  intxn_unique = [i for n, i in enumerate(intxn_unnest) if i not in intxn_unnest[:n]]
  intxn_array = np.array(intxn_unique)

  ## first grouping: combine intersection generated by prediction error
  distMax = 1
  intxngroup = []
  for i in range(0,len(intxn_array)):
    if i not in unnestlist(intxngroup):
      pt0 = intxn_array[i]
      dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in intxn_array]
      closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
      intxngroup.append(closepts)

  intxns = []
  for i in range(0,len(intxngroup)):
    lats = intxn_array[intxngroup[i],0]
    lons = intxn_array[intxngroup[i],1]
    intxns.append([np.mean(lats), np.mean(lons)])

  ## second grouping: combine intersections very close to each other
  distMax = 5
  intxngroup = []

  intxn_array2 = np.array(intxns)
  for i in range(0,len(intxn_array2)):
    if i not in unnestlist(intxngroup):
      pt0 = intxn_array2[i]
      dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in intxn_array2]
      closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
      intxngroup.append(closepts)

  intxns2 = []
  for i in range(0,len(intxngroup)):
    lats = intxn_array2[intxngroup[i],0]
    lons = intxn_array2[intxngroup[i],1]
    intxns2.append([np.mean(lats), np.mean(lons)])

  ## check pole distance
  maxpoledist = 70 # maximum allowable distance b/t poles [urban: 125 ft (38 m); rural: 300 ft (91 m)]
  maxsegdist = 500 # maximum distance b/t route segments; output route points might be quite far away and belong to different road
  intxns_sorted = []
  intxns_index = []
  dist = [(lambda x: getPathLength(startpoint[0],startpoint[1],x[0],x[1]))(x) for x in intxns2]
  if dist:
    intxns_index.append(np.argmin(dist))
    intxns_sorted.append(intxns2[np.argmin(dist)])

  for i in range(1,len(intxns2)):
    prevpt = intxns_sorted[i-1]
    dist = np.array([[n, (lambda x: getPathLength(prevpt[0],prevpt[1],x[0],x[1]))(x)] for n, x in enumerate(intxns2) if n not in intxns_index])
    sortdist = dist[np.argsort(dist[:, 1])]
    intxns_index.append(sortdist[0,0])
    intxns_sorted.append(intxns2[int(sortdist[0,0])])

  intxns3 = intxns_sorted.copy()
  for i in range(1,len(intxns_sorted)-1):
    pt0 = intxns_sorted[i]
    pt1 = intxns_sorted[i+1]
    dist2next = getPathLength(pt0[0],pt0[1],pt1[0],pt1[1])
    if maxpoledist < dist2next < maxsegdist:
      n_pole_needed = int(dist2next // maxpoledist) # number of pole needed to insert
      dist2insertpole = dist2next/(n_pole_needed+1)
      bearing = calculateBearing(pt0[0],pt0[1],pt1[0],pt1[1])
      for j in range(0,n_pole_needed):
        intxns3.append(getDestinationLatLong(pt0[0],pt0[1],bearing,dist2insertpole*(j+1)))
  intxns_final = intxns3.copy()

  ## plot results
  # if plotresult:
  #   finalintxns = intxns_final
  #   print('Number of intersections = {}'.format(len(finalintxns)))
  #   pointtext=[str(x) for x in PanoInfoFinal.index+1]

  #   fig = mapplotpoints(PanoInfoFinal['lat'],PanoInfoFinal['lon'],size = 8, name='street view location', color='DodgerBlue',text=pointtext)
  #   fig.add_trace(go.Scattermapbox(
  #           lat=np.array(finalintxns)[:,0],
  #           lon=np.array(finalintxns)[:,1],
  #           name='possible pole locations',
  #           mode='markers',
  #           marker=go.scattermapbox.Marker(
  #               size=10,
  #               color='red',
  #               opacity=0.9
  #           )))

  #   for i in range(0,len(poleLOB)):
  #     lob = poleLOB[i]
  #     for j in range(0,len(lob)):
  #       fig.add_trace(
  #           go.Scattermapbox(
  #               lon = [np.array(poleLOB[i][j])[1], np.array(poleLOB[i][j])[3]],
  #               lat = [np.array(poleLOB[i][j])[0], np.array(poleLOB[i][j])[2]],
  #               mode = 'lines',
  #               line = dict(width = 1,color = 'Dodgerblue'),
  #               opacity=0.5
  #           )
  #       )
  #   fig.update_layout(
  #       height=650
  #   )
  #   return fig

  return intxns_final

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory_and_grid(trajectory_points, grid_cells):
    """
    視覺化行駛軌跡點與不同顏色的自適應網格

    Args:
        trajectory_points: 行駛軌跡點 (list of [lat, lon])
        grid_cells:  自适应网格划分的结果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
    """
    # 創建地圖
    fig = go.Figure()

    # 1️⃣ 添加行駛軌跡點 (藍色線條)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        # mode='lines+markers',
        name='Trajectory',
        # line=dict(width=2, color='blue'),
        marker=dict(size=5, color='blue')
    ))

    # 2️⃣ 生成不同顏色的網格
    colors = ['red', 'green', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'lime', 'teal', 'orange']

    for i, cell in enumerate(grid_cells):
        cell.append(cell[0])  # 闭合多边形
        grid_color = random.choice(colors)  # 隨機選擇顏色
        fig.add_trace(go.Scattermapbox(
            lat=[pt[0] for pt in cell],
            lon=[pt[1] for pt in cell],
            mode='lines',
            line=dict(width=2, color=grid_color),
            name=f'Grid {i+1}'
        ))

    # 3️⃣ 更新地圖布局
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory(trajectory_points):
    """
    視覺化行駛軌跡點與不同顏色的自適應網格

    Args:
        trajectory_points: 行駛軌跡點 (list of [lat, lon])
        grid_cells:  自适应网格划分的结果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
    """
    # 創建地圖
    fig = go.Figure()

    # 1️⃣ 添加行駛軌跡點 (藍色線條)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        mode='markers',
        name='Trajectory',
        marker=dict(size=5, color='blue')
    ))


    # 3️⃣ 更新地圖布局
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

import numpy as np
import pandas as pd
from streetlevel import streetview

# 参数设置
dist_para = [40*304.8, 1.5, 4.55, 10]
size = (640, 640)
EFFECTIVE_DISTANCE = 50  # 有效采集距离(米)

# 文件路径
path1 = workingdirectory + 'StreetViewImages/'
path2 = workingdirectory + 'resized/'
savepreddir = workingdirectory + 'PolePredictionResults/'

totaldownload = 0

for rr in range(0,len(RouteIDs)):
    routeid = RouteIDs[rr]
    routepoints = LumbertonRoutesPoints.loc[LumbertonRoutesPoints['RTE_NM'] == routeid]
    Pts2downloadPano = routepoints[['Lat','Lon']].values.tolist()

    # 获取街景全景信息
    allpanoid = []
    for panoLatLon in Pts2downloadPano:
        pano = streetview.find_panorama(lat=panoLatLon[0], lon=panoLatLon[1])
        if bool(pano):
            allpanoid.append([pano.id, pano.lat, pano.lon])
    PanoInfoFinal = pd.DataFrame(allpanoid,columns=['panoid','lat','lon']).drop_duplicates()
    print(PanoInfoFinal)

    # 只处理超过3个全景点的路段
    if len(PanoInfoFinal) > 3:
        poleview = []  # 路径上的结果 [相机坐标, 杆体方位角]
        poleLOB = []   # 建议的LOB [起点坐标(相机), 终点坐标]

        # 自适应网格划分
        trajectory_points = PanoInfoFinal[['lat','lon']].values.tolist()
        grid_cells = create_grid_cells(trajectory_points, EFFECTIVE_DISTANCE)
        fig = plot_trajectory_and_grid(trajectory_points, grid_cells)
        fig.show()

import numpy as np
import pandas as pd
from streetlevel import streetview

# 参数设置
dist_para = [40*304.8, 1.5, 4.55, 10]
size = (640, 640)
EFFECTIVE_DISTANCE = 50  # 有效采集距离(米)

# 文件路径
path1 = workingdirectory + 'StreetViewImages/'
path2 = workingdirectory + 'resized/'
savepreddir = workingdirectory + 'PolePredictionResults/'

totaldownload = 0
trajectory_points = LumbertonRoutesPoints[['Lat','Lon']].values.tolist()
print(len(trajectory_points))
grid_cells = create_grid_cells(trajectory_points,EFFECTIVE_DISTANCE)

fig = plot_trajectory_and_grid(trajectory_points, grid_cells)
fig.show()

import numpy as np
import networkx as nx
from geopy.distance import geodesic
import plotly.graph_objects as go

print(len(trajectory_points))
# 計算地理距離的距離矩陣
n = len(trajectory_points)
dist_matrix = np.zeros((n, n))
for i in range(n):
    for j in range(i + 1, n):
        dist = geodesic(trajectory_points[i], trajectory_points[j]).meters  # 計算兩點之間的距離（以米為單位）
        dist_matrix[i, j] = dist_matrix[j, i] = dist

# 建立圖（所有點相連，權重為地理距離）
G = nx.Graph()
for i in range(n):
    for j in range(i + 1, n):
        G.add_edge(i, j, weight=dist_matrix[i, j])

# 計算 MST（最小生成樹）
MST = nx.minimum_spanning_tree(G, algorithm='prim')

# 取出 MST 連線的點
lats, lons = zip(*trajectory_points)  # 拆分緯度和經度
edges_x = []
edges_y = []

# 連線的 x, y 座標
for edge in MST.edges():
    i, j = edge
    edges_x.append([lons[i], lons[j]])
    edges_y.append([lats[i], lats[j]])

# 畫圖
# fig = go.Figure()

# # 畫出電線杆座標
# fig.add_trace(go.Scattermapbox(
#     lat=lats,
#     lon=lons,
#     mode='markers',
#     name='Electric Poles',
#     marker=dict(
#         size=7,
#         color='red',
#         opacity=0.8
#     )
# ))

# # 畫出 MST 連線
# for x, y in zip(edges_x, edges_y):
#     fig.add_trace(go.Scattermapbox(
#         lat=y,
#         lon=x,
#         mode='lines',
#         line=dict(width=2, color='blue'),
#         name='MST Connections'
#     ))

# # 更新布局
# fig.update_layout(
#     mapbox=dict(
#         style='carto-positron',
#         zoom=15,
#         center=dict(
#             lat=np.mean(lats),
#             lon=np.mean(lons)
#         )
#     ),
#     height=800,
#     margin=dict(l=0, r=0, t=0, b=0),
#     showlegend=True,
#     legend=dict(
#         yanchor="top",
#         y=0.99,
#         xanchor="left",
#         x=0.01,
#         bgcolor='rgba(255,255,255,0.8)'
#     )
# )

# # 顯示圖
# fig.show()

# 計算基線長度
baseline_length = calculate_mst_baseline(trajectory_points, MST)
print("MST Baseline Length:", baseline_length, "meters")

grid_cells_flatten = grid_cells[0]
print(grid_cells_flatten)
#左下，左上，右上，右下
k = (1+(50/(2*math.sqrt(2)*baseline_length)))/2
print(50/(2*math.sqrt(2)*baseline_length))
print(k)
dist_y = geodesic(grid_cells_flatten[1],grid_cells_flatten[0]).meters
dist_x = geodesic(grid_cells_flatten[2],grid_cells_flatten[1]).meters
print("垂直距離：",dist_y, "\n水平距離：",dist_x)
nrow = math.ceil(dist_y/(k*baseline_length))
ncol = math.ceil(dist_x/(k*baseline_length))
print("nrow: ",nrow, "\nncol: ",ncol)

import numpy as np
from geopy.distance import geodesic

# 获取四个角点
p1, p2, p3, p4 = grid_cells_flatten[:4]

# 计算步长
step_y = dist_y / nrow
step_x = dist_x / ncol

# 生成网格点
lat_values = np.linspace(p1[0], p2[0], nrow + 1)  # 纵向切分点
lon_values = np.linspace(p1[1], p3[1], ncol + 1)  # 横向切分点

# 存储所有 grid cells
each_grid_cells = []

# 迭代生成所有小网格
for i in range(nrow):
    for j in range(ncol):
        lat1, lat2 = lat_values[i], lat_values[i + 1]
        lon1, lon2 = lon_values[j], lon_values[j + 1]

        # 构造一个 grid cell
        grid_cell = [
            [lat1, lon1],  # 左下角
            [lat2, lon1],  # 左上角
            [lat2, lon2],  # 右上角
            [lat1, lon2],  # 右下角
            [lat1, lon1]
        ]

        each_grid_cells.append(grid_cell)

# 输出示例
print(f"总网格数: {len(each_grid_cells)}")
print("示例网格:", each_grid_cells)

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()


for grid_cell in grid_cells:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Outer Grid Cell'
    ))

for grid_cell in each_grid_cells[15500:16000]:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='green'),
        name='Grid Cell'
    ))

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='carto-positron',
        zoom=15,
        center=dict(
            lat=np.mean([pt[0] for cell in each_grid_cells for pt in cell]),
            lon=np.mean([pt[1] for cell in each_grid_cells for pt in cell])
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖
fig.show()

import numpy as np

# 計算每個 MST 點所屬的 grid(recorded)
min_lon = min(pt[1] for pt in trajectory_points)  # 经度
max_lon = max(pt[1] for pt in trajectory_points)
min_lat = min(pt[0] for pt in trajectory_points)  # 纬度
max_lat = max(pt[0] for pt in trajectory_points)
bl=baseline_length

# 記錄每個 MST 點對應的 grid(recorded) 及其周圍的 grid(calculation)
grid_info = []

# 轉換比例
def meters_to_lat(meters):
    return meters / 110540  # 1度緯度約110540米

def meters_to_lon(meters, lat):
    return meters / (111320 * np.cos(np.radians(lat)))  # 1度經度約111320米 * cos(緯度)

for lat, lon in zip(lats, lons):
    delta_lat = meters_to_lat(k * bl)
    delta_lon = meters_to_lon(k * bl, lat)

    col = int((lon - min_lon) / delta_lon)
    row = int((lat - min_lat) / delta_lat)

    grid_recorded = {
        "row": row,
        "col": col,
        "grid": [
            [min_lon + col * delta_lon, min_lat + row * delta_lat],  # 左下
            [min_lon + (col + 1) * delta_lon, min_lat + row * delta_lat],  # 右下
            [min_lon + (col + 1) * delta_lon, min_lat + (row + 1) * delta_lat],  # 右上
            [min_lon + col * delta_lon, min_lat + (row + 1) * delta_lat],  # 左上
            [min_lon + col * delta_lon, min_lat + row * delta_lat]  # 回到左下
        ]
    }

    # 計算 grid(calculation) 範圍 (包含周圍8個 grid)
    grid_calculation = [
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat],  # 左下
        [min_lon + (col + 2) * delta_lon, min_lat + (row - 1) * delta_lat],  # 右下
        [min_lon + (col + 2) * delta_lon, min_lat + (row + 2) * delta_lat],  # 右上
        [min_lon + (col - 1) * delta_lon, min_lat + (row + 2) * delta_lat],  # 左上
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat]  # 回到左下
    ]

    grid_info.append({
        "recorded": grid_recorded,
        "calculation": grid_calculation
    })


# 這樣每個 MST 點都會對應一個 grid(recorded) 及其周圍 9 個 grid(calculation)

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 取得第一個 grid_calculation 和 grid_recorded
first_grid_info = grid_info[50]

# 畫出 grid_calculation（藍色）
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]  # 緯度
lon_values = [pt[0] for pt in grid_calculation]  # 經度
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# 畫出 grid_recorded（紅色）
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]  # 緯度
lon_values = [pt[0] for pt in grid_recorded]  # 經度
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# 計算地圖中心點
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # 使用免費地圖
        zoom=12,  # 減少 zoom 避免太靠近
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖
print(first_grid_info)
fig.show()

print(grid_info[0]['calculation'])

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 記錄所有點的經緯度，以便計算地圖中心
all_lats = []
all_lons = []

# 遍歷 grid_info[50:100]
for grid_data in grid_info[1150:1175]:
    # 繪製 grid_calculation（藍色）
    grid_calculation = grid_data["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]  # 緯度
    lon_values = [pt[0] for pt in grid_calculation]  # 經度
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation'
    ))

    # 繪製 grid_recorded（紅色）
    grid_recorded = grid_data["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]  # 緯度
    lon_values = [pt[0] for pt in grid_recorded]  # 經度
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded'
    ))

    # 累積所有點的經緯度
    all_lats.extend([pt[1] for pt in grid_calculation + grid_recorded])
    all_lons.extend([pt[0] for pt in grid_calculation + grid_recorded])

# 設定地圖中心
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # 使用免費地圖
        zoom=12,  # 適當縮放
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖表
fig.show()

from google.colab import drive
drive.mount("/content/drive")

LOBS = pd.read_csv("/content/poleLOB.csv")
print(len(LOBS))
LOBS = LOBS.drop_duplicates(subset=["start_lat", "start_lon", "end_lat", "end_lon"])
LOBS.to_csv("/content/poleLOB_drop_duplicates.csv")
print(len(LOBS))

from shapely.geometry import Point, Polygon

for grid in grid_info:
    grid_polygon_coords = grid['calculation']
    polygon = Polygon(grid_polygon_coords)
    lobs_in_polygon = set()  # 使用 set 自動去除重複

    for _, row in LOBS.iterrows():
        start_point = Point(row["start_lon"], row["start_lat"])
        end_point = Point(row["end_lon"], row["end_lat"])

        if polygon.contains(start_point) or polygon.contains(end_point):
            lob = (
                row["start_lat"], row["start_lon"],
                row["end_lat"], row["end_lon"]
            )
            lobs_in_polygon.add(lob)  # 加入 set，自動去除重複

    # 將 set 轉為 list 存入 grid 中
    grid['lobs_in_polygon'] = list(lobs_in_polygon)

print(len(grid_info[1991]['lobs_in_polygon']))
print(grid_info[1151]['lobs_in_polygon'])

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 取得指定 grid_info
first_grid_info = grid_info[1991]

# 畫出 grid_calculation（藍色）
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]
lon_values = [pt[0] for pt in grid_calculation]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],  # 閉合多邊形
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# 畫出 grid_recorded（紅色）
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]
lon_values = [pt[0] for pt in grid_recorded]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# 畫出 intersecting LOBs（綠色）
for lob in first_grid_info["lobs_in_polygon"]:
    start_lat, start_lon, end_lat, end_lon = lob
    fig.add_trace(go.Scattermapbox(
        lat=[start_lat, end_lat],
        lon=[start_lon, end_lon],
        mode='lines+markers',
        line=dict(width=2, color='green'),
        marker=dict(size=6, color='green'),
        name='LOB in Grid',
        showlegend=False  # 避免重複圖例
    ))

# 計算地圖中心
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖與確認資料
print(first_grid_info)
fig.show()

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 記錄所有經緯度以便計算地圖中心
all_lats = []
all_lons = []

# 取得多個 grid_info
for grid in grid_info[1150:1175]:
    # 畫出 grid_calculation（藍色）
    grid_calculation = grid["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]
    lon_values = [pt[0] for pt in grid_calculation]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],  # 閉合多邊形
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation',
        showlegend=False  # 避免重複圖例
    ))

    # 畫出 grid_recorded（紅色）
    grid_recorded = grid["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]
    lon_values = [pt[0] for pt in grid_recorded]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded',
        showlegend=False
    ))

    # 畫出 intersecting LOBs（綠色）
    for lob in grid["lobs_in_polygon"]:
        start_lat, start_lon, end_lat, end_lon = lob
        fig.add_trace(go.Scattermapbox(
            lat=[start_lat, end_lat],
            lon=[start_lon, end_lon],
            mode='lines+markers',
            line=dict(width=2, color='green'),
            marker=dict(size=6, color='green'),
            name='LOB in Grid',
            showlegend=False
        ))

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()