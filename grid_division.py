# -*- coding: utf-8 -*-
"""Grid_Division.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kUdY5RXUfLJYgWUuLh1rJhisgDaitZTd
"""

!pip install streetlevel

import pandas as pd
# read ROI route points (locations to download street view images)

workingdirectory = '/content/'

LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv")
# LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv",converters={'panoid':str})
# RouteIDs = LumbertonRoutesPoints['RTE_NM'].unique() # unique route ID
LumbertonRoutesPoints = LumbertonRoutesPoints.drop_duplicates()
LumbertonRoutesPoints.info()

# prepare required functions
import math

def decode_polyline(polyline_str):
    '''Pass a Google Maps encoded polyline string; returns list of lat/lon pairs'''
    index, lat, lng = 0, 0, 0
    coordinates = []
    changes = {'latitude': 0, 'longitude': 0}

    # Coordinates have variable length when encoded, so just keep
    # track of whether we've hit the end of the string. In each
    # while loop iteration, a single coordinate is decoded.
    while index < len(polyline_str):
        # Gather lat/lon changes, store them in a dictionary to apply them later
        for unit in ['latitude', 'longitude']:
            shift, result = 0, 0
            while True:
                byte = ord(polyline_str[index]) - 63
                index += 1
                result |= (byte & 0x1f) << shift
                shift += 5
                if not byte >= 0x20:
                    break
            if (result & 1):
                changes[unit] = ~(result >> 1)
            else:
                changes[unit] = (result >> 1)
        lat += changes['latitude']
        lng += changes['longitude']
        coordinates.append((lat / 100000.0, lng / 100000.0))
    return coordinates

def getpathpoints(dirs,pts_distance=50):
  # polypath = dirs[0]['legs'][0]['steps'][0]['polyline']['points']
  polypath = dirs[0]['overview_polyline']['points']
  polypath_pts = decode_polyline(polypath)
  pts_coords = []
  for pt in range(1, len(polypath_pts)):
    lat1 = polypath_pts[pt-1][0]
    lng1 = polypath_pts[pt-1][1]
    lat2 = polypath_pts[pt][0]
    lng2 = polypath_pts[pt][1]
    azimuth = calculateBearing(lat1,lng1,lat2,lng2)
    coords = getInnerPoints(pts_distance,azimuth,lat1,lng1,lat2,lng2)
    if pt==1:
      pts_coords.append(coords)
    else:
      pts_coords.append(coords[1:])
  flatten_pts_coords = []
  for subl in pts_coords:
      for item in subl:
          flatten_pts_coords.append(item)
  return flatten_pts_coords

def getPathLength(lat1,lng1,lat2,lng2):
    '''calculates the distance between two lat, long coordinate pairs'''
    R = 6371000 # radius of earth in m
    lat1rads = math.radians(lat1)
    lat2rads = math.radians(lat2)
    deltaLat = math.radians((lat2-lat1))
    deltaLng = math.radians((lng2-lng1))
    a = math.sin(deltaLat/2) * math.sin(deltaLat/2) + math.cos(lat1rads) * math.cos(lat2rads) * math.sin(deltaLng/2) * math.sin(deltaLng/2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = R * c
    return d

def getDestinationLatLong(lat,lng,azimuth,distance):
    '''returns the lat an long of destination point
    given the start lat, long, aziuth, and distance'''
    R = 6378.1 #Radius of the Earth in km
    brng = math.radians(azimuth) #Bearing is degrees converted to radians.
    d = distance/1000 #Distance m converted to km
    lat1 = math.radians(lat) #Current dd lat point converted to radians
    lon1 = math.radians(lng) #Current dd long point converted to radians
    lat2 = math.asin(math.sin(lat1) * math.cos(d/R) + math.cos(lat1)* math.sin(d/R)* math.cos(brng))
    lon2 = lon1 + math.atan2(math.sin(brng) * math.sin(d/R)* math.cos(lat1), math.cos(d/R)- math.sin(lat1)* math.sin(lat2))
    #convert back to degrees
    lat2 = math.degrees(lat2)
    lon2 = math.degrees(lon2)
    return[lat2, lon2]

def calculateBearing(lat1,lng1,lat2,lng2):
    '''calculates the azimuth in degrees from start point to end point'''
    startLat = math.radians(lat1)
    startLong = math.radians(lng1)
    endLat = math.radians(lat2)
    endLong = math.radians(lng2)
    dLong = endLong - startLong
    dPhi = math.log(math.tan(endLat/2.0+math.pi/4.0)/math.tan(startLat/2.0+math.pi/4.0))
    if abs(dLong) > math.pi:
         if dLong > 0.0:
             dLong = -(2.0 * math.pi - dLong)
         else:
             dLong = (2.0 * math.pi + dLong)
    bearing = (math.degrees(math.atan2(dLong, dPhi)) + 360.0) % 360.0;
    return bearing

def getInnerPoints(interval,azimuth,lat1,lng1,lat2,lng2):
    '''returns every coordinate pair inbetween two coordinate
    pairs given the desired interval'''

    d = getPathLength(lat1,lng1,lat2,lng2)
    remainder, dist = math.modf((d / interval))
    counter = float(interval)
    coords = []
    coords.append([lat1,lng1])
    for distance in range(0,int(dist)):
        coord = getDestinationLatLong(lat1,lng1,azimuth,counter)
        counter = counter + float(interval)
        coords.append(coord)
    coords.append([lat2,lng2])
    return coords

def samepoint(line1, line2):
  result = False
  for x in line1:
    for y in line2:
      if x == y:
        result = True
        return x
        break
  return result

def find_intersection(p0, p1, p2, p3):
    # line1 = [p0.tolist(),p1.tolist()]
    # line2 = [p2.tolist(),p3.tolist()]
    line1 = [p0,p1]
    line2 = [p2,p3]
    samept = samepoint(line1,line2)
    if samept is not False:
      intersection_point = samept
    else:
      s10_x = p1[0] - p0[0]
      s10_y = p1[1] - p0[1]
      s32_x = p3[0] - p2[0]
      s32_y = p3[1] - p2[1]
      denom = s10_x * s32_y - s32_x * s10_y
      if denom == 0 : return math.nan # collinear
      denom_is_positive = denom > 0
      s02_x = p0[0] - p2[0]
      s02_y = p0[1] - p2[1]
      s_numer = s10_x * s02_y - s10_y * s02_x
      if (s_numer < 0) == denom_is_positive : return math.nan # no collision
      t_numer = s32_x * s02_y - s32_y * s02_x
      if (t_numer < 0) == denom_is_positive : return math.nan # no collision
      if (s_numer > denom) == denom_is_positive or (t_numer > denom) == denom_is_positive : return math.nan # no collision
      # collision detected
      t = t_numer / denom
      intersection_point = [ p0[0] + (t * s10_x), p0[1] + (t * s10_y) ]
    return intersection_point

import numpy as np
import math

def calculate_baseline_length(trajectory_points):
    """
    计算轨迹基线长度

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon],...]

    Returns:
        baseline: 基线长度(米)
    """
    total_length = 0
    for i in range(len(trajectory_points)-1):
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[i+1]
        # 使用已有的getPathLength函数计算两点间距离
        length = getPathLength(pt1[0], pt1[1], pt2[0], pt2[1])
        total_length += length

    # 返回平均段长作为基线长度
    return total_length / (len(trajectory_points)-1)

from geopy.distance import geodesic

def calculate_mst_baseline(trajectory_points, MST):
    """
    计算 MST 的基线长度

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon],...]
        MST: NetworkX 计算出的最小生成树 (Minimum Spanning Tree)

    Returns:
        baseline: 基线长度(米)
    """
    total_length = 0
    edge_count = 0

    for i, j in MST.edges():
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[j]
        length = geodesic(pt1, pt2).meters  # 計算地理距離
        total_length += length
        edge_count += 1
        print(i,j, trajectory_points[i], trajectory_points[j])

    # 返回平均邊長作為基線
    return total_length / edge_count if edge_count > 0 else 0


def create_grid_cells(trajectory_points, effective_distance):
    """
    基于轨迹点划分自适应网格

    Args:
        trajectory_points: 轨迹点列表 [[lat, lon], ...]
        effective_distance: 影响范围（用于计算网格大小）

    Returns:
        grid_cells: 自适应网格划分的结果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
    """

    bl = calculate_baseline_length(trajectory_points)
    grid_cells = []
    # 计算轨迹的边界范围
    min_lon = min(pt[1] for pt in trajectory_points)  # 经度
    max_lon = max(pt[1] for pt in trajectory_points)
    min_lat = min(pt[0] for pt in trajectory_points)  # 纬度
    max_lat = max(pt[0] for pt in trajectory_points)
    lat_start = min_lat
    lon_start = min_lon
    lat_end = max_lat
    lon_end = max_lon
    grid = [
        [lat_start, lon_start],
        [lat_end, lon_start],
        [lat_end, lon_end],
        [lat_start, lon_end]
        ]
    grid_cells.append(grid)
    print(grid_cells)
    return grid_cells

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory_and_grid(trajectory_points, grid_cells):
    """
    視覺化行駛軌跡點與不同顏色的自適應網格

    Args:
        trajectory_points: 行駛軌跡點 (list of [lat, lon])
        grid_cells:  自适应网格划分的结果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
    """
    # 創建地圖
    fig = go.Figure()

    # 1️⃣ 添加行駛軌跡點 (藍色線條)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        # mode='lines+markers',
        name='Trajectory',
        # line=dict(width=2, color='blue'),
        marker=dict(size=5, color='blue')
    ))

    # 2️⃣ 生成不同顏色的網格
    colors = ['red', 'green', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'lime', 'teal', 'orange']

    for i, cell in enumerate(grid_cells):
        cell.append(cell[0])  # 闭合多边形
        grid_color = random.choice(colors)  # 隨機選擇顏色
        fig.add_trace(go.Scattermapbox(
            lat=[pt[0] for pt in cell],
            lon=[pt[1] for pt in cell],
            mode='lines',
            line=dict(width=2, color=grid_color),
            name=f'Grid {i+1}'
        ))

    # 3️⃣ 更新地圖布局
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory(trajectory_points):
    """
    視覺化行駛軌跡點與不同顏色的自適應網格

    Args:
        trajectory_points: 行駛軌跡點 (list of [lat, lon])
        grid_cells:  自适应网格划分的结果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
    """
    # 創建地圖
    fig = go.Figure()

    # 1️⃣ 添加行駛軌跡點 (藍色線條)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        mode='markers',
        name='Trajectory',
        marker=dict(size=5, color='blue')
    ))


    # 3️⃣ 更新地圖布局
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

"""# **Create outer grid and do grid division(divide outer large grid into several small grid)**"""

import numpy as np
import pandas as pd
from streetlevel import streetview

# 参数设置
dist_para = [40*304.8, 1.5, 4.55, 10]
size = (640, 640)
EFFECTIVE_DISTANCE = 50  # 有效采集距离(米)

# 文件路径
path1 = workingdirectory + 'StreetViewImages/'
path2 = workingdirectory + 'resized/'
savepreddir = workingdirectory + 'PolePredictionResults/'

totaldownload = 0
trajectory_points = LumbertonRoutesPoints[['Lat','Lon']].values.tolist()
print(len(trajectory_points))
grid_cells = create_grid_cells(trajectory_points,EFFECTIVE_DISTANCE)

fig = plot_trajectory_and_grid(trajectory_points, grid_cells)
fig.show()

"""***- use MST to link the trajectory point and stored them in edge_x and edge_y in increasing order of length(m).***"""

import numpy as np
import networkx as nx
from geopy.distance import geodesic
import plotly.graph_objects as go

print(len(trajectory_points))
# 計算地理距離的距離矩陣
n = len(trajectory_points)
dist_matrix = np.zeros((n, n))
for i in range(n):
    for j in range(i + 1, n):
        dist = geodesic(trajectory_points[i], trajectory_points[j]).meters  # 計算兩點之間的距離（以米為單位）
        dist_matrix[i, j] = dist_matrix[j, i] = dist

# 建立圖（所有點相連，權重為地理距離）
G = nx.Graph()
for i in range(n):
    for j in range(i + 1, n):
        G.add_edge(i, j, weight=dist_matrix[i, j])

# 計算 MST（最小生成樹）
MST = nx.minimum_spanning_tree(G, algorithm='prim')

# 取出 MST 連線的點
lats, lons = zip(*trajectory_points)  # 拆分緯度和經度
edges_x = []
edges_y = []

# 連線的 x, y 座標
for edge in MST.edges():
    i, j = edge
    edges_x.append([lons[i], lons[j]])
    edges_y.append([lats[i], lats[j]])

# 畫圖
# fig = go.Figure()

# # 畫出電線杆座標
# fig.add_trace(go.Scattermapbox(
#     lat=lats,
#     lon=lons,
#     mode='markers',
#     name='Electric Poles',
#     marker=dict(
#         size=7,
#         color='red',
#         opacity=0.8
#     )
# ))

# # 畫出 MST 連線
# for x, y in zip(edges_x, edges_y):
#     fig.add_trace(go.Scattermapbox(
#         lat=y,
#         lon=x,
#         mode='lines',
#         line=dict(width=2, color='blue'),
#         name='MST Connections'
#     ))

# # 更新布局
# fig.update_layout(
#     mapbox=dict(
#         style='carto-positron',
#         zoom=15,
#         center=dict(
#             lat=np.mean(lats),
#             lon=np.mean(lons)
#         )
#     ),
#     height=800,
#     margin=dict(l=0, r=0, t=0, b=0),
#     showlegend=True,
#     legend=dict(
#         yanchor="top",
#         y=0.99,
#         xanchor="left",
#         x=0.01,
#         bgcolor='rgba(255,255,255,0.8)'
#     )
# )

# # 顯示圖
# fig.show()

# 計算基線長度
baseline_length = calculate_mst_baseline(trajectory_points, MST)
print("MST Baseline Length:", baseline_length, "meters")

"""***- calculate k, dist_y, dist_x, nrow and ncol.***"""

grid_cells_flatten = grid_cells[0]
print(grid_cells_flatten)
#左下，左上，右上，右下
k = (1+(50/(2*math.sqrt(2)*baseline_length)))/2
print(50/(2*math.sqrt(2)*baseline_length))
print(k)
dist_y = geodesic(grid_cells_flatten[1],grid_cells_flatten[0]).meters
dist_x = geodesic(grid_cells_flatten[2],grid_cells_flatten[1]).meters
print("垂直距離：",dist_y, "\n水平距離：",dist_x)
nrow = math.ceil(dist_y/(k*baseline_length))
ncol = math.ceil(dist_x/(k*baseline_length))
print("nrow: ",nrow, "\nncol: ",ncol)

import numpy as np
from geopy.distance import geodesic

# 获取四个角点
p1, p2, p3, p4 = grid_cells_flatten[:4]

# 计算步长
step_y = dist_y / nrow
step_x = dist_x / ncol

# 生成网格点
lat_values = np.linspace(p1[0], p2[0], nrow + 1)  # 纵向切分点
lon_values = np.linspace(p1[1], p3[1], ncol + 1)  # 横向切分点

# 存储所有 grid cells
each_grid_cells = []

# 迭代生成所有小网格
for i in range(nrow):
    for j in range(ncol):
        lat1, lat2 = lat_values[i], lat_values[i + 1]
        lon1, lon2 = lon_values[j], lon_values[j + 1]

        # 构造一个 grid cell
        grid_cell = [
            [lat1, lon1],  # 左下角
            [lat2, lon1],  # 左上角
            [lat2, lon2],  # 右上角
            [lat1, lon2],  # 右下角
            [lat1, lon1]
        ]

        each_grid_cells.append(grid_cell)

# 输出示例
print(f"总网格数: {len(each_grid_cells)}")
print("示例网格:", each_grid_cells)

"""# **Visualise the grid cell**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()


for grid_cell in grid_cells:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Outer Grid Cell'
    ))

for grid_cell in each_grid_cells[15500:16000]:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='green'),
        name='Grid Cell'
    ))

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='carto-positron',
        zoom=15,
        center=dict(
            lat=np.mean([pt[0] for cell in each_grid_cells for pt in cell]),
            lon=np.mean([pt[1] for cell in each_grid_cells for pt in cell])
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖
fig.show()

"""# **Create grid_info which contain the grid for record and also calculation.**"""

import numpy as np

# 計算每個 MST 點所屬的 grid(recorded)
min_lon = min(pt[1] for pt in trajectory_points)  # 经度
max_lon = max(pt[1] for pt in trajectory_points)
min_lat = min(pt[0] for pt in trajectory_points)  # 纬度
max_lat = max(pt[0] for pt in trajectory_points)
bl=baseline_length

# 記錄每個 MST 點對應的 grid(recorded) 及其周圍的 grid(calculation)
grid_info = []

# 轉換比例
def meters_to_lat(meters):
    return meters / 110540  # 1度緯度約110540米

def meters_to_lon(meters, lat):
    return meters / (111320 * np.cos(np.radians(lat)))  # 1度經度約111320米 * cos(緯度)

for lat, lon in zip(lats, lons):
    delta_lat = meters_to_lat(k * bl)
    delta_lon = meters_to_lon(k * bl, lat)

    col = int((lon - min_lon) / delta_lon)
    row = int((lat - min_lat) / delta_lat)

    grid_recorded = {
        "row": row,
        "col": col,
        "grid": [
            [min_lon + col * delta_lon, min_lat + row * delta_lat],  # 左下
            [min_lon + (col + 1) * delta_lon, min_lat + row * delta_lat],  # 右下
            [min_lon + (col + 1) * delta_lon, min_lat + (row + 1) * delta_lat],  # 右上
            [min_lon + col * delta_lon, min_lat + (row + 1) * delta_lat],  # 左上
            [min_lon + col * delta_lon, min_lat + row * delta_lat]  # 回到左下
        ]
    }

    # 計算 grid(calculation) 範圍 (包含周圍8個 grid)
    grid_calculation = [
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat],  # 左下
        [min_lon + (col + 2) * delta_lon, min_lat + (row - 1) * delta_lat],  # 右下
        [min_lon + (col + 2) * delta_lon, min_lat + (row + 2) * delta_lat],  # 右上
        [min_lon + (col - 1) * delta_lon, min_lat + (row + 2) * delta_lat],  # 左上
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat]  # 回到左下
    ]

    grid_info.append({
        "recorded": grid_recorded,
        "calculation": grid_calculation
    })


# 這樣每個 MST 點都會對應一個 grid(recorded) 及其周圍 9 個 grid(calculation)

"""# **Visualise grid for record and also calculation**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 取得第一個 grid_calculation 和 grid_recorded
first_grid_info = grid_info[1884]

# 畫出 grid_calculation（藍色）
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]  # 緯度
lon_values = [pt[0] for pt in grid_calculation]  # 經度
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# 畫出 grid_recorded（紅色）
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]  # 緯度
lon_values = [pt[0] for pt in grid_recorded]  # 經度
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# 計算地圖中心點
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # 使用免費地圖
        zoom=12,  # 減少 zoom 避免太靠近
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖
print(first_grid_info)
fig.show()

print(grid_info[0]['calculation'])

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 記錄所有點的經緯度，以便計算地圖中心
all_lats = []
all_lons = []

# 遍歷 grid_info[50:100]
for grid_data in grid_info[1150:1175]:
    # 繪製 grid_calculation（藍色）
    grid_calculation = grid_data["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]  # 緯度
    lon_values = [pt[0] for pt in grid_calculation]  # 經度
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation'
    ))

    # 繪製 grid_recorded（紅色）
    grid_recorded = grid_data["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]  # 緯度
    lon_values = [pt[0] for pt in grid_recorded]  # 經度
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded'
    ))

    # 累積所有點的經緯度
    all_lats.extend([pt[1] for pt in grid_calculation + grid_recorded])
    all_lons.extend([pt[0] for pt in grid_calculation + grid_recorded])

# 設定地圖中心
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # 使用免費地圖
        zoom=12,  # 適當縮放
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖表
fig.show()

from google.colab import drive
drive.mount("/content/drive")

LOBS = pd.read_csv("/content/poleLOB_original.csv")
print(len(LOBS))
LOBS = LOBS.drop_duplicates(subset=["start_lat", "start_lon", "end_lat", "end_lon"])
# LOBS.to_csv("/content/poleLOB_drop_duplicates.csv")
print(len(LOBS))

"""# **Remove duplicate of LOBS and also categorize them in proper grid respectively.**"""

from shapely.geometry import Point, Polygon

for grid in grid_info:
    grid_polygon_coords = grid['calculation']
    polygon = Polygon(grid_polygon_coords)
    lobs_in_polygon = set()  # 使用 set 自動去除重複

    for _, row in LOBS.iterrows():
        start_point = Point(row["start_lon"], row["start_lat"])
        end_point = Point(row["end_lon"], row["end_lat"])

        if polygon.contains(start_point) or polygon.contains(end_point):
            lob = (
                row["start_lat"], row["start_lon"],
                row["end_lat"], row["end_lon"]
            )
            lobs_in_polygon.add(lob)  # 加入 set，自動去除重複

    # 將 set 轉為 list 存入 grid 中
    grid['lobs_in_polygon'] = list(lobs_in_polygon)

print(len(grid_info[1151]['lobs_in_polygon']))
print(grid_info[1151]['lobs_in_polygon'])

"""# **Visualise the grid for calculation and LOBs inside the grid**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 取得指定 grid_info
first_grid_info = grid_info[1155]

# 畫出 grid_calculation（藍色）
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]
lon_values = [pt[0] for pt in grid_calculation]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],  # 閉合多邊形
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# 畫出 grid_recorded（紅色）
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]
lon_values = [pt[0] for pt in grid_recorded]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# 畫出 intersecting LOBs（綠色）
for lob in first_grid_info["lobs_in_polygon"]:
    start_lat, start_lon, end_lat, end_lon = lob
    fig.add_trace(go.Scattermapbox(
        lat=[start_lat, end_lat],
        lon=[start_lon, end_lon],
        mode='lines+markers',
        line=dict(width=2, color='green'),
        marker=dict(size=6, color='green'),
        name='LOB in Grid',
        showlegend=False  # 避免重複圖例
    ))

# 計算地圖中心
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# 顯示圖與確認資料
print(first_grid_info)
fig.show()

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 記錄所有經緯度以便計算地圖中心
all_lats = []
all_lons = []

# 取得多個 grid_info
for grid in grid_info[1150:1175]:
    # 畫出 grid_calculation（藍色）
    grid_calculation = grid["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]
    lon_values = [pt[0] for pt in grid_calculation]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation',
        showlegend=False
    ))

    # 畫出 grid_recorded（紅色）
    grid_recorded = grid["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]
    lon_values = [pt[0] for pt in grid_recorded]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded',
        showlegend=False
    ))

    # 畫出 intersecting LOBs（綠色）
    for lob in grid["lobs_in_polygon"]:
        start_lat, start_lon, end_lat, end_lon = lob
        fig.add_trace(go.Scattermapbox(
            lat=[start_lat, end_lat],
            lon=[start_lon, end_lon],
            mode='lines+markers',
            line=dict(width=2, color='green'),
            marker=dict(size=6, color='green'),
            name='LOB in Grid',
            showlegend=False
        ))

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

"""# **Append 2 tupple in grid_info(intersections and lobs_intersection)**
***- to find the intersection of LOBs in grid***
"""

from shapely.geometry import LineString

for grid in grid_info:
    grid_polygon_coords = grid['calculation']
    polygon = Polygon(grid_polygon_coords)

    lobs = grid.get('lobs_in_polygon', [])
    intersections = set()
    intersection_lobs = set()

    # 兩兩配對找交點
    for i in range(len(lobs)):
        for j in range(i + 1, len(lobs)):
            lob1 = lobs[i]
            lob2 = lobs[j]

            line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])  # (lon, lat)
            line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

            if line1.intersects(line2):
                intersection = line1.intersection(line2)

                # 檢查是否為點，並且該點在 grid polygon 裡
                if intersection.geom_type == 'Point' and polygon.contains(intersection):
                    intersections.add((intersection.y, intersection.x))  # 存為 (lat, lon)
                    intersection_lobs.add(tuple(lob1))
                    intersection_lobs.add(tuple(lob2))

    # 存回 grid
    grid['intersections'] = [list(pt) for pt in intersections]
    grid['intersection_lobs'] = [list(lob) for lob in intersection_lobs]

print((grid_info[1155]['intersections']))
print((grid_info[1155]['intersection_lobs']))

"""# **Visualise the grid for calculation and intersectinon_LOBs inside the grid**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# 記錄所有經緯度以便計算地圖中心
all_lats = []
all_lons = []

# 取得多個 grid_info
for grid in grid_info[1151:1152]:
    # 畫出 grid_calculation（藍色）
    grid_calculation = grid["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]
    lon_values = [pt[0] for pt in grid_calculation]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation',
        showlegend=False
    ))

    # 畫出 grid_recorded（紅色）
    grid_recorded = grid["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]
    lon_values = [pt[0] for pt in grid_recorded]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded',
        showlegend=False
    ))

    # 畫出 intersecting LOBs（綠色）
    for lob in grid["intersection_lobs"]:
        start_lat, start_lon, end_lat, end_lon = lob
        fig.add_trace(go.Scattermapbox(
            lat=[start_lat, end_lat],
            lon=[start_lon, end_lon],
            mode='lines+markers',
            line=dict(width=2, color='green'),
            marker=dict(size=6, color='green'),
            name='LOB in Grid',
            showlegend=False
        ))

# 更新佈局
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

print(grid_info[1151]['intersection_lobs'])

"""# **Create Intersection Matrix**

Save the intersection between each set of LOBS in a dictionaries
"""

import pandas as pd
import numpy as np
from shapely.geometry import LineString, Point
from collections import defaultdict

# 處理 intersection_lobs
intersection_lobs = [
    [float(a), float(b), float(c), float(d)]
    for a, b, c, d in grid_info[1151]['intersection_lobs']
]

# 分群根據起點
start_point_groups = defaultdict(list)
for lob in intersection_lobs:
    start = (lob[0], lob[1])  # (lat, lon)
    start_point_groups[start].append(lob)

# 標記 A1, A2, ..., B1, ...
labels = {}
label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
lob_list = []
label_index = 0
for group_start, lobs in sorted(start_point_groups.items()):
    for i, lob in enumerate(lobs):
        label = f"{label_prefix[label_index]}{i+1}"
        labels[tuple(lob)] = label
        lob_list.append((lob, label))
    label_index += 1

# 初始化 matrix 和交點記錄 dict
n = len(lob_list)
matrix = [['-' for _ in range(n)] for _ in range(n)]
label_list = [label for _, label in lob_list]
intersection_points_dict = {}

# 比對交點
for i in range(n):
    for j in range(n):
        if i == j:
            matrix[i][j] = '—'
            continue

        lob1, label1 = lob_list[i]
        lob2, label2 = lob_list[j]
        line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])  # (lon, lat)
        line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

        if line1.intersects(line2):
            intersection = line1.intersection(line2)
            if intersection.geom_type == 'Point':
                matrix[i][j] = f"P({label1}x{label2})"
                intersection_points_dict[(label1, label2)] = (intersection.y, intersection.x)  # lat, lon
                intersection_points_dict[(label2, label1)] = (intersection.y, intersection.x)

# 顯示矩陣
df_matrix = pd.DataFrame(matrix, columns=label_list, index=label_list)
display(df_matrix)

# 印出所有交點
print("所有交點（label 對應的交點座標）:")
for (label_a, label_b), point in intersection_points_dict.items():
    print(f"{label_a} x {label_b} -> 交點座標: (lat={point[0]:.6f}, lon={point[1]:.6f})")

from sklearn.cluster import DBSCAN
import numpy as np
from math import radians, cos, sin, asin, sqrt
from collections import defaultdict

# 將所有交點座標轉為 numpy array
coords = np.array(list(intersection_points_dict.values()))  # [[lat, lon], ...]

# 計算 haversine 距離
def haversine(lat1, lon1, lat2, lon2):
    R = 6371000  # 地球半徑 (公尺)
    dlat = radians(lat2 - lat1)
    dlon = radians(lon2 - lon1)
    a = sin(dlat / 2)**2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2)**2
    return 2 * R * asin(sqrt(a))

# 自訂 haversine 距離矩陣
def haversine_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                dist_matrix[i][j] = haversine(coords[i][0], coords[i][1], coords[j][0], coords[j][1])
    return dist_matrix

# DBSCAN 聚類（eps = 2.5 公尺，min_samples=1 表示自己也能成一群）
distance_matrix = haversine_distance_matrix(coords)
db = DBSCAN(eps=2.5, min_samples=1, metric='precomputed')
labels = db.fit_predict(distance_matrix)

# 為每個 cluster 計算 centroid
cluster_points = defaultdict(list)
for i, label in enumerate(labels):
    cluster_points[label].append(coords[i])

cluster_centroids = {
    label: np.mean(np.array(pts), axis=0)  # 平均 lat/lon
    for label, pts in cluster_points.items()
}

# 將所有交點更新為 centroid
label_keys = list(intersection_points_dict.keys())
for i, key in enumerate(label_keys):
    cluster_id = labels[i]
    centroid = cluster_centroids[cluster_id]
    intersection_points_dict[key] = tuple(centroid)

# 印出結果
print("聚類後交點（使用 centroid 更新）:")
for (label_a, label_b), point in intersection_points_dict.items():
    print(f"{label_a} x {label_b} -> 群中心: (lat={point[0]:.6f}, lon={point[1]:.6f})")

import plotly.graph_objects as go
import numpy as np
import plotly.express as px

fig = go.Figure()

# 取得指定 grid_info
first_grid_info = grid_info[1151]

# 畫出 grid_calculation（藍色）
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]
lon_values = [pt[0] for pt in grid_calculation]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# 畫出 grid_recorded（紅色）
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]
lon_values = [pt[0] for pt in grid_recorded]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# 📌 顯示 intersection points，根據 cluster 上色
unique_cluster_ids = set(labels)
color_scale = px.colors.qualitative.Alphabet  # 或 Set3、Plotly 等配色方案

for cluster_id in unique_cluster_ids:
    # 所有屬於這個 cluster 的交點索引
    indices = np.where(labels == cluster_id)[0]
    cluster_color = color_scale[cluster_id % len(color_scale)]

    # 提取交點並加到圖上
    for idx in indices:
        label_pair = list(intersection_points_dict.keys())[idx]
        point = intersection_points_dict[label_pair]
        fig.add_trace(go.Scattermapbox(
            lat=[point[0]],
            lon=[point[1]],
            mode='markers+text',
            marker=dict(size=10, color=cluster_color),
            text=[f"Cluster {cluster_id}"],
            textposition="top right",
            name=f"Intersection Cluster {cluster_id}",
            showlegend=False
        ))

# 計算地圖中心
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

import pandas as pd
import numpy as np
import plotly.express as px

# 建立顏色表，每個 cluster 對應一個顏色
unique_cluster_ids = sorted(set(labels))
color_palette = px.colors.qualitative.Alphabet
cluster_colors = {
    cid: color_palette[cid % len(color_palette)]
    for cid in unique_cluster_ids
}

# 建立 intersection 對應的 cluster 字典，讓我們知道哪個交點屬於哪個 cluster
intersection_to_cluster = {
    key: cluster_id
    for key, cluster_id in zip(intersection_points_dict.keys(), labels)
}

# 樣式函數，根據位置 i, j 決定是否要上色
def highlight_intersections(val, row_idx, col_idx):
    label1 = df_matrix.index[row_idx]
    label2 = df_matrix.columns[col_idx]

    # 交點字典的 key 有兩種排列順序
    key1 = (label1, label2)
    key2 = (label2, label1)

    if key1 in intersection_to_cluster:
        cluster_id = intersection_to_cluster[key1]
    elif key2 in intersection_to_cluster:
        cluster_id = intersection_to_cluster[key2]
    else:
        return ''  # 無交點，不上色

    color = cluster_colors[cluster_id]
    return f'background-color: {color}; color: black;'

# 建立樣式 DataFrame
def style_df(df):
    styled = df.style

    for i in range(df.shape[0]):
        for j in range(df.shape[1]):
            styled = styled.set_properties(
                subset=pd.IndexSlice[df.index[i], df.columns[j]],
                **{
                    'background-color': highlight_intersections(df.iat[i, j], i, j).replace('background-color:', '').split(';')[0],
                    'color': 'black'
                }
            )
    return styled

# 顯示加色後的矩陣
styled_df = style_df(df_matrix)
styled_df

def simplify_matrix(matrix_df, intersection_to_cluster, cluster_colors):
    n = matrix_df.shape[0]
    simplified = matrix_df.copy()

    for i in range(n):
        for j in range(n):
            if i >= j:
                simplified.iat[i, j] = ''  # 清除對角線與下三角
    return simplified

def style_simplified_df(df, intersection_to_cluster, cluster_colors):
    def highlight(val, row_idx, col_idx):
        label1 = df.index[row_idx]
        label2 = df.columns[col_idx]
        key1 = (label1, label2)
        key2 = (label2, label1)

        if key1 in intersection_to_cluster:
            cid = intersection_to_cluster[key1]
        elif key2 in intersection_to_cluster:
            cid = intersection_to_cluster[key2]
        else:
            return ''
        return f'background-color: {cluster_colors[cid]}; color: black'

    styled = df.style
    for i in range(df.shape[0]):
        for j in range(df.shape[1]):
            if i < j:
                color_style = highlight(df.iat[i, j], i, j)
                styled = styled.set_properties(
                    subset=pd.IndexSlice[df.index[i], df.columns[j]],
                    **{
                        'background-color': color_style.replace('background-color:', '').split(';')[0],
                        'color': 'black'
                    }
                )
    return styled

# 簡化矩陣（上三角 + 無對角線）
df_simplified = simplify_matrix(df_matrix, intersection_to_cluster, cluster_colors)
styled_df_simplified = style_simplified_df(df_simplified, intersection_to_cluster, cluster_colors)
styled_df_simplified

def filter_row_lonely_intersections(df_simplified, intersection_to_cluster):
    df_filtered = df_simplified.copy()

    for i in range(df_filtered.shape[0]):
        row_label = df_filtered.index[i]
        # 記錄每個 cluster 在這一 row 出現幾次
        cluster_count = {}

        for j in range(df_filtered.shape[1]):
            if i >= j:
                continue  # 只處理上三角

            col_label = df_filtered.columns[j]
            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            cluster_count[cluster_id] = cluster_count.get(cluster_id, 0) + 1

        # 再次走過這一 row，把孤立的 intersection 清除
        for j in range(df_filtered.shape[1]):
            if i >= j:
                continue

            col_label = df_filtered.columns[j]
            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            if cluster_count[cluster_id] <= 1:
                # 如果這個 cluster 只出現 1 次，就清除它
                df_filtered.iat[i, j] = '—'

    return df_filtered

df_filtered = filter_row_lonely_intersections(df_simplified, intersection_to_cluster)

# 再上色
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
styled_filtered

def filter_lonely_column_intersections(df_simplified, intersection_to_cluster):
    df_filtered = df_simplified.copy()

    for j in range(df_filtered.shape[1]):
        col_label = df_filtered.columns[j]
        # 記錄每個 cluster 在這一 col 出現幾次
        cluster_count = {}

        for i in range(df_filtered.shape[0]):
            if i >= j:
                continue  # 只處理上三角

            row_label = df_filtered.index[i]
            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            cluster_count[cluster_id] = cluster_count.get(cluster_id, 0) + 1

        # 再次走過這一 column，把孤立的 intersection 清除
        for i in range(df_filtered.shape[0]):
            if i >= j:
                continue

            row_label = df_filtered.index[i]
            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            if cluster_count[cluster_id] <= 1:
                df_filtered.iat[i, j] = '—'

    return df_filtered

df_filtered_column = filter_lonely_column_intersections(df_simplified, intersection_to_cluster)

# 上色顯示
styled_filtered_column = style_simplified_df(df_filtered_column, intersection_to_cluster, cluster_colors)
styled_filtered_column

def filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster):
    df_filtered = df_simplified.copy()

    # 記錄每個 row 和 column 中，每個 cluster 出現次數
    row_cluster_count = {}
    col_cluster_count = {}

    # 先走過一次，統計 row 和 column 的 cluster 數量
    for i in range(df_filtered.shape[0]):
        row_label = df_filtered.index[i]
        for j in range(df_filtered.shape[1]):
            col_label = df_filtered.columns[j]
            if i >= j:
                continue  # 只看上三角

            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]

            row_cluster_count.setdefault(row_label, {}).setdefault(cluster_id, 0)
            row_cluster_count[row_label][cluster_id] += 1

            col_cluster_count.setdefault(col_label, {}).setdefault(cluster_id, 0)
            col_cluster_count[col_label][cluster_id] += 1

    # 再走一次，清掉 row 和 column 都只有1個的交點
    for i in range(df_filtered.shape[0]):
        row_label = df_filtered.index[i]
        for j in range(df_filtered.shape[1]):
            col_label = df_filtered.columns[j]
            if i >= j:
                continue  # 只看上三角

            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]

            # 如果在 row 和 column 上，這個 cluster 都只有出現 1 次
            if row_cluster_count[row_label][cluster_id] <= 1 and col_cluster_count[col_label][cluster_id] <= 1:
                df_filtered.iat[i, j] = '—'

    return df_filtered

df_filtered = filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster)

# 上色
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
styled_filtered

def filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0):
    df_result = df_filtered.copy()

    for j in range(start_col_idx, df_result.shape[1]):
        col_label = df_result.columns[j]
        clusters_in_column = set()

        for i in range(df_result.shape[0]):
            row_label = df_result.index[i]
            if i >= j:
                continue

            key = (row_label, col_label)
            if key not in intersection_to_cluster:
                continue

            cluster_id = intersection_to_cluster[key]
            clusters_in_column.add(cluster_id)

        if len(clusters_in_column) > 1:
            print(f"Column '{col_label}' (index {j}) has multiple clusters: {clusters_in_column}. Marking and stopping.")
            for i in range(df_result.shape[0]):
                if i >= j:
                    continue
                df_result.iat[i, j] = '—'
            return df_result, j + 1  # 回傳下一次要從哪個 column 開始

    print("No more columns with multiple clusters.")
    return df_result, df_result.shape[1]


# 第一次處理
df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0)

# 上色
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
styled_filtered

df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=next_col_idx)
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
styled_filtered

# from collections import Counter

# def filter_columns_with_dominant_cluster(df_filtered, intersection_to_cluster, start_col_idx=0):
#     df_result = df_filtered.copy()

#     for j in range(start_col_idx, df_result.shape[1]):
#         col_label = df_result.columns[j]
#         cluster_counter = Counter()

#         # 統計該 column 中所有 cluster 的出現次數
#         for i in range(df_result.shape[0]):
#             row_label = df_result.index[i]
#             if i >= j:
#                 continue

#             key = (row_label, col_label)
#             if key in intersection_to_cluster:
#                 cluster_id = intersection_to_cluster[key]
#                 cluster_counter[cluster_id] += 1

#         if len(cluster_counter) > 1:
#             # 找出最多次的 cluster
#             most_common = cluster_counter.most_common()
#             top_count = most_common[0][1]
#             top_clusters = [cid for cid, count in most_common if count == top_count]

#             if len(top_clusters) == 1:
#                 dominant_cluster = top_clusters[0]
#                 print(f"Column '{col_label}' (index {j}) has dominant cluster: {dominant_cluster}. Keeping only that cluster.")
#                 for i in range(df_result.shape[0]):
#                     if i >= j:
#                         continue
#                     key = (df_result.index[i], col_label)
#                     if intersection_to_cluster.get(key) != dominant_cluster:
#                         df_result.iat[i, j] = '—'
#             else:
#                 print(f"Column '{col_label}' (index {j}) has no unique dominant cluster: {top_clusters}. Removing entire column.")
#                 for i in range(df_result.shape[0]):
#                     if i >= j:
#                         continue
#                     df_result.iat[i, j] = '—'

#             return df_result, j + 1  # 回傳下一次要從哪個 column 開始

#     print("No more columns with multiple clusters.")
#     return df_result, df_result.shape[1]


# # 第一次處理
# df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0)

# # 上色
# styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
# styled_filtered

# df_filtered, next_col_idx = filter_columns_with_dominant_cluster(df_filtered, intersection_to_cluster, start_col_idx=next_col_idx)
# styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
# styled_filtered

start_col = 0
df_simplified = simplify_matrix(df_matrix, intersection_to_cluster, cluster_colors)
styled_df_simplified = style_simplified_df(df_simplified, intersection_to_cluster, cluster_colors)
# styled_df_simplified

df_filtered = filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster)
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
# styled_filtered


df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0)
styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
# styled_filtered

while(next_col_idx!=df_filtered.shape[1]):
    print(next_col_idx)
    df_filtered = filter_lonely_row_column_intersections(df_filtered, intersection_to_cluster)
    styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)

    df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=next_col_idx)
    styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)

styled_filtered

# import pandas as pd

# def save_remaining_coordinates(df_filtered, intersection_points_dict, output_filename="remaining_coordinates.xlsx"):
#     remaining_coords = []

#     for i in range(df_filtered.shape[0]):
#         for j in range(df_filtered.shape[1]):
#             if i >= j:
#                 continue  # 只看上三角

#             row_label = df_filtered.index[i]
#             col_label = df_filtered.columns[j]

#             if df_filtered.iat[i, j] != '—':
#                 key = (row_label, col_label)
#                 if key in intersection_points_dict:
#                     lat, lon = intersection_points_dict[key]
#                     remaining_coords.append({
#                         "row": row_label,
#                         "col": col_label,
#                         "Latitude": round(lat, 7),   # 可選：增加精度控制避免浮點微小差異影響
#                         "Longitude": round(lon, 7)
#                     })

#     if remaining_coords:
#         df_coords = pd.DataFrame(remaining_coords)

#         # 根據 Latitude 和 Longitude 移除重複點
#         df_coords_unique = df_coords.drop_duplicates(subset=["Latitude", "Longitude"])

#         df_coords_unique.to_excel(output_filename, index=False)
#         print(f"✅ 已移除重複經緯度並儲存至 {output_filename}，共 {len(df_coords_unique)} 筆")
#     else:
#         print("⚠️ 沒有可儲存的交點座標（所有都被刪除）")

# # 使用範例
# save_remaining_coordinates(df_filtered, intersection_points_dict)

import os
import pandas as pd
from openpyxl import load_workbook

def save_remaining_coordinates(df_filtered, intersection_points_dict, output_filename="remaining_coordinates.xlsx"):
    remaining_coords = []

    for i in range(df_filtered.shape[0]):
        for j in range(df_filtered.shape[1]):
            if i >= j:
                continue  # 只看上三角

            row_label = df_filtered.index[i]
            col_label = df_filtered.columns[j]

            if df_filtered.iat[i, j] != '—':
                key = (row_label, col_label)
                if key in intersection_points_dict:
                    lat, lon = intersection_points_dict[key]
                    remaining_coords.append({
                        "Lat": round(lat, 8),
                        "Lon": round(lon, 8)
                    })

    if not remaining_coords:
        print("⚠️ 沒有可儲存的交點座標（所有都被刪除）")
        return

    df_coords = pd.DataFrame(remaining_coords)
    df_coords_unique = df_coords.drop_duplicates(subset=["Lat", "Lon"])

    if os.path.exists(output_filename):
        # 若檔案存在，附加資料
        with pd.ExcelWriter(output_filename, mode='a', engine='openpyxl', if_sheet_exists='overlay') as writer:
            # 讀取現有資料
            existing_df = pd.read_excel(output_filename)
            # 合併並去重
            combined_df = pd.concat([existing_df, df_coords_unique], ignore_index=True)
            combined_df = combined_df.drop_duplicates(subset=["Lat", "Lon"])
            combined_df.to_excel(writer, index=False)
        print(f"✅ 已移除重複經緯度並儲存至 {output_filename}，共 {len(df_coords_unique)} 筆")
        print(f"📌 已附加並儲存至 {output_filename}，目前共 {len(combined_df)} 筆")
    else:
        # 檔案不存在，建立新檔
        df_coords_unique.to_excel(output_filename, index=False)
        print(f"✅ 建立新檔並儲存至 {output_filename}，共 {len(df_coords_unique)} 筆")

# import pandas as pd
# import numpy as np
# from shapely.geometry import LineString, Point
# from collections import defaultdict
# import matplotlib.pyplot as plt
# import plotly.graph_objects as go
# import numpy as np
# import plotly.express as px

# for grid_id in grid_info:
#   intersection_lobs = [
#       [float(a), float(b), float(c), float(d)]
#       for a, b, c, d in grid_id['intersection_lobs']
#   ]

#   # 分群根據起點
#   start_point_groups = defaultdict(list)
#   for lob in intersection_lobs:
#       start = (lob[0], lob[1])  # (lat, lon)
#       start_point_groups[start].append(lob)

#   # 標記 A1, A2, ..., B1, ...
#   labels = {}
#   label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
#   lob_list = []
#   label_index = 0
#   for group_start, lobs in sorted(start_point_groups.items()):
#       for i, lob in enumerate(lobs):
#           label = f"{label_prefix[label_index]}{i+1}"
#           labels[tuple(lob)] = label
#           lob_list.append((lob, label))
#       label_index += 1

#   # 初始化 matrix 和交點記錄 dict
#   n = len(lob_list)
#   matrix = [['-' for _ in range(n)] for _ in range(n)]
#   label_list = [label for _, label in lob_list]
#   intersection_points_dict = {}

#   # 比對交點
#   for i in range(n):
#       for j in range(n):
#           if i == j:
#               matrix[i][j] = '—'
#               continue

#           lob1, label1 = lob_list[i]
#           lob2, label2 = lob_list[j]
#           line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])  # (lon, lat)
#           line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

#           if line1.intersects(line2):
#               intersection = line1.intersection(line2)
#               if intersection.geom_type == 'Point':
#                   matrix[i][j] = f"P({label1}x{label2})"
#                   intersection_points_dict[(label1, label2)] = (intersection.y, intersection.x)  # lat, lon
#                   intersection_points_dict[(label2, label1)] = (intersection.y, intersection.x)

#   # 顯示矩陣
#   df_matrix = pd.DataFrame(matrix, columns=label_list, index=label_list)
#   display(df_matrix)

#   # # DBSCAN 聚類（eps = 2.5 公尺，min_samples=1 表示自己也能成一群）
#   # distance_matrix = haversine_distance_matrix(coords)
#   # db = DBSCAN(eps=2.5, min_samples=1, metric='precomputed')
#   # labels = db.fit_predict(distance_matrix)

#   # # 為每個 cluster 計算 centroid
#   # cluster_points = defaultdict(list)
#   # for i, label in enumerate(labels):
#   #     cluster_points[label].append(coords[i])

#   # cluster_centroids = {
#   #     label: np.mean(np.array(pts), axis=0)  # 平均 lat/lon
#   #     for label, pts in cluster_points.items()
#   # }

#   # # 將所有交點更新為 centroid
#   # label_keys = list(intersection_points_dict.keys())
#   # for i, key in enumerate(label_keys):
#   #     cluster_id = labels[i]
#   #     centroid = cluster_centroids[cluster_id]
#   #     intersection_points_dict[key] = tuple(centroid)

#   # fig = go.Figure()

#   coords = []
#   label_pair_list = []

#   for key, point in intersection_points_dict.items():
#       coords.append(point)
#       label_pair_list.append(key)

#   distance_matrix = haversine_distance_matrix(coords)
#   db = DBSCAN(eps=2.5, min_samples=1, metric='precomputed')
#   labels = db.fit_predict(distance_matrix)

#   # 建立 label_pair 對應 cluster_id 的 dict
#   intersection_to_cluster = {
#       label_pair_list[i]: labels[i]
#       for i in range(len(labels))
#   }

#   cluster_points = defaultdict(list)
#   for i, label in enumerate(labels):
#       cluster_points[label].append(coords[i])

#   cluster_centroids = {
#       label: np.mean(np.array(pts), axis=0)  # (lat, lon)
#       for label, pts in cluster_points.items()
#   }

#   for key in intersection_points_dict.keys():
#       cluster_id = intersection_to_cluster[key]
#       centroid = cluster_centroids[cluster_id]
#       intersection_points_dict[key] = tuple(centroid)

#   # 取得指定 grid_info
#   first_grid_info = grid_id

#   # 畫出 grid_calculation（藍色）
#   grid_calculation = first_grid_info["calculation"]
#   lat_values = [pt[1] for pt in grid_calculation]
#   lon_values = [pt[0] for pt in grid_calculation]
#   fig.add_trace(go.Scattermapbox(
#       lat=lat_values + [lat_values[0]],
#       lon=lon_values + [lon_values[0]],
#       mode='lines',
#       line=dict(width=2, color='blue'),
#       name='Grid Calculation'
#   ))

#   # 畫出 grid_recorded（紅色）
#   grid_recorded = first_grid_info["recorded"]["grid"]
#   lat_values = [pt[1] for pt in grid_recorded]
#   lon_values = [pt[0] for pt in grid_recorded]
#   fig.add_trace(go.Scattermapbox(
#       lat=lat_values + [lat_values[0]],
#       lon=lon_values + [lon_values[0]],
#       mode='lines',
#       line=dict(width=2, color='red'),
#       name='Grid Recorded'
#   ))

#   # 📌 顯示 intersection points，根據 cluster 上色
#   unique_cluster_ids = set(labels)
#   color_scale = px.colors.qualitative.Alphabet  # 或 Set3、Plotly 等配色方案

#   for cluster_id in unique_cluster_ids:
#       # 所有屬於這個 cluster 的交點索引
#       indices = np.where(labels == cluster_id)[0]
#       cluster_color = color_scale[cluster_id % len(color_scale)]

#       # 提取交點並加到圖上
#       for idx in indices:
#           label_pair = list(intersection_points_dict.keys())[idx]
#           point = intersection_points_dict[label_pair]
#           fig.add_trace(go.Scattermapbox(
#               lat=[point[0]],
#               lon=[point[1]],
#               mode='markers+text',
#               marker=dict(size=10, color=cluster_color),
#               text=[f"Cluster {cluster_id}"],
#               textposition="top right",
#               name=f"Intersection Cluster {cluster_id}",
#               showlegend=False
#           ))

#   # 計算地圖中心
#   all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
#   all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

#   fig.update_layout(
#       mapbox=dict(
#           style='open-street-map',
#           zoom=15,
#           center=dict(
#               lat=np.mean(all_lats),
#               lon=np.mean(all_lons)
#           )
#       ),
#       height=800,
#       margin=dict(l=0, r=0, t=0, b=0),
#       showlegend=True,
#       legend=dict(
#           yanchor="top",
#           y=0.99,
#           xanchor="left",
#           x=0.01,
#           bgcolor='rgba(255,255,255,0.8)'
#       )
#   )

#   fig.show()

#   start_col = 0
#   df_simplified = simplify_matrix(df_matrix, intersection_to_cluster, cluster_colors)
#   styled_df_simplified = style_simplified_df(df_simplified, intersection_to_cluster, cluster_colors)
#   # styled_df_simplified

#   df_filtered = filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster)
#   styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
#   # styled_filtered


#   df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=0)
#   styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)
#   # styled_filtered

#   while(next_col_idx!=df_filtered.shape[1]):
#       print(next_col_idx)
#       df_filtered = filter_lonely_row_column_intersections(df_filtered, intersection_to_cluster)
#       styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)

#       df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, start_col_idx=next_col_idx)
#       styled_filtered = style_simplified_df(df_filtered, intersection_to_cluster, cluster_colors)

#   styled_filtered
#   save_remaining_coordinates(df_filtered, intersection_points_dict)

import pandas as pd
import numpy as np
from shapely.geometry import LineString
from collections import defaultdict
import plotly.graph_objects as go
import plotly.express as px
from sklearn.cluster import DBSCAN

for grid_id in grid_info:
    intersection_lobs = [
        [float(a), float(b), float(c), float(d)]
        for a, b, c, d in grid_id['intersection_lobs']
    ]

    # Group LOBs by start point
    start_point_groups = defaultdict(list)
    for lob in intersection_lobs:
        start = (lob[0], lob[1])
        start_point_groups[start].append(lob)

    labels = {}
    label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    lob_list = []
    label_index = 0
    for _, lobs in sorted(start_point_groups.items()):
        for i, lob in enumerate(lobs):
            label = f"{label_prefix[label_index]}{i+1}"
            labels[tuple(lob)] = label
            lob_list.append((lob, label))
        label_index += 1

    n = len(lob_list)
    matrix = [['-' for _ in range(n)] for _ in range(n)]
    label_list = [label for _, label in lob_list]
    intersection_points_dict = {}

    for i in range(n):
        for j in range(n):
            if i == j:
                matrix[i][j] = '—'
                continue
            lob1, label1 = lob_list[i]
            lob2, label2 = lob_list[j]
            line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])
            line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])
            if line1.intersects(line2):
                inter = line1.intersection(line2)
                if inter.geom_type == 'Point':
                    matrix[i][j] = f"P({label1}x{label2})"
                    intersection_points_dict[(label1, label2)] = (inter.y, inter.x)
                    intersection_points_dict[(label2, label1)] = (inter.y, inter.x)

    if intersection_points_dict:
        coords = list(intersection_points_dict.values())
        label_pair_list = list(intersection_points_dict.keys())

        distance_matrix = haversine_distance_matrix(coords)
        db = DBSCAN(eps=2, min_samples=1, metric="precomputed")
        cluster_labels = db.fit_predict(distance_matrix)

        # ... (Rest of the code for clustering, centroid calculation, etc.)

    else:
        print(f"No intersection points found in grid ID: {grid_id}")
        # Handle the case where there are no intersections, e.g., skip processing or assign a default value
        continue  # Skip to the next grid_id

    intersection_to_cluster = {
        label_pair_list[i]: cluster_labels[i]
        for i in range(len(cluster_labels))
    }

    cluster_points = defaultdict(list)
    for i, cluster_id in enumerate(cluster_labels):
        cluster_points[cluster_id].append(coords[i])

    cluster_centroids = {
        cid: np.mean(np.array(pts), axis=0)
        for cid, pts in cluster_points.items()
    }

    for key in intersection_points_dict:
        cid = intersection_to_cluster[key]
        intersection_points_dict[key] = tuple(cluster_centroids[cid])

    fig = go.Figure()

    for key in ['calculation', 'recorded']:
        grid = grid_id[key]['grid'] if key == 'recorded' else grid_id[key]
        lats = [pt[1] for pt in grid] + [grid[0][1]]
        lons = [pt[0] for pt in grid] + [grid[0][0]]
        fig.add_trace(go.Scattermapbox(
            lat=lats, lon=lons, mode='lines',
            line=dict(width=2, color='blue' if key == 'calculation' else 'red'),
            name=f"Grid {key.title()}"
        ))

    unique_clusters = set(cluster_labels)
    color_scale = px.colors.qualitative.Alphabet

    for cid in unique_clusters:
        idxs = np.where(cluster_labels == cid)[0]
        color = color_scale[cid % len(color_scale)]
        for i in idxs:
            pt = cluster_centroids[cid]
            # fig.add_trace(go.Scattermapbox(
            #     lat=[pt[0]], lon=[pt[1]], mode='markers+text',
            #     marker=dict(size=10, color=color),
            #     text=[f"Cluster {cid}"],
            #     textposition="top right", showlegend=False
            # ))

    all_lats = [pt[1] for pt in grid_id['recorded']['grid'] + grid_id['calculation']]
    all_lons = [pt[0] for pt in grid_id['recorded']['grid'] + grid_id['calculation']]

    # fig.update_layout(
    #     mapbox=dict(style='open-street-map', zoom=15,
    #                 center=dict(lat=np.mean(all_lats), lon=np.mean(all_lons))),
    #     height=800, margin=dict(l=0, r=0, t=0, b=0), showlegend=True
    # )

    # fig.show()

    df_simplified = simplify_matrix(df_matrix, intersection_to_cluster, cluster_colors)
    df_filtered = filter_lonely_row_column_intersections(df_simplified, intersection_to_cluster)
    df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, 0)

    while next_col_idx != df_filtered.shape[1]:
        df_filtered = filter_lonely_row_column_intersections(df_filtered, intersection_to_cluster)
        df_filtered, next_col_idx = filter_columns_with_multiple_clusters_stepwise(df_filtered, intersection_to_cluster, next_col_idx)

    save_remaining_coordinates(df_filtered, intersection_points_dict)