# -*- coding: utf-8 -*-
"""Grid_Division.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kUdY5RXUfLJYgWUuLh1rJhisgDaitZTd
"""

!pip install streetlevel

import pandas as pd
# read ROI route points (locations to download street view images)

workingdirectory = '/content/'

LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv")
# LumbertonRoutesPoints = pd.read_csv(workingdirectory + "PanoInfoFinal.csv",converters={'panoid':str})
# RouteIDs = LumbertonRoutesPoints['RTE_NM'].unique() # unique route ID
LumbertonRoutesPoints = LumbertonRoutesPoints.drop_duplicates()
LumbertonRoutesPoints.info()

# prepare required functions
import math

def decode_polyline(polyline_str):
    '''Pass a Google Maps encoded polyline string; returns list of lat/lon pairs'''
    index, lat, lng = 0, 0, 0
    coordinates = []
    changes = {'latitude': 0, 'longitude': 0}

    # Coordinates have variable length when encoded, so just keep
    # track of whether we've hit the end of the string. In each
    # while loop iteration, a single coordinate is decoded.
    while index < len(polyline_str):
        # Gather lat/lon changes, store them in a dictionary to apply them later
        for unit in ['latitude', 'longitude']:
            shift, result = 0, 0
            while True:
                byte = ord(polyline_str[index]) - 63
                index += 1
                result |= (byte & 0x1f) << shift
                shift += 5
                if not byte >= 0x20:
                    break
            if (result & 1):
                changes[unit] = ~(result >> 1)
            else:
                changes[unit] = (result >> 1)
        lat += changes['latitude']
        lng += changes['longitude']
        coordinates.append((lat / 100000.0, lng / 100000.0))
    return coordinates

def getpathpoints(dirs,pts_distance=50):
  # polypath = dirs[0]['legs'][0]['steps'][0]['polyline']['points']
  polypath = dirs[0]['overview_polyline']['points']
  polypath_pts = decode_polyline(polypath)
  pts_coords = []
  for pt in range(1, len(polypath_pts)):
    lat1 = polypath_pts[pt-1][0]
    lng1 = polypath_pts[pt-1][1]
    lat2 = polypath_pts[pt][0]
    lng2 = polypath_pts[pt][1]
    azimuth = calculateBearing(lat1,lng1,lat2,lng2)
    coords = getInnerPoints(pts_distance,azimuth,lat1,lng1,lat2,lng2)
    if pt==1:
      pts_coords.append(coords)
    else:
      pts_coords.append(coords[1:])
  flatten_pts_coords = []
  for subl in pts_coords:
      for item in subl:
          flatten_pts_coords.append(item)
  return flatten_pts_coords

def getPathLength(lat1,lng1,lat2,lng2):
    '''calculates the distance between two lat, long coordinate pairs'''
    R = 6371000 # radius of earth in m
    lat1rads = math.radians(lat1)
    lat2rads = math.radians(lat2)
    deltaLat = math.radians((lat2-lat1))
    deltaLng = math.radians((lng2-lng1))
    a = math.sin(deltaLat/2) * math.sin(deltaLat/2) + math.cos(lat1rads) * math.cos(lat2rads) * math.sin(deltaLng/2) * math.sin(deltaLng/2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = R * c
    return d

def getDestinationLatLong(lat,lng,azimuth,distance):
    '''returns the lat an long of destination point
    given the start lat, long, aziuth, and distance'''
    R = 6378.1 #Radius of the Earth in km
    brng = math.radians(azimuth) #Bearing is degrees converted to radians.
    d = distance/1000 #Distance m converted to km
    lat1 = math.radians(lat) #Current dd lat point converted to radians
    lon1 = math.radians(lng) #Current dd long point converted to radians
    lat2 = math.asin(math.sin(lat1) * math.cos(d/R) + math.cos(lat1)* math.sin(d/R)* math.cos(brng))
    lon2 = lon1 + math.atan2(math.sin(brng) * math.sin(d/R)* math.cos(lat1), math.cos(d/R)- math.sin(lat1)* math.sin(lat2))
    #convert back to degrees
    lat2 = math.degrees(lat2)
    lon2 = math.degrees(lon2)
    return[lat2, lon2]

def calculateBearing(lat1,lng1,lat2,lng2):
    '''calculates the azimuth in degrees from start point to end point'''
    startLat = math.radians(lat1)
    startLong = math.radians(lng1)
    endLat = math.radians(lat2)
    endLong = math.radians(lng2)
    dLong = endLong - startLong
    dPhi = math.log(math.tan(endLat/2.0+math.pi/4.0)/math.tan(startLat/2.0+math.pi/4.0))
    if abs(dLong) > math.pi:
         if dLong > 0.0:
             dLong = -(2.0 * math.pi - dLong)
         else:
             dLong = (2.0 * math.pi + dLong)
    bearing = (math.degrees(math.atan2(dLong, dPhi)) + 360.0) % 360.0;
    return bearing

def getInnerPoints(interval,azimuth,lat1,lng1,lat2,lng2):
    '''returns every coordinate pair inbetween two coordinate
    pairs given the desired interval'''

    d = getPathLength(lat1,lng1,lat2,lng2)
    remainder, dist = math.modf((d / interval))
    counter = float(interval)
    coords = []
    coords.append([lat1,lng1])
    for distance in range(0,int(dist)):
        coord = getDestinationLatLong(lat1,lng1,azimuth,counter)
        counter = counter + float(interval)
        coords.append(coord)
    coords.append([lat2,lng2])
    return coords

def samepoint(line1, line2):
  result = False
  for x in line1:
    for y in line2:
      if x == y:
        result = True
        return x
        break
  return result

def find_intersection(p0, p1, p2, p3):
    # line1 = [p0.tolist(),p1.tolist()]
    # line2 = [p2.tolist(),p3.tolist()]
    line1 = [p0,p1]
    line2 = [p2,p3]
    samept = samepoint(line1,line2)
    if samept is not False:
      intersection_point = samept
    else:
      s10_x = p1[0] - p0[0]
      s10_y = p1[1] - p0[1]
      s32_x = p3[0] - p2[0]
      s32_y = p3[1] - p2[1]
      denom = s10_x * s32_y - s32_x * s10_y
      if denom == 0 : return math.nan # collinear
      denom_is_positive = denom > 0
      s02_x = p0[0] - p2[0]
      s02_y = p0[1] - p2[1]
      s_numer = s10_x * s02_y - s10_y * s02_x
      if (s_numer < 0) == denom_is_positive : return math.nan # no collision
      t_numer = s32_x * s02_y - s32_y * s02_x
      if (t_numer < 0) == denom_is_positive : return math.nan # no collision
      if (s_numer > denom) == denom_is_positive or (t_numer > denom) == denom_is_positive : return math.nan # no collision
      # collision detected
      t = t_numer / denom
      intersection_point = [ p0[0] + (t * s10_x), p0[1] + (t * s10_y) ]
    return intersection_point

import numpy as np
import math

def calculate_baseline_length(trajectory_points):
    """
    è®¡ç®—è½¨è¿¹åŸºçº¿é•¿åº¦

    Args:
        trajectory_points: è½¨è¿¹ç‚¹åˆ—è¡¨ [[lat, lon],...]

    Returns:
        baseline: åŸºçº¿é•¿åº¦(ç±³)
    """
    total_length = 0
    for i in range(len(trajectory_points)-1):
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[i+1]
        # ä½¿ç”¨å·²æœ‰çš„getPathLengthå‡½æ•°è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
        length = getPathLength(pt1[0], pt1[1], pt2[0], pt2[1])
        total_length += length

    # è¿”å›å¹³å‡æ®µé•¿ä½œä¸ºåŸºçº¿é•¿åº¦
    return total_length / (len(trajectory_points)-1)

from geopy.distance import geodesic

def calculate_mst_baseline(trajectory_points, MST):
    """
    è®¡ç®— MST çš„åŸºçº¿é•¿åº¦

    Args:
        trajectory_points: è½¨è¿¹ç‚¹åˆ—è¡¨ [[lat, lon],...]
        MST: NetworkX è®¡ç®—å‡ºçš„æœ€å°ç”Ÿæˆæ ‘ (Minimum Spanning Tree)

    Returns:
        baseline: åŸºçº¿é•¿åº¦(ç±³)
    """
    total_length = 0
    edge_count = 0

    for i, j in MST.edges():
        pt1 = trajectory_points[i]
        pt2 = trajectory_points[j]
        length = geodesic(pt1, pt2).meters  # è¨ˆç®—åœ°ç†è·é›¢
        total_length += length
        edge_count += 1
        print(i,j, trajectory_points[i], trajectory_points[j])

    # è¿”å›å¹³å‡é‚Šé•·ä½œç‚ºåŸºç·š
    return total_length / edge_count if edge_count > 0 else 0


def create_grid_cells(trajectory_points, effective_distance):
    """
    åŸºäºè½¨è¿¹ç‚¹åˆ’åˆ†è‡ªé€‚åº”ç½‘æ ¼

    Args:
        trajectory_points: è½¨è¿¹ç‚¹åˆ—è¡¨ [[lat, lon], ...]
        effective_distance: å½±å“èŒƒå›´ï¼ˆç”¨äºè®¡ç®—ç½‘æ ¼å¤§å°ï¼‰

    Returns:
        grid_cells: è‡ªé€‚åº”ç½‘æ ¼åˆ’åˆ†çš„ç»“æœï¼Œæ¯ä¸ªå•å…ƒæ˜¯ [[lat1, lon1], [lat2, lon2], ...]
    """

    bl = calculate_baseline_length(trajectory_points)
    grid_cells = []
    # è®¡ç®—è½¨è¿¹çš„è¾¹ç•ŒèŒƒå›´
    min_lon = min(pt[1] for pt in trajectory_points)  # ç»åº¦
    max_lon = max(pt[1] for pt in trajectory_points)
    min_lat = min(pt[0] for pt in trajectory_points)  # çº¬åº¦
    max_lat = max(pt[0] for pt in trajectory_points)
    lat_start = min_lat
    lon_start = min_lon
    lat_end = max_lat
    lon_end = max_lon
    grid = [
        [lat_start, lon_start],
        [lat_end, lon_start],
        [lat_end, lon_end],
        [lat_start, lon_end]
        ]
    grid_cells.append(grid)
    print(grid_cells)
    return grid_cells

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory_and_grid(trajectory_points, grid_cells):
    """
    è¦–è¦ºåŒ–è¡Œé§›è»Œè·¡é»èˆ‡ä¸åŒé¡è‰²çš„è‡ªé©æ‡‰ç¶²æ ¼

    Args:
        trajectory_points: è¡Œé§›è»Œè·¡é» (list of [lat, lon])
        grid_cells:  è‡ªé€‚åº”ç½‘æ ¼åˆ’åˆ†çš„ç»“æœï¼Œæ¯ä¸ªå•å…ƒæ˜¯ [[lat1, lon1], [lat2, lon2], ...]
    """
    # å‰µå»ºåœ°åœ–
    fig = go.Figure()

    # 1ï¸âƒ£ æ·»åŠ è¡Œé§›è»Œè·¡é» (è—è‰²ç·šæ¢)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        # mode='lines+markers',
        name='Trajectory',
        # line=dict(width=2, color='blue'),
        marker=dict(size=5, color='blue')
    ))

    # 2ï¸âƒ£ ç”Ÿæˆä¸åŒé¡è‰²çš„ç¶²æ ¼
    colors = ['red', 'green', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'lime', 'teal', 'orange']

    for i, cell in enumerate(grid_cells):
        cell.append(cell[0])  # é—­åˆå¤šè¾¹å½¢
        grid_color = random.choice(colors)  # éš¨æ©Ÿé¸æ“‡é¡è‰²
        fig.add_trace(go.Scattermapbox(
            lat=[pt[0] for pt in cell],
            lon=[pt[1] for pt in cell],
            mode='lines',
            line=dict(width=2, color=grid_color),
            name=f'Grid {i+1}'
        ))

    # 3ï¸âƒ£ æ›´æ–°åœ°åœ–å¸ƒå±€
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

import os
import pandas as pd
import plotly.graph_objects as go
import random

def plot_trajectory(trajectory_points):
    """
    è¦–è¦ºåŒ–è¡Œé§›è»Œè·¡é»èˆ‡ä¸åŒé¡è‰²çš„è‡ªé©æ‡‰ç¶²æ ¼

    Args:
        trajectory_points: è¡Œé§›è»Œè·¡é» (list of [lat, lon])
        grid_cells:  è‡ªé€‚åº”ç½‘æ ¼åˆ’åˆ†çš„ç»“æœï¼Œæ¯ä¸ªå•å…ƒæ˜¯ [[lat1, lon1], [lat2, lon2], ...]
    """
    # å‰µå»ºåœ°åœ–
    fig = go.Figure()

    # 1ï¸âƒ£ æ·»åŠ è¡Œé§›è»Œè·¡é» (è—è‰²ç·šæ¢)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        mode='markers',
        name='Trajectory',
        marker=dict(size=5, color='blue')
    ))


    # 3ï¸âƒ£ æ›´æ–°åœ°åœ–å¸ƒå±€
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

import numpy as np
import pandas as pd
from streetlevel import streetview

# å‚æ•°è®¾ç½®
dist_para = [40*304.8, 1.5, 4.55, 10]
size = (640, 640)
EFFECTIVE_DISTANCE = 50  # æœ‰æ•ˆé‡‡é›†è·ç¦»(ç±³)

# æ–‡ä»¶è·¯å¾„
path1 = workingdirectory + 'StreetViewImages/'
path2 = workingdirectory + 'resized/'
savepreddir = workingdirectory + 'PolePredictionResults/'

totaldownload = 0

for rr in range(0,len(RouteIDs)):
    routeid = RouteIDs[rr]
    routepoints = LumbertonRoutesPoints.loc[LumbertonRoutesPoints['RTE_NM'] == routeid]
    Pts2downloadPano = routepoints[['Lat','Lon']].values.tolist()

    # è·å–è¡—æ™¯å…¨æ™¯ä¿¡æ¯
    allpanoid = []
    for panoLatLon in Pts2downloadPano:
        pano = streetview.find_panorama(lat=panoLatLon[0], lon=panoLatLon[1])
        if bool(pano):
            allpanoid.append([pano.id, pano.lat, pano.lon])
    PanoInfoFinal = pd.DataFrame(allpanoid,columns=['panoid','lat','lon']).drop_duplicates()
    print(PanoInfoFinal)

    # åªå¤„ç†è¶…è¿‡3ä¸ªå…¨æ™¯ç‚¹çš„è·¯æ®µ
    if len(PanoInfoFinal) > 3:
        poleview = []  # è·¯å¾„ä¸Šçš„ç»“æœ [ç›¸æœºåæ ‡, æ†ä½“æ–¹ä½è§’]
        poleLOB = []   # å»ºè®®çš„LOB [èµ·ç‚¹åæ ‡(ç›¸æœº), ç»ˆç‚¹åæ ‡]

        # è‡ªé€‚åº”ç½‘æ ¼åˆ’åˆ†
        trajectory_points = PanoInfoFinal[['lat','lon']].values.tolist()
        grid_cells = create_grid_cells(trajectory_points, EFFECTIVE_DISTANCE)
        fig = plot_trajectory_and_grid(trajectory_points, grid_cells)
        fig.show()

"""# **Create outer grid and do grid division(divide outer large grid into several small grid)**"""

import numpy as np
import pandas as pd
from streetlevel import streetview

# å‚æ•°è®¾ç½®
dist_para = [40*304.8, 1.5, 4.55, 10]
size = (640, 640)
EFFECTIVE_DISTANCE = 50  # æœ‰æ•ˆé‡‡é›†è·ç¦»(ç±³)

# æ–‡ä»¶è·¯å¾„
path1 = workingdirectory + 'StreetViewImages/'
path2 = workingdirectory + 'resized/'
savepreddir = workingdirectory + 'PolePredictionResults/'

totaldownload = 0
trajectory_points = LumbertonRoutesPoints[['Lat','Lon']].values.tolist()
print(len(trajectory_points))
grid_cells = create_grid_cells(trajectory_points,EFFECTIVE_DISTANCE)

fig = plot_trajectory_and_grid(trajectory_points, grid_cells)
fig.show()

"""***- use MST to link the trajectory point and stored them in edge_x and edge_y in increasing order of length(m).***"""

import numpy as np
import networkx as nx
from geopy.distance import geodesic
import plotly.graph_objects as go

print(len(trajectory_points))
# è¨ˆç®—åœ°ç†è·é›¢çš„è·é›¢çŸ©é™£
n = len(trajectory_points)
dist_matrix = np.zeros((n, n))
for i in range(n):
    for j in range(i + 1, n):
        dist = geodesic(trajectory_points[i], trajectory_points[j]).meters  # è¨ˆç®—å…©é»ä¹‹é–“çš„è·é›¢ï¼ˆä»¥ç±³ç‚ºå–®ä½ï¼‰
        dist_matrix[i, j] = dist_matrix[j, i] = dist

# å»ºç«‹åœ–ï¼ˆæ‰€æœ‰é»ç›¸é€£ï¼Œæ¬Šé‡ç‚ºåœ°ç†è·é›¢ï¼‰
G = nx.Graph()
for i in range(n):
    for j in range(i + 1, n):
        G.add_edge(i, j, weight=dist_matrix[i, j])

# è¨ˆç®— MSTï¼ˆæœ€å°ç”Ÿæˆæ¨¹ï¼‰
MST = nx.minimum_spanning_tree(G, algorithm='prim')

# å–å‡º MST é€£ç·šçš„é»
lats, lons = zip(*trajectory_points)  # æ‹†åˆ†ç·¯åº¦å’Œç¶“åº¦
edges_x = []
edges_y = []

# é€£ç·šçš„ x, y åº§æ¨™
for edge in MST.edges():
    i, j = edge
    edges_x.append([lons[i], lons[j]])
    edges_y.append([lats[i], lats[j]])

# ç•«åœ–
# fig = go.Figure()

# # ç•«å‡ºé›»ç·šæ†åº§æ¨™
# fig.add_trace(go.Scattermapbox(
#     lat=lats,
#     lon=lons,
#     mode='markers',
#     name='Electric Poles',
#     marker=dict(
#         size=7,
#         color='red',
#         opacity=0.8
#     )
# ))

# # ç•«å‡º MST é€£ç·š
# for x, y in zip(edges_x, edges_y):
#     fig.add_trace(go.Scattermapbox(
#         lat=y,
#         lon=x,
#         mode='lines',
#         line=dict(width=2, color='blue'),
#         name='MST Connections'
#     ))

# # æ›´æ–°å¸ƒå±€
# fig.update_layout(
#     mapbox=dict(
#         style='carto-positron',
#         zoom=15,
#         center=dict(
#             lat=np.mean(lats),
#             lon=np.mean(lons)
#         )
#     ),
#     height=800,
#     margin=dict(l=0, r=0, t=0, b=0),
#     showlegend=True,
#     legend=dict(
#         yanchor="top",
#         y=0.99,
#         xanchor="left",
#         x=0.01,
#         bgcolor='rgba(255,255,255,0.8)'
#     )
# )

# # é¡¯ç¤ºåœ–
# fig.show()

# è¨ˆç®—åŸºç·šé•·åº¦
baseline_length = calculate_mst_baseline(trajectory_points, MST)
print("MST Baseline Length:", baseline_length, "meters")

"""***- calculate k, dist_y, dist_x, nrow and ncol.***"""

grid_cells_flatten = grid_cells[0]
print(grid_cells_flatten)
#å·¦ä¸‹ï¼Œå·¦ä¸Šï¼Œå³ä¸Šï¼Œå³ä¸‹
k = (1+(50/(2*math.sqrt(2)*baseline_length)))/2
print(50/(2*math.sqrt(2)*baseline_length))
print(k)
dist_y = geodesic(grid_cells_flatten[1],grid_cells_flatten[0]).meters
dist_x = geodesic(grid_cells_flatten[2],grid_cells_flatten[1]).meters
print("å‚ç›´è·é›¢ï¼š",dist_y, "\næ°´å¹³è·é›¢ï¼š",dist_x)
nrow = math.ceil(dist_y/(k*baseline_length))
ncol = math.ceil(dist_x/(k*baseline_length))
print("nrow: ",nrow, "\nncol: ",ncol)

import numpy as np
from geopy.distance import geodesic

# è·å–å››ä¸ªè§’ç‚¹
p1, p2, p3, p4 = grid_cells_flatten[:4]

# è®¡ç®—æ­¥é•¿
step_y = dist_y / nrow
step_x = dist_x / ncol

# ç”Ÿæˆç½‘æ ¼ç‚¹
lat_values = np.linspace(p1[0], p2[0], nrow + 1)  # çºµå‘åˆ‡åˆ†ç‚¹
lon_values = np.linspace(p1[1], p3[1], ncol + 1)  # æ¨ªå‘åˆ‡åˆ†ç‚¹

# å­˜å‚¨æ‰€æœ‰ grid cells
each_grid_cells = []

# è¿­ä»£ç”Ÿæˆæ‰€æœ‰å°ç½‘æ ¼
for i in range(nrow):
    for j in range(ncol):
        lat1, lat2 = lat_values[i], lat_values[i + 1]
        lon1, lon2 = lon_values[j], lon_values[j + 1]

        # æ„é€ ä¸€ä¸ª grid cell
        grid_cell = [
            [lat1, lon1],  # å·¦ä¸‹è§’
            [lat2, lon1],  # å·¦ä¸Šè§’
            [lat2, lon2],  # å³ä¸Šè§’
            [lat1, lon2],  # å³ä¸‹è§’
            [lat1, lon1]
        ]

        each_grid_cells.append(grid_cell)

# è¾“å‡ºç¤ºä¾‹
print(f"æ€»ç½‘æ ¼æ•°: {len(each_grid_cells)}")
print("ç¤ºä¾‹ç½‘æ ¼:", each_grid_cells)

"""# **Visualise the grid cell**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()


for grid_cell in grid_cells:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Outer Grid Cell'
    ))

for grid_cell in each_grid_cells[15500:16000]:
    lat_values = [pt[0] for pt in grid_cell]
    lon_values = [pt[1] for pt in grid_cell]
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='green'),
        name='Grid Cell'
    ))

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='carto-positron',
        zoom=15,
        center=dict(
            lat=np.mean([pt[0] for cell in each_grid_cells for pt in cell]),
            lon=np.mean([pt[1] for cell in each_grid_cells for pt in cell])
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# é¡¯ç¤ºåœ–
fig.show()

"""# **Create grid_info which contain the grid for record and also calculation.**"""

import numpy as np

# è¨ˆç®—æ¯å€‹ MST é»æ‰€å±¬çš„ grid(recorded)
min_lon = min(pt[1] for pt in trajectory_points)  # ç»åº¦
max_lon = max(pt[1] for pt in trajectory_points)
min_lat = min(pt[0] for pt in trajectory_points)  # çº¬åº¦
max_lat = max(pt[0] for pt in trajectory_points)
bl=baseline_length

# è¨˜éŒ„æ¯å€‹ MST é»å°æ‡‰çš„ grid(recorded) åŠå…¶å‘¨åœçš„ grid(calculation)
grid_info = []

# è½‰æ›æ¯”ä¾‹
def meters_to_lat(meters):
    return meters / 110540  # 1åº¦ç·¯åº¦ç´„110540ç±³

def meters_to_lon(meters, lat):
    return meters / (111320 * np.cos(np.radians(lat)))  # 1åº¦ç¶“åº¦ç´„111320ç±³ * cos(ç·¯åº¦)

for lat, lon in zip(lats, lons):
    delta_lat = meters_to_lat(k * bl)
    delta_lon = meters_to_lon(k * bl, lat)

    col = int((lon - min_lon) / delta_lon)
    row = int((lat - min_lat) / delta_lat)

    grid_recorded = {
        "row": row,
        "col": col,
        "grid": [
            [min_lon + col * delta_lon, min_lat + row * delta_lat],  # å·¦ä¸‹
            [min_lon + (col + 1) * delta_lon, min_lat + row * delta_lat],  # å³ä¸‹
            [min_lon + (col + 1) * delta_lon, min_lat + (row + 1) * delta_lat],  # å³ä¸Š
            [min_lon + col * delta_lon, min_lat + (row + 1) * delta_lat],  # å·¦ä¸Š
            [min_lon + col * delta_lon, min_lat + row * delta_lat]  # å›åˆ°å·¦ä¸‹
        ]
    }

    # è¨ˆç®— grid(calculation) ç¯„åœ (åŒ…å«å‘¨åœ8å€‹ grid)
    grid_calculation = [
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat],  # å·¦ä¸‹
        [min_lon + (col + 2) * delta_lon, min_lat + (row - 1) * delta_lat],  # å³ä¸‹
        [min_lon + (col + 2) * delta_lon, min_lat + (row + 2) * delta_lat],  # å³ä¸Š
        [min_lon + (col - 1) * delta_lon, min_lat + (row + 2) * delta_lat],  # å·¦ä¸Š
        [min_lon + (col - 1) * delta_lon, min_lat + (row - 1) * delta_lat]  # å›åˆ°å·¦ä¸‹
    ]

    grid_info.append({
        "recorded": grid_recorded,
        "calculation": grid_calculation
    })


# é€™æ¨£æ¯å€‹ MST é»éƒ½æœƒå°æ‡‰ä¸€å€‹ grid(recorded) åŠå…¶å‘¨åœ 9 å€‹ grid(calculation)

"""# **Visualise grid for record and also calculation**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# å–å¾—ç¬¬ä¸€å€‹ grid_calculation å’Œ grid_recorded
first_grid_info = grid_info[50]

# ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]  # ç·¯åº¦
lon_values = [pt[0] for pt in grid_calculation]  # ç¶“åº¦
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]  # ç·¯åº¦
lon_values = [pt[0] for pt in grid_recorded]  # ç¶“åº¦
fig.add_trace(go.Scattermapbox(
    lat=lat_values,
    lon=lon_values,
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# è¨ˆç®—åœ°åœ–ä¸­å¿ƒé»
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # ä½¿ç”¨å…è²»åœ°åœ–
        zoom=12,  # æ¸›å°‘ zoom é¿å…å¤ªé è¿‘
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# é¡¯ç¤ºåœ–
print(first_grid_info)
fig.show()

print(grid_info[0]['calculation'])

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# è¨˜éŒ„æ‰€æœ‰é»çš„ç¶“ç·¯åº¦ï¼Œä»¥ä¾¿è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = []
all_lons = []

# éæ­· grid_info[50:100]
for grid_data in grid_info[1150:1175]:
    # ç¹ªè£½ grid_calculationï¼ˆè—è‰²ï¼‰
    grid_calculation = grid_data["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]  # ç·¯åº¦
    lon_values = [pt[0] for pt in grid_calculation]  # ç¶“åº¦
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation'
    ))

    # ç¹ªè£½ grid_recordedï¼ˆç´…è‰²ï¼‰
    grid_recorded = grid_data["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]  # ç·¯åº¦
    lon_values = [pt[0] for pt in grid_recorded]  # ç¶“åº¦
    fig.add_trace(go.Scattermapbox(
        lat=lat_values,
        lon=lon_values,
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded'
    ))

    # ç´¯ç©æ‰€æœ‰é»çš„ç¶“ç·¯åº¦
    all_lats.extend([pt[1] for pt in grid_calculation + grid_recorded])
    all_lons.extend([pt[0] for pt in grid_calculation + grid_recorded])

# è¨­å®šåœ°åœ–ä¸­å¿ƒ
fig.update_layout(
    mapbox=dict(
        style='open-street-map',  # ä½¿ç”¨å…è²»åœ°åœ–
        zoom=12,  # é©ç•¶ç¸®æ”¾
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# é¡¯ç¤ºåœ–è¡¨
fig.show()

from google.colab import drive
drive.mount("/content/drive")

LOBS = pd.read_csv("/content/poleLOB_original.csv")
print(len(LOBS))
LOBS = LOBS.drop_duplicates(subset=["start_lat", "start_lon", "end_lat", "end_lon"])
# LOBS.to_csv("/content/poleLOB_drop_duplicates.csv")
print(len(LOBS))

"""# **Remove duplicate of LOBS and also categorize them in proper grid respectively.**"""

from shapely.geometry import Point, Polygon

for grid in grid_info:
    grid_polygon_coords = grid['calculation']
    polygon = Polygon(grid_polygon_coords)
    lobs_in_polygon = set()  # ä½¿ç”¨ set è‡ªå‹•å»é™¤é‡è¤‡

    for _, row in LOBS.iterrows():
        start_point = Point(row["start_lon"], row["start_lat"])
        end_point = Point(row["end_lon"], row["end_lat"])

        if polygon.contains(start_point) or polygon.contains(end_point):
            lob = (
                row["start_lat"], row["start_lon"],
                row["end_lat"], row["end_lon"]
            )
            lobs_in_polygon.add(lob)  # åŠ å…¥ setï¼Œè‡ªå‹•å»é™¤é‡è¤‡

    # å°‡ set è½‰ç‚º list å­˜å…¥ grid ä¸­
    grid['lobs_in_polygon'] = list(lobs_in_polygon)

print(len(grid_info[1151]['lobs_in_polygon']))
print(grid_info[1151]['lobs_in_polygon'])

"""# **Visualise the grid for calculation and LOBs inside the grid**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# å–å¾—æŒ‡å®š grid_info
first_grid_info = grid_info[1151]

# ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]
lon_values = [pt[0] for pt in grid_calculation]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],  # é–‰åˆå¤šé‚Šå½¢
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]
lon_values = [pt[0] for pt in grid_recorded]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# ç•«å‡º intersecting LOBsï¼ˆç¶ è‰²ï¼‰
for lob in first_grid_info["lobs_in_polygon"]:
    start_lat, start_lon, end_lat, end_lon = lob
    fig.add_trace(go.Scattermapbox(
        lat=[start_lat, end_lat],
        lon=[start_lon, end_lon],
        mode='lines+markers',
        line=dict(width=2, color='green'),
        marker=dict(size=6, color='green'),
        name='LOB in Grid',
        showlegend=False  # é¿å…é‡è¤‡åœ–ä¾‹
    ))

# è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

# é¡¯ç¤ºåœ–èˆ‡ç¢ºèªè³‡æ–™
print(first_grid_info)
fig.show()

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# è¨˜éŒ„æ‰€æœ‰ç¶“ç·¯åº¦ä»¥ä¾¿è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = []
all_lons = []

# å–å¾—å¤šå€‹ grid_info
for grid in grid_info[1150:1175]:
    # ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
    grid_calculation = grid["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]
    lon_values = [pt[0] for pt in grid_calculation]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation',
        showlegend=False
    ))

    # ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
    grid_recorded = grid["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]
    lon_values = [pt[0] for pt in grid_recorded]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded',
        showlegend=False
    ))

    # ç•«å‡º intersecting LOBsï¼ˆç¶ è‰²ï¼‰
    for lob in grid["lobs_in_polygon"]:
        start_lat, start_lon, end_lat, end_lon = lob
        fig.add_trace(go.Scattermapbox(
            lat=[start_lat, end_lat],
            lon=[start_lon, end_lon],
            mode='lines+markers',
            line=dict(width=2, color='green'),
            marker=dict(size=6, color='green'),
            name='LOB in Grid',
            showlegend=False
        ))

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

"""# **Append 2 tupple in grid_info(intersections and lobs_intersection)**
***- to find the intersection of LOBs in grid***
"""

from shapely.geometry import LineString

for grid in grid_info:
    grid_polygon_coords = grid['calculation']
    polygon = Polygon(grid_polygon_coords)

    lobs = grid.get('lobs_in_polygon', [])
    intersections = set()
    intersection_lobs = set()

    # å…©å…©é…å°æ‰¾äº¤é»
    for i in range(len(lobs)):
        for j in range(i + 1, len(lobs)):
            lob1 = lobs[i]
            lob2 = lobs[j]

            line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])  # (lon, lat)
            line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

            if line1.intersects(line2):
                intersection = line1.intersection(line2)

                # æª¢æŸ¥æ˜¯å¦ç‚ºé»ï¼Œä¸¦ä¸”è©²é»åœ¨ grid polygon è£¡
                if intersection.geom_type == 'Point' and polygon.contains(intersection):
                    intersections.add((intersection.y, intersection.x))  # å­˜ç‚º (lat, lon)
                    intersection_lobs.add(tuple(lob1))
                    intersection_lobs.add(tuple(lob2))

    # å­˜å› grid
    grid['intersections'] = [list(pt) for pt in intersections]
    grid['intersection_lobs'] = [list(lob) for lob in intersection_lobs]

print(len(grid_info[1155]['intersections']))
print(len(grid_info[1155]['intersection_lobs']))

"""# **Visualise the grid for calculation and intersectinon_LOBs inside the grid**"""

import plotly.graph_objects as go
import numpy as np

fig = go.Figure()

# è¨˜éŒ„æ‰€æœ‰ç¶“ç·¯åº¦ä»¥ä¾¿è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = []
all_lons = []

# å–å¾—å¤šå€‹ grid_info
for grid in grid_info[1151:1152]:
    # ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
    grid_calculation = grid["calculation"]
    lat_values = [pt[1] for pt in grid_calculation]
    lon_values = [pt[0] for pt in grid_calculation]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='blue'),
        name='Grid Calculation',
        showlegend=False
    ))

    # ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
    grid_recorded = grid["recorded"]["grid"]
    lat_values = [pt[1] for pt in grid_recorded]
    lon_values = [pt[0] for pt in grid_recorded]
    all_lats.extend(lat_values)
    all_lons.extend(lon_values)
    fig.add_trace(go.Scattermapbox(
        lat=lat_values + [lat_values[0]],
        lon=lon_values + [lon_values[0]],
        mode='lines',
        line=dict(width=2, color='red'),
        name='Grid Recorded',
        showlegend=False
    ))

    # ç•«å‡º intersecting LOBsï¼ˆç¶ è‰²ï¼‰
    for lob in grid["intersection_lobs"]:
        start_lat, start_lon, end_lat, end_lon = lob
        fig.add_trace(go.Scattermapbox(
            lat=[start_lat, end_lat],
            lon=[start_lon, end_lon],
            mode='lines+markers',
            line=dict(width=2, color='green'),
            marker=dict(size=6, color='green'),
            name='LOB in Grid',
            showlegend=False
        ))

# æ›´æ–°ä½ˆå±€
fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()

print(grid_info[1151]['intersection_lobs'])

"""# **Create Intersection Matrix**"""

import pandas as pd
import numpy as np
from shapely.geometry import LineString, Point
from collections import defaultdict
import matplotlib.pyplot as plt
intersection_points_dict = {}

intersection_lobs = [
    [float(a), float(b), float(c), float(d)]
    for a, b, c, d in grid_info[1155]['intersection_lobs']
]

start_point_groups = defaultdict(list)

for lob in intersection_lobs:
    start = (lob[0], lob[1])
    start_point_groups[start].append(lob)

labels = {}
label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
lob_list = []
label_index = 0

for group_start, lobs in sorted(start_point_groups.items()):
    for i, lob in enumerate(lobs):
        label = f"{label_prefix[label_index]}{i+1}"
        labels[tuple(lob)] = label
        lob_list.append((lob, label))
    label_index += 1

n = len(lob_list)
matrix = [['-' for _ in range(n)] for _ in range(n)]
label_list = [label for _, label in lob_list]

for i in range(n):
    for j in range(n):
        if i == j:
            matrix[i][j] = 'â€”'
            continue
        lob1, label1 = lob_list[i]
        lob2, label2 = lob_list[j]
        line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])
        line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

        if line1.intersects(line2):
            matrix[i][j] = f"P({label1}x{label2})"
            intersection_points_dict[(label1, label2)] = (intersection.y, intersection.x)

df_matrix = pd.DataFrame(matrix, columns=label_list, index=label_list)
display(df_matrix)

"""Save the intersection between each set of LOBS in a dictionaries"""

import pandas as pd
import numpy as np
from shapely.geometry import LineString, Point
from collections import defaultdict

# è™•ç† intersection_lobs
intersection_lobs = [
    [float(a), float(b), float(c), float(d)]
    for a, b, c, d in grid_info[1151]['intersection_lobs']
]

# åˆ†ç¾¤æ ¹æ“šèµ·é»
start_point_groups = defaultdict(list)
for lob in intersection_lobs:
    start = (lob[0], lob[1])  # (lat, lon)
    start_point_groups[start].append(lob)

# æ¨™è¨˜ A1, A2, ..., B1, ...
labels = {}
label_prefix = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
lob_list = []
label_index = 0
for group_start, lobs in sorted(start_point_groups.items()):
    for i, lob in enumerate(lobs):
        label = f"{label_prefix[label_index]}{i+1}"
        labels[tuple(lob)] = label
        lob_list.append((lob, label))
    label_index += 1

# åˆå§‹åŒ– matrix å’Œäº¤é»è¨˜éŒ„ dict
n = len(lob_list)
matrix = [['-' for _ in range(n)] for _ in range(n)]
label_list = [label for _, label in lob_list]
intersection_points_dict = {}

# æ¯”å°äº¤é»
for i in range(n):
    for j in range(n):
        if i == j:
            matrix[i][j] = 'â€”'
            continue

        lob1, label1 = lob_list[i]
        lob2, label2 = lob_list[j]
        line1 = LineString([(lob1[1], lob1[0]), (lob1[3], lob1[2])])  # (lon, lat)
        line2 = LineString([(lob2[1], lob2[0]), (lob2[3], lob2[2])])

        if line1.intersects(line2):
            intersection = line1.intersection(line2)
            if intersection.geom_type == 'Point':
                matrix[i][j] = f"P({label1}x{label2})"
                intersection_points_dict[(label1, label2)] = (intersection.y, intersection.x)  # lat, lon
                intersection_points_dict[(label2, label1)] = (intersection.y, intersection.x)

# é¡¯ç¤ºçŸ©é™£
df_matrix = pd.DataFrame(matrix, columns=label_list, index=label_list)
display(df_matrix)

# å°å‡ºæ‰€æœ‰äº¤é»
print("æ‰€æœ‰äº¤é»ï¼ˆlabel å°æ‡‰çš„äº¤é»åº§æ¨™ï¼‰:")
for (label_a, label_b), point in intersection_points_dict.items():
    print(f"{label_a} x {label_b} -> äº¤é»åº§æ¨™: (lat={point[0]:.6f}, lon={point[1]:.6f})")

from sklearn.cluster import DBSCAN
import numpy as np
from math import radians, cos, sin, asin, sqrt
from collections import defaultdict

# å°‡æ‰€æœ‰äº¤é»åº§æ¨™è½‰ç‚º numpy array
coords = np.array(list(intersection_points_dict.values()))  # [[lat, lon], ...]

# è¨ˆç®— haversine è·é›¢
def haversine(lat1, lon1, lat2, lon2):
    R = 6371000  # åœ°çƒåŠå¾‘ (å…¬å°º)
    dlat = radians(lat2 - lat1)
    dlon = radians(lon2 - lon1)
    a = sin(dlat / 2)**2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon / 2)**2
    return 2 * R * asin(sqrt(a))

# è‡ªè¨‚ haversine è·é›¢çŸ©é™£
def haversine_distance_matrix(coords):
    n = len(coords)
    dist_matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                dist_matrix[i][j] = haversine(coords[i][0], coords[i][1], coords[j][0], coords[j][1])
    return dist_matrix

# DBSCAN èšé¡ï¼ˆeps = 2.5 å…¬å°ºï¼Œmin_samples=1 è¡¨ç¤ºè‡ªå·±ä¹Ÿèƒ½æˆä¸€ç¾¤ï¼‰
distance_matrix = haversine_distance_matrix(coords)
db = DBSCAN(eps=2.5, min_samples=1, metric='precomputed')
labels = db.fit_predict(distance_matrix)

# ç‚ºæ¯å€‹ cluster è¨ˆç®— centroid
cluster_points = defaultdict(list)
for i, label in enumerate(labels):
    cluster_points[label].append(coords[i])

cluster_centroids = {
    label: np.mean(np.array(pts), axis=0)  # å¹³å‡ lat/lon
    for label, pts in cluster_points.items()
}

# å°‡æ‰€æœ‰äº¤é»æ›´æ–°ç‚º centroid
label_keys = list(intersection_points_dict.keys())
for i, key in enumerate(label_keys):
    cluster_id = labels[i]
    centroid = cluster_centroids[cluster_id]
    intersection_points_dict[key] = tuple(centroid)

# å°å‡ºçµæœ
print("èšé¡å¾Œäº¤é»ï¼ˆä½¿ç”¨ centroid æ›´æ–°ï¼‰:")
for (label_a, label_b), point in intersection_points_dict.items():
    print(f"{label_a} x {label_b} -> ç¾¤ä¸­å¿ƒ: (lat={point[0]:.6f}, lon={point[1]:.6f})")

import plotly.graph_objects as go
import numpy as np
import plotly.express as px

fig = go.Figure()

# å–å¾—æŒ‡å®š grid_info
first_grid_info = grid_info[1151]

# ç•«å‡º grid_calculationï¼ˆè—è‰²ï¼‰
grid_calculation = first_grid_info["calculation"]
lat_values = [pt[1] for pt in grid_calculation]
lon_values = [pt[0] for pt in grid_calculation]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='blue'),
    name='Grid Calculation'
))

# ç•«å‡º grid_recordedï¼ˆç´…è‰²ï¼‰
grid_recorded = first_grid_info["recorded"]["grid"]
lat_values = [pt[1] for pt in grid_recorded]
lon_values = [pt[0] for pt in grid_recorded]
fig.add_trace(go.Scattermapbox(
    lat=lat_values + [lat_values[0]],
    lon=lon_values + [lon_values[0]],
    mode='lines',
    line=dict(width=2, color='red'),
    name='Grid Recorded'
))

# ğŸ“Œ é¡¯ç¤º intersection pointsï¼Œæ ¹æ“š cluster ä¸Šè‰²
unique_cluster_ids = set(labels)
color_scale = px.colors.qualitative.Set1  # æˆ– Set3ã€Plotly ç­‰é…è‰²æ–¹æ¡ˆ

for cluster_id in unique_cluster_ids:
    # æ‰€æœ‰å±¬æ–¼é€™å€‹ cluster çš„äº¤é»ç´¢å¼•
    indices = np.where(labels == cluster_id)[0]
    cluster_color = color_scale[cluster_id % len(color_scale)]

    # æå–äº¤é»ä¸¦åŠ åˆ°åœ–ä¸Š
    for idx in indices:
        label_pair = list(intersection_points_dict.keys())[idx]
        point = intersection_points_dict[label_pair]
        fig.add_trace(go.Scattermapbox(
            lat=[point[0]],
            lon=[point[1]],
            mode='markers+text',
            marker=dict(size=10, color=cluster_color),
            text=[f"Cluster {cluster_id}"],
            textposition="top right",
            name=f"Intersection Cluster {cluster_id}",
            showlegend=False
        ))

# è¨ˆç®—åœ°åœ–ä¸­å¿ƒ
all_lats = [pt[1] for pt in grid_recorded + grid_calculation]
all_lons = [pt[0] for pt in grid_recorded + grid_calculation]

fig.update_layout(
    mapbox=dict(
        style='open-street-map',
        zoom=15,
        center=dict(
            lat=np.mean(all_lats),
            lon=np.mean(all_lons)
        )
    ),
    height=800,
    margin=dict(l=0, r=0, t=0, b=0),
    showlegend=True,
    legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="left",
        x=0.01,
        bgcolor='rgba(255,255,255,0.8)'
    )
)

fig.show()