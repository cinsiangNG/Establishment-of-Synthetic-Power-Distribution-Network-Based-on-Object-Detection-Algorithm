# -*- coding: utf-8 -*-
"""Prediction_accuracy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10l2D54S5CetASY01aWp6QS73eStdIj6P
"""

def getPathLength(lat1,lng1,lat2,lng2):
    '''calculates the distance between two lat, long coordinate pairs'''
    R = 6371000 # radius of earth in m
    lat1rads = math.radians(lat1)
    lat2rads = math.radians(lat2)
    deltaLat = math.radians((lat2-lat1))
    deltaLng = math.radians((lng2-lng1))
    a = math.sin(deltaLat/2) * math.sin(deltaLat/2) + math.cos(lat1rads) * math.cos(lat2rads) * math.sin(deltaLng/2) * math.sin(deltaLng/2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = R * c
    return d

def unnestlist(alist):
  unnestedlist = []
  for subl in alist:
    for item in subl:
      unnestedlist.append(item)
  return unnestedlist

"""# **Aerial view accuracy**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "aerialview_poles.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Street view accuracy**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "streetview_pole.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25,30,50] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Data fusion accuracy**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "fused_poles.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Aerial View Accuracy(Yolo11)**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "detected_poles_Yolo11.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Aerial View Accuracy(Yolo11+Transformer)**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "detected_poles_Yolo11_transformer.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Aerial View Ensemble Learning**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "detected_poles_Yolo11_EL.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Aerial View Yolo v8x**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "detected_poles_Yolov8x.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Street View 100 meter**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "Streetview_adaptive_constraints.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Street View 50 meter**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "Streetview_adaptive_constraints_50m.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Aerial View Yolov8 newdataset**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "detected_poles_newdataset_v8.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Aerial View Yolo11x newdataset**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "detected_poles_newdataset_11x.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Aerial View Yolov8x newdataset**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "detected_poles_newdataset_8x.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Street View 50m + increased data point**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "Streetview_adaptive_constraints_50m+dataset_increased.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Street View Original + Increased point**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "7000testOriginal.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Data Fusion(Old_Dataset_Yolo11+adaptive_constraints_50m)**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "fused_poles_Yolo11+adaptive_constraints_50m.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Data Fusion(Old_Dataset_Yolo11+OriginalStreetView_increased)**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "fused_poles_Yolo11+OriginalStreetview_incresed.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Data Fusion(Old_Dataset_Yolo11+adaptive_constraints_50m_increased)**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "fused_poles_Yolo11+adaptive_constraints_50m_dataset_increased.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Data Fusion(New_Dataset_Yolo11x+adaptive_constraints_50m)**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "fused_poles_newdataset_Yolo11x+adaptive_constraints_50m.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Data Fusion(New_Dataset_Yolo11x+OriginalStreetView_incresed)**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "fused_poles_newdataset_Yolo11x+OriginalStreetview_incresed.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Data Fusion(New_Dataset_Yolo11x+adaptive_constraints_50m_increased)**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "fused_poles_newdataset_Yolo11x+adaptive_constraints_50m_dataset_increased.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Data Fusion(New_Dataset_Yolo11x+OriginalStreetView)**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "fused_poles_newdataset_Yolo11x+OriginalStreetview.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Street view accuracy update to YOLO11**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "update_yolo11.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult

"""# **Debuged Adaptive Constrained LOB-50m**"""

# compute accuracy
# PctAcc1: Percentage of the number of actual poles being within a buffer zone of a predicted pole (%)
# PctAcc2: Percentage of the number of predicted of poles being within a certain buffer zone of actual poles (%)
import pandas as pd
import numpy as np
import math

workingdirectory = "/content/"
WHPoleLoc = pd.read_excel(workingdirectory + "PoleLocationGT.xlsx",sheet_name='pole') # actual pole locations
WHPolePred = pd.read_excel(workingdirectory + "adaptive_constrained_result.xlsx") # predicted pole locations

distMax = 2
polepredgroup = []

polepred = np.array(WHPolePred)
for i in range(0,len(polepred)):
  if i not in unnestlist(polepredgroup):
    pt0 = polepred[i]
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepred]
    closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
    polepredgroup.append(closepts)

polepredgroup_final = []
for i in range(0,len(polepredgroup)):
  lats = polepred[polepredgroup[i],0]
  lons = polepred[polepredgroup[i],1]
  polepredgroup_final.append([np.mean(lats), np.mean(lons)])

bufferdist = [1,2,3,5,7,10,15,20,25] # buffer distance (meter)

PctAcc1 =[]
PctAcc2 =[]

for bb in range(0,len(bufferdist)):
  poles_in_Buffer1 = 0
  for i in range(0,len(polepredgroup_final)):
    pt0 = np.array(polepredgroup_final[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in WHPoleLoc.values.tolist()]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer1 += 1
  PctAcc1.append(poles_in_Buffer1/len(polepredgroup_final))

  poles_in_Buffer2 = 0
  for i in range(0,len(WHPoleLoc)):
    pt0 = np.array(WHPoleLoc.loc[i]) # current pole
    dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in polepredgroup_final]
    if min(dist) < bufferdist[bb]:
      poles_in_Buffer2 += 1
  PctAcc2.append(poles_in_Buffer2/len(WHPoleLoc))
F1 = 2 * (np.array(PctAcc1) * np.array(PctAcc2)) / (np.array(PctAcc1) + np.array(PctAcc2))
PRDresult = pd.DataFrame(np.array([np.array(bufferdist), np.array(PctAcc1), np.array(PctAcc2), F1]).T,
                        columns=['Buffer(m)', 'Precision', 'Recall', 'F1'])
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1)]).T,columns=['Buffer(m)','PDR'])
# PRDresult
# PRDresult = pd.DataFrame(np.array([np.array(bufferdist),np.array(PctAcc1),np.array(PctAcc2)]).T,columns=['Buffer(m)','PDR1','PDR2'])

PRDresult