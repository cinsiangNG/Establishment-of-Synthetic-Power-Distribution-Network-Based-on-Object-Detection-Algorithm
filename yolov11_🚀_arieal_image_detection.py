# -*- coding: utf-8 -*-
"""YOLOv11 ğŸš€ Arieal_image_detection

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ztMTP4QKi8i4rDCFimmvsdvn1PbbuZ1F
"""

!pip install ultralytics
! git clone https://github.com/doersino/aerialbot
! python3 -m venv aerialbot
! cd aerialbot
! source bin/activate
! pip3 install -r /content/aerialbot/requirements.txt
!pip install googlemaps
!pip install overpy
!pip install geopy
!pip install plotly
!pip install folium
!pip install shapely

"""## **Link to GOOGLE CLOUD**"""

from google.colab import drive
drive.mount('/content/drive')

import os
os.environ["DATASET_DIRECTORY"] = "/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/Aerial_view"

"""### Create model by using **YOLOv8ğŸš€**"""

from ultralytics import YOLO

#Load a model
model = YOLO("/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/Aerial_view/yolo11.pt") #load existing model

"""## **Validating..........**"""

metric=model.val(data="/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/Aerial_view/Pole_test-3/data.yaml")

"""# **Processing aerial image captureï¼Œvalidating image and output the result to the excel file**"""

import pandas as pd
import matplotlib.pyplot as plt
import cv2
import subprocess
import plotly.graph_objects as go

# åˆå§‹åŒ–ä¸€ä¸ªæ–°åˆ—æ¥å­˜å‚¨æ£€æµ‹ç»“æœ
df['Detection'] = ''

# åˆå§‹åŒ–ä¸€ä¸ªåˆ—è¡¨æ¥å­˜å‚¨æ£€æµ‹åˆ°çš„ç”µçº¿æ†ä½ç½®
detected_poles = []

# å¾300è¡Œé–‹å§‹åŸ·è¡Œ
for index, row in df.iloc[400:500].iterrows():
    latitude = row['Lat']
    longitude = row['Lon']

    print(f"Downloading map for coordinates: ({latitude}, {longitude})")

    # ä½¿ç”¨ subprocess æ¥æ‰§è¡Œå‘½ä»¤
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        '--image_width', '1000',
        '--image_height', '1000',
        '-w', '35',
        '-h', '35'
    ]
    subprocess.run(command, check=True)

    # ç”Ÿæˆä¸‹è½½å›¾ç‰‡çš„è·¯å¾„
    image_path = f"/content/aerialbot/aerialbot-{latitude}-{longitude}-35.0-35.0-0.035.jpg"

    # ä½¿ç”¨è®­ç»ƒå¥½çš„æ¨¡å‹æ£€æµ‹æ˜¯å¦æœ‰ç”µçº¿æ†
    results = model(image_path)

    if results and results[0].boxes:  # å¦‚æœæ¨¡å‹è¿”å›çš„ç»“æœåŒ…å«ç”µçº¿æ†
        df.at[index, 'Detection'] = 'âœ”'

        # å°†ç”µçº¿æ†çš„ä½ç½®åŠ å…¥ detected_poles åˆ—è¡¨
        detected_poles.append({'Lat': latitude, 'Lon': longitude})
    else:
        df.at[index, 'Detection'] = 'x'

    # æ˜¾ç¤ºå¸¦æœ‰è¾¹ç•Œæ¡†çš„ç»“æœå›¾åƒï¼ˆå¯é€‰ï¼‰
    result_image = results[0].plot()
    plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()

# ä¿å­˜æ–°çš„ CSV æ–‡ä»¶
df.to_csv('/content/Result7.csv', index=False)

# ä½¿ç”¨ Plotly å°† detected_poles æ˜¾ç¤ºåœ¨åœ°å›¾ä¸Š
def mapplotpoints(poles, zoom=16, color='red'):
    latitudes = [pole['Lat'] for pole in poles]
    longitudes = [pole['Lon'] for pole in poles]

    fig = go.Figure(go.Scattermapbox(
        lat=latitudes,
        lon=longitudes,
        mode='markers',
        marker=go.scattermapbox.Marker(size=12, color=color),
        text=["Detected Pole" for _ in poles]
    ))

    fig.update_layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken="pk.eyJ1IjoiY2hpeWluZ2xpbiIsImEiOiJja24xNDB3eWkwaWh1Mm5vMnRud2cwdTZ1In0.mVM5aPE2TgbxeKo1il1CUQ",
            bearing=0,
            center=go.layout.mapbox.Center(
                lat=sum(latitudes) / len(latitudes),
                lon=sum(longitudes) / len(longitudes),
            ),
            pitch=0,
            zoom=zoom
        )
    )

    fig.show()

# åœ¨åœ°å›¾ä¸Šæ˜¾ç¤ºæ£€æµ‹åˆ°çš„ç”µçº¿æ†
if detected_poles:
    mapplotpoints(detected_poles)
else:
    print("No poles detected.")

"""# ***Rectangle Zone to download an area's coordinate***"""

import subprocess
from geopy.distance import geodesic
from geopy import Point
import matplotlib.pyplot as plt
import cv2
import numpy as np
import plotly.graph_objects as go

# Jamaica Beach's boundary (latitude and longitude)
area_boundary = {
    "min_lat": 29.204,  # South boundary
    "max_lat": 29.231,  # North boundary
    "min_lon": -94.976,  # West boundary
    "max_lon": -94.920   # East boundary
}

# Parameters for coordinate generation
start_lat = area_boundary["min_lat"]
start_lon = area_boundary["min_lon"]
distance_meters = 35  # Step distance in meters
bearing = 90  # East direction

# è°ƒæ•´åçš„å‡½æ•°ç”¨äºç”Ÿæˆç½‘æ ¼åæ ‡å¹¶é™åˆ¶æ€»æ•°
# è°ƒæ•´åçš„å‡½æ•°ç”¨äºç”Ÿæˆç½‘æ ¼åæ ‡å¹¶é™åˆ¶æ€»æ•°
def generate_grid_coordinates(start_lat, start_lon, area_boundary, distance_meters, max_coordinates=100):
    coordinates = []
    current_lat = start_lat
    bearing_east = 90
    bearing_west = 270
    move_east = True  # æ ‡å¿—æ¥äº¤æ›¿æ–¹å‘ä»¥åˆ›å»ºç½‘æ ¼
    count = 0  # ç”¨äºè®¡æ•°ç”Ÿæˆçš„åæ ‡æ•°é‡

    while current_lat <= area_boundary["max_lat"]:
        current_point = Point(current_lat, start_lon)
        row_coordinates = []

        while current_point.longitude <= area_boundary["max_lon"] and count < max_coordinates:
            # å°†å½“å‰ç‚¹æ·»åŠ åˆ°åæ ‡åˆ—è¡¨
            row_coordinates.append((current_point.latitude, current_point.longitude))
            count += 1  # å¢åŠ è®¡æ•°å™¨

            # å¦‚æœè¾¾åˆ°æœ€å¤§åæ ‡æ•°é‡ï¼Œåœæ­¢ç”Ÿæˆ
            if count >= max_coordinates:
                break

            # åœ¨å½“å‰è¡ŒæŒ‰æŒ‡å®šçš„è·ç¦»ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªç‚¹
            next_point = geodesic(meters=distance_meters).destination(current_point, bearing_east if move_east else bearing_west)
            current_point = next_point

        # å°†å½“å‰è¡Œçš„åæ ‡æ·»åŠ åˆ°ä¸»åˆ—è¡¨ä¸­
        coordinates.extend(row_coordinates)

        # å¦‚æœè¾¾åˆ°æœ€å¤§åæ ‡æ•°é‡ï¼Œåœæ­¢ç”Ÿæˆ
        if count >= max_coordinates:
            break

        # ç§»åŠ¨åˆ°ä¸‹ä¸€â€œè¡Œâ€ï¼ˆå¢åŠ çº¬åº¦ï¼‰
        current_lat += distance_meters / 111320  # å°†ç±³å¤§è‡´è½¬æ¢ä¸ºçº¬åº¦çš„åº¦æ•°
        # äº¤æ›¿æ–¹å‘ä»¥è¦†ç›–åŒºåŸŸå‘ˆZå­—å½¢
        move_east = not move_east

    return coordinates

# åœ¨è¾¹ç•Œå†…ç”Ÿæˆæœ€å¤š 100 ä¸ªåæ ‡
coordinates = generate_grid_coordinates(start_lat, start_lon, area_boundary, distance_meters, max_coordinates=100)



# Download settings
max_downloads = 1000  # Maximum number of downloads
download_count = 0  # Download counter

# Initialize a list to save the detection results
detected_poles = []

for latitude, longitude in coordinates:
    if download_count >= max_downloads:
        print("Reached the maximum number of downloads, stopping.")
        break  # Stop if maximum downloads are reached

    print(f"Downloading map for coordinates: ({latitude}, {longitude})")

    # Use subprocess to run the download command
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        '--image_width', '1000',
        '--image_height', '1000',
        '-w', '35',
        '-h', '35'
    ]
    subprocess.run(command, check=True)

    # Generate the path for the downloaded image
    image_path = f"/content/aerialbot/aerialbot-{latitude}-{longitude}-35.0-35.0-0.035.jpg"

    # Use the trained model to detect poles
    results = model(image_path)  # Replace with your model detection code

    if results and results[0].boxes:  # If the model returns results with poles
        detected_poles.append({'Lat': latitude, 'Lon': longitude})
    else:
        # Handle the case where no poles are detected
        print(f"No poles detected at: ({latitude}, {longitude})")

    download_count += 1  # Increment the counter

    # Display the image with bounding boxes (optional)
    result_image = results[0].plot()  # Replace with the appropriate plotting code
    plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()

# Save the detected poles to a CSV file if needed
# df.to_csv('/content/Result7.csv', index=False)

# Function to plot detected poles on the map using Plotly
def mapplotpoints(poles, zoom=16, color='red'):
    latitudes = [pole['Lat'] for pole in poles]
    longitudes = [pole['Lon'] for pole in poles]

    fig = go.Figure(go.Scattermapbox(
        lat=latitudes,
        lon=longitudes,
        mode='markers',
        marker=go.scattermapbox.Marker(size=12, color=color),
        text=["Detected Pole" for _ in poles]
    ))

    fig.update_layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken="pk.eyJ1IjoiY2hpeWluZ2xpbiIsImEiOiJja24xNDB3eWkwaWh1Mm5vMnRud2cwdTZ1In0.mVM5aPE2TgbxeKo1il1CUQ",
            bearing=0,
            center=go.layout.mapbox.Center(
                lat=sum(latitudes) / len(latitudes),
                lon=sum(longitudes) / len(longitudes),
            ),
            pitch=0,
            zoom=zoom
        )
    )

    fig.show()

# Plot the detected poles on the map
if detected_poles:
    mapplotpoints(detected_poles)
else:
    print("No poles detected.")

"""# **Polygon Area from Google MAP API**

# **Capture the boundary of Jamaica beach from Mapbox and plot it**
"""

import overpy
from geopy.distance import geodesic
from geopy import Point
import matplotlib.pyplot as plt
import cv2
import subprocess

# åˆå§‹åŒ– Overpass API
api = overpy.Overpass()

# ç™¼é€è«‹æ±‚ç²å– Jamaica Beach çš„é‚Šç•Œæ•¸æ“š
query = """
[out:json];
relation["name"="Jamaica Beach"];
out geom;
"""
result = api.query(query)

# æå–é‚Šç•Œåº§æ¨™
boundary_coordinates = []
for rel in result.relations:
    for member in rel.members:
        if member.geometry:
            boundary_coordinates.extend([(node.lat, node.lon) for node in member.geometry])

print(f"ç²å–åˆ°çš„é‚Šç•Œåº§æ¨™æ•¸é‡: {len(boundary_coordinates)}")

import matplotlib.pyplot as plt

# æå–é‚Šç•Œåº§æ¨™çš„ç¶“ç·¯åº¦åˆ—è¡¨
lats = [lat for lat, lon in boundary_coordinates]
lons = [lon for lat, lon in boundary_coordinates]

# ä½¿ç”¨ Matplotlib ç¹ªè£½é‚Šç•Œ
plt.figure(figsize=(10, 6))
plt.plot(lons, lats, 'b-', marker='o', markersize=3)  # 'b-' è¡¨ç¤ºè—è‰²å¯¦ç·š
plt.fill(lons, lats, 'lightblue', alpha=0.4)  # å¡«å……å€åŸŸ
plt.title("Jamaica Beach polygon area map")
plt.xlabel("ç¶“åº¦")
plt.ylabel("ç·¯åº¦")
plt.grid(True)
plt.show()

"""# **Plot the Jamaica beach's polygon area on the map**"""

import folium
from shapely.geometry import Polygon

# æå–é‚Šç•Œåº§æ¨™ (ä¹‹å‰ç²å–çš„)
boundary_coordinates = [(lat, lon) for lat, lon in boundary_coordinates]

# å‰µå»ºä¸­å¿ƒé»ï¼ˆå¯ä»¥é¸æ“‡é‚Šç•Œå…§ä»»æ„ä¸€å€‹é»ä½œç‚ºä¸­å¿ƒï¼‰
center_lat = sum(lat for lat, lon in boundary_coordinates) / len(boundary_coordinates)
center_lon = sum(lon for lat, lon in boundary_coordinates) / len(boundary_coordinates)

# å‰µå»º Folium åœ°åœ–ï¼Œä¸¦å°‡ä¸­å¿ƒé»è¨­ç‚º Jamaica Beach çš„ä¸­å¿ƒ
m = folium.Map(location=[center_lat, center_lon], zoom_start=14)

# å°‡é‚Šç•Œæ·»åŠ åˆ°åœ°åœ–ä¸Š
folium.Polygon(boundary_coordinates, color="blue", fill=True, fill_opacity=0.4).add_to(m)

# é¡¯ç¤ºåœ°åœ–
m.save('jamaica_beach_map.html')

"""# **Create a rectangle that include all the entire Jamaica Beach and turn it into 35x35 distance meter small rectangle.**"""

from shapely.geometry import Polygon, Point

# å‰µå»ºé‚Šç•Œå¤šé‚Šå½¢
boundary_polygon = Polygon(boundary_coordinates)

# ç²å–é‚Šç•Œçš„å¤–æ¥çŸ©å½¢
min_lat, min_lon, max_lat, max_lon = boundary_polygon.bounds

# è¨­ç½®å°çŸ©å½¢çš„å¤§å°
distance_meters = 35
lat_distance = distance_meters / 111320  # ç·¯åº¦åº¦æ•¸
lon_distance = distance_meters / (111320 * (max_lon - min_lon) / (max_lat - min_lat))  # ç¶“åº¦åº¦æ•¸

# ç”Ÿæˆå°çŸ©å½¢çš„ä¸­å¿ƒé»
grid_coordinates = []
current_lat = min_lat + lat_distance / 2
while current_lat < max_lat:
    current_lon = min_lon + lon_distance / 2
    while current_lon < max_lon:
        center_point = (current_lat, current_lon)
        small_rectangle = Polygon([
            (current_lon - lon_distance / 2, current_lat - lat_distance / 2),
            (current_lon + lon_distance / 2, current_lat - lat_distance / 2),
            (current_lon + lon_distance / 2, current_lat + lat_distance / 2),
            (current_lon - lon_distance / 2, current_lat + lat_distance / 2),
        ])
        # æª¢æŸ¥å°çŸ©å½¢æ˜¯å¦èˆ‡é‚Šç•Œç›¸äº¤è‹¥æœ‰å°±æ–°å¢è©²é»
        point = Point(center_point)
        if boundary_polygon.contains(point) or boundary_polygon.touches(point):
          grid_coordinates.append(center_point)
        current_lon += lon_distance
    current_lat += lat_distance

print(f"ç”Ÿæˆçš„åæ¨™é»æ•¸é‡: {len(grid_coordinates)}")

"""# **Get the center of each small rectangle as the coordinate and plot them.**"""

import plotly.graph_objects as go

# å‡è¨­ä½ å·²ç¶“æœ‰ boundary_coordinates å’Œ grid_coordinates
# å°‡é‚Šç•Œåº§æ¨™åˆ†æˆç¶“ç·¯åº¦åˆ—è¡¨
boundary_latitudes = [coord[0] for coord in boundary_coordinates]
boundary_longitudes = [coord[1] for coord in boundary_coordinates]

# å°‡å°çŸ©å½¢çš„ä¸­å¿ƒé»åˆ†æˆç¶“ç·¯åº¦åˆ—è¡¨
grid_latitudes = [coord[0] for coord in grid_coordinates]
grid_longitudes = [coord[1] for coord in grid_coordinates]

# å‰µå»ºåœ°åœ–
fig = go.Figure()

# ç•«å‡ºé‚Šç•Œ
fig.add_trace(go.Scattermapbox(
    lat=boundary_latitudes + [boundary_latitudes[0]],  # é—œé–‰å¤šé‚Šå½¢
    lon=boundary_longitudes + [boundary_longitudes[0]],
    mode='lines',
    name='Jamaica Beach Boundary',
    line=dict(width=2, color='blue')
))

# ç•«å‡ºå°çŸ©å½¢çš„ä¸­å¿ƒé»
fig.add_trace(go.Scattermapbox(
    lat=grid_latitudes,
    lon=grid_longitudes,
    mode='markers',
    marker=dict(size=8, color='red'),
    name='Grid Coordinates'
))

# æ›´æ–°å¸ƒå±€
fig.update_layout(
    mapbox=dict(
        accesstoken="pk.eyJ1IjoiY2luc2lhbmcwNDI5IiwiYSI6ImNtMWx4NjRoMzBlMDUyanB1OW45aWdtMTUifQ.eM_lp379UkizfnWrdEv8CA",  # æ›¿æ›ç‚ºä½ çš„ Mapbox Token
        center=dict(lat=sum(boundary_latitudes) / len(boundary_latitudes), lon=sum(boundary_longitudes) / len(boundary_longitudes)),
        zoom=14
    ),
    showlegend=True
)

# é¡¯ç¤ºåœ°åœ–
fig.show()

# è¨­ç½®ä¸‹è¼‰çš„é™åˆ¶
max_downloads = len(grid_coordinates)  # æœ€å¤§ä¸‹è¼‰æ•¸é‡
download_count = 0  # ä¸‹è¼‰è¨ˆæ•¸å™¨
detected_poles = []  # å„²å­˜æª¢æ¸¬åˆ°çš„é»

for latitude, longitude in grid_coordinates:
    if download_count > max_downloads:
        print("å·²é”åˆ°æœ€å¤§ä¸‹è¼‰æ•¸é‡ï¼Œåœæ­¢ä¸‹è¼‰ã€‚")
        print(f"å·²ä¸‹è¼‰ {download_count} å¼µåœ–åƒã€‚")
        break

    print(f"æ­£åœ¨ä¸‹è¼‰åœ°åœ–: ({latitude}, {longitude})")

    # ä½¿ç”¨ subprocess ä¸‹è¼‰åœ–åƒ
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        '--image_width', '1000',
        '--image_height', '1000',
        '-w', '35',
        '-h', '35'
    ]
    subprocess.run(command, check=True)

    image_path = f"/content/aerialbot/aerialbot-{latitude}-{longitude}-35.0-35.0-0.035.jpg"

    # æ¨¡å‹æª¢æ¸¬ä»£ç¢¼ï¼Œå‡è¨­ä½¿ç”¨ç¾æœ‰æ¨¡å‹
    results = model(image_path)

    if results and results[0].boxes:
        detected_poles.append({'Lat': latitude, 'Lon': longitude})
    else:
        print(f"æœªæª¢æ¸¬åˆ°ä»»ä½•ç‰©é«”: ({latitude}, {longitude})")

    download_count += 1  # å¢åŠ ä¸‹è¼‰è¨ˆæ•¸
    # Display the image with bounding boxes (optional)
    # result_image = results[0].plot()  # Replace with the appropriate plotting code
    # plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    # plt.axis('off')
    # plt.show()

print('downloaded_image=', download_count)

import plotly.graph_objects as go

def plot_detected_poles(poles, zoom=16, color='red'):
    latitudes = [pole['Lat'] for pole in poles]
    longitudes = [pole['Lon'] for pole in poles]

    fig = go.Figure(go.Scattermapbox(
        lat=latitudes,
        lon=longitudes,
        mode='markers',
        marker=go.scattermapbox.Marker(size=12, color=color),
        text=["Detected Pole" for _ in poles]
    ))

    fig.update_layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken="pk.eyJ1IjoiY2luc2lhbmcwNDI5IiwiYSI6ImNtMWx4NjRoMzBlMDUyanB1OW45aWdtMTUifQ.eM_lp379UkizfnWrdEv8CA",
            bearing=0,
            center=go.layout.mapbox.Center(
                lat=sum(latitudes) / len(latitudes),
                lon=sum(longitudes) / len(longitudes),
            ),
            pitch=0,
            zoom=zoom
        )
    )

    fig.show()

# é¡¯ç¤ºæª¢æ¸¬çµæœ
if detected_poles:
    plot_detected_poles(detected_poles)
else:
    print("æœªæª¢æ¸¬åˆ°ä»»ä½•æ¡¿å­ã€‚")

"""# **Plot polygon area (update if overlapping)**"""

import subprocess
import plotly.graph_objects as go
import cv2
import matplotlib.pyplot as plt
from shapely.geometry import Point
from math import radians, cos
import torch

def calculate_actual_coordinates(center_lat, center_lon, image_width, image_height, pixel_x, pixel_y, image_geo_width, image_geo_height):
    """
    Calculate the actual geographic coordinates of a point in the image.

    :param center_lat: Latitude of the image center
    :param center_lon: Longitude of the image center
    :param image_width: Width of the image in pixels
    :param image_height: Height of the image in pixels
    :param pixel_x: X coordinate of the point in the image
    :param pixel_y: Y coordinate of the point in the image
    :param image_geo_width: Geographic width of the image in meters
    :param image_geo_height: Geographic height of the image in meters
    :return: (latitude, longitude) of the point
    """
    # Convert pixel coordinates to geographic offsets
    offset_x = (pixel_x - image_width / 2) / image_width * image_geo_width
    offset_y = (image_height / 2 - pixel_y) / image_height * image_geo_height

    # Calculate the actual coordinates
    actual_lon = center_lon + offset_x / (111320 * cos(radians(center_lat)))
    actual_lat = center_lat + offset_y / 111320

    return actual_lat, actual_lon


# è®¾ç½®ä¸‹è½½çš„é™åˆ¶
max_downloads = len(grid_coordinates)  # æœ€å¤§ä¸‹è½½æ•°é‡
download_count = 0  # ä¸‹è½½è®¡æ•°å™¨
detected_poles = []  # å­˜å‚¨æ£€æµ‹åˆ°çš„ç‚¹

for latitude, longitude in grid_coordinates:
    if download_count >= max_downloads:
        print(f"å·²è¾¾åˆ°æœ€å¤§ä¸‹è½½æ•°é‡ï¼Œåœæ­¢ä¸‹è½½ã€‚å·²ä¸‹è½½ {download_count} å¼ å›¾åƒã€‚")
        break

    print(f"æ­£åœ¨ä¸‹è½½åœ°å›¾: ({latitude}, {longitude})")

    # ä½¿ç”¨ subprocess ä¸‹è½½å›¾åƒ
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        '--image_width', '1000',
        '--image_height', '1000',
        '-w', '35',
        '-h', '35'
    ]
    subprocess.run(command, check=True)

    image_path = f"/content/aerialbot/aerialbot-{latitude}-{longitude}-35.0-35.0-0.035.jpg"

    # æ¨¡å‹æ£€æµ‹ä»£ç ï¼Œå‡è®¾ä½¿ç”¨ç°æœ‰æ¨¡å‹
    results = model(image_path)

    if results and results[0].boxes:
        for box in results[0].boxes:
            # è·å–è¾¹ç•Œæ¡†çš„ä¸­å¿ƒç‚¹
            x_center, y_center = box.xywh[0][:2]

            # å°†å¼ é‡è½¬æ¢ä¸º Python æ•°å€¼
            x_center = x_center.item() if isinstance(x_center, torch.Tensor) else x_center
            y_center = y_center.item() if isinstance(y_center, torch.Tensor) else y_center

            # è®¡ç®—å®é™…åœ°ç†åæ ‡
            actual_lat, actual_lon = calculate_actual_coordinates(
                latitude, longitude, 1000, 1000, x_center, y_center, 35, 35)

            detected_poles.append({'Lat': float(actual_lat), 'Lon': float(actual_lon)})

        print(f"æ£€æµ‹åˆ°ç”µçº¿æ†: ({latitude}, {longitude})")
    else:
        print(f"æœªæ£€æµ‹åˆ°ä»»ä½•ç‰©ä½“: ({latitude}, {longitude})")

    download_count += 1  # å¢åŠ ä¸‹è½½è®¡æ•°

    # # æ˜¾ç¤ºå¸¦æœ‰è¾¹ç•Œæ¡†çš„å›¾åƒï¼ˆå¯é€‰ï¼‰
    # result_image = results[0].plot()
    # plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    # plt.axis('off')
    # plt.show()

!pip install openpyxl

import pandas as pd
import openpyxl

detected_poles = pd.read_excel('/content/detected_poles_Yolo11.xlsx')
x = detected_poles['Lon']
y = detected_poles['Lat']

def plot_detected_poles(poles, zoom=15, color='red'):
    latitudes = [pole['Lat'] for pole in poles]
    longitudes = [pole['Lon'] for pole in poles]

    fig = go.Figure(go.Scattermapbox(
        lat=latitudes,
        lon=longitudes,
        mode='markers',
        marker=go.scattermapbox.Marker(size=12, color=color),
        text=["Detected Pole" for _ in poles]
    ))

    fig.update_layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken="pk.eyJ1IjoiY2luc2lhbmcwNDI5IiwiYSI6ImNtMWx4NjRoMzBlMDUyanB1OW45aWdtMTUifQ.eM_lp379UkizfnWrdEv8CA",
            bearing=0,
            center=go.layout.mapbox.Center(
                lat=sum(latitudes) / len(latitudes),
                lon=sum(longitudes) / len(longitudes),
            ),
            pitch=0,
            zoom=zoom
        )
    )

    fig.show()

# æ˜¾ç¤ºæ£€æµ‹ç»“æœ
if detected_poles:
    plot_detected_poles(detected_poles)
else:
    print("æœªæ£€æµ‹åˆ°ä»»ä½•ç”µçº¿æ†ã€‚")

"""# **Save the predicted coordinate into excel file and export it to Google Drive.**"""

!pip install openpyxl
import pandas as pd
import os

# å°‡ detected_poles è½‰æ›ç‚º DataFrame
df = pd.DataFrame(detected_poles, columns=['Lat', 'Lon'])

# è¨­å®š Excel æª”æ¡ˆçš„å„²å­˜è·¯å¾‘
excel_path = "/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/Aerial_view/detected_poles_Yolo11.xlsx"

# ç¢ºä¿ç›®æ¨™è³‡æ–™å¤¾å­˜åœ¨
os.makedirs(os.path.dirname(excel_path), exist_ok=True)

# å°‡ DataFrame å„²å­˜ç‚º Excel æª”æ¡ˆ
df.to_excel(excel_path, index=False)

print(f"è³‡æ–™å·²æˆåŠŸå„²å­˜åˆ° {excel_path}")