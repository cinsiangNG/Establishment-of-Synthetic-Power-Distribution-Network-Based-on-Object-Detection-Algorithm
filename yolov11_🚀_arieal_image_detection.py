# -*- coding: utf-8 -*-
"""YOLOv11 🚀 Arieal_image_detection

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ztMTP4QKi8i4rDCFimmvsdvn1PbbuZ1F
"""

!pip install ultralytics
! git clone https://github.com/doersino/aerialbot
! python3 -m venv aerialbot
! cd aerialbot
! source bin/activate
! pip3 install -r /content/aerialbot/requirements.txt
!pip install googlemaps
!pip install overpy
!pip install geopy
!pip install plotly
!pip install folium
!pip install shapely

"""## **Link to GOOGLE CLOUD**"""

from google.colab import drive
drive.mount('/content/drive')

import os
os.environ["DATASET_DIRECTORY"] = "/content/drive/MyDrive/黃俊翔_論文研究📚/Aerial_view"

"""### Create model by using **YOLOv8🚀**"""

from ultralytics import YOLO

#Load a model
model = YOLO("/content/drive/MyDrive/黃俊翔_論文研究📚/Aerial_view/yolo11.pt") #load existing model

"""## **Validating..........**"""

metric=model.val(data="/content/drive/MyDrive/黃俊翔_論文研究📚/Aerial_view/Pole_test-3/data.yaml")

"""# **Processing aerial image capture，validating image and output the result to the excel file**"""

import pandas as pd
import matplotlib.pyplot as plt
import cv2
import subprocess
import plotly.graph_objects as go

# 初始化一个新列来存储检测结果
df['Detection'] = ''

# 初始化一个列表来存储检测到的电线杆位置
detected_poles = []

# 從300行開始執行
for index, row in df.iloc[400:500].iterrows():
    latitude = row['Lat']
    longitude = row['Lon']

    print(f"Downloading map for coordinates: ({latitude}, {longitude})")

    # 使用 subprocess 来执行命令
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        '--image_width', '1000',
        '--image_height', '1000',
        '-w', '35',
        '-h', '35'
    ]
    subprocess.run(command, check=True)

    # 生成下载图片的路径
    image_path = f"/content/aerialbot/aerialbot-{latitude}-{longitude}-35.0-35.0-0.035.jpg"

    # 使用训练好的模型检测是否有电线杆
    results = model(image_path)

    if results and results[0].boxes:  # 如果模型返回的结果包含电线杆
        df.at[index, 'Detection'] = '✔'

        # 将电线杆的位置加入 detected_poles 列表
        detected_poles.append({'Lat': latitude, 'Lon': longitude})
    else:
        df.at[index, 'Detection'] = 'x'

    # 显示带有边界框的结果图像（可选）
    result_image = results[0].plot()
    plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()

# 保存新的 CSV 文件
df.to_csv('/content/Result7.csv', index=False)

# 使用 Plotly 将 detected_poles 显示在地图上
def mapplotpoints(poles, zoom=16, color='red'):
    latitudes = [pole['Lat'] for pole in poles]
    longitudes = [pole['Lon'] for pole in poles]

    fig = go.Figure(go.Scattermapbox(
        lat=latitudes,
        lon=longitudes,
        mode='markers',
        marker=go.scattermapbox.Marker(size=12, color=color),
        text=["Detected Pole" for _ in poles]
    ))

    fig.update_layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken="pk.eyJ1IjoiY2hpeWluZ2xpbiIsImEiOiJja24xNDB3eWkwaWh1Mm5vMnRud2cwdTZ1In0.mVM5aPE2TgbxeKo1il1CUQ",
            bearing=0,
            center=go.layout.mapbox.Center(
                lat=sum(latitudes) / len(latitudes),
                lon=sum(longitudes) / len(longitudes),
            ),
            pitch=0,
            zoom=zoom
        )
    )

    fig.show()

# 在地图上显示检测到的电线杆
if detected_poles:
    mapplotpoints(detected_poles)
else:
    print("No poles detected.")

"""# ***Rectangle Zone to download an area's coordinate***"""

import subprocess
from geopy.distance import geodesic
from geopy import Point
import matplotlib.pyplot as plt
import cv2
import numpy as np
import plotly.graph_objects as go

# Jamaica Beach's boundary (latitude and longitude)
area_boundary = {
    "min_lat": 29.204,  # South boundary
    "max_lat": 29.231,  # North boundary
    "min_lon": -94.976,  # West boundary
    "max_lon": -94.920   # East boundary
}

# Parameters for coordinate generation
start_lat = area_boundary["min_lat"]
start_lon = area_boundary["min_lon"]
distance_meters = 35  # Step distance in meters
bearing = 90  # East direction

# 调整后的函数用于生成网格坐标并限制总数
# 调整后的函数用于生成网格坐标并限制总数
def generate_grid_coordinates(start_lat, start_lon, area_boundary, distance_meters, max_coordinates=100):
    coordinates = []
    current_lat = start_lat
    bearing_east = 90
    bearing_west = 270
    move_east = True  # 标志来交替方向以创建网格
    count = 0  # 用于计数生成的坐标数量

    while current_lat <= area_boundary["max_lat"]:
        current_point = Point(current_lat, start_lon)
        row_coordinates = []

        while current_point.longitude <= area_boundary["max_lon"] and count < max_coordinates:
            # 将当前点添加到坐标列表
            row_coordinates.append((current_point.latitude, current_point.longitude))
            count += 1  # 增加计数器

            # 如果达到最大坐标数量，停止生成
            if count >= max_coordinates:
                break

            # 在当前行按指定的距离移动到下一个点
            next_point = geodesic(meters=distance_meters).destination(current_point, bearing_east if move_east else bearing_west)
            current_point = next_point

        # 将当前行的坐标添加到主列表中
        coordinates.extend(row_coordinates)

        # 如果达到最大坐标数量，停止生成
        if count >= max_coordinates:
            break

        # 移动到下一“行”（增加纬度）
        current_lat += distance_meters / 111320  # 将米大致转换为纬度的度数
        # 交替方向以覆盖区域呈Z字形
        move_east = not move_east

    return coordinates

# 在边界内生成最多 100 个坐标
coordinates = generate_grid_coordinates(start_lat, start_lon, area_boundary, distance_meters, max_coordinates=100)



# Download settings
max_downloads = 1000  # Maximum number of downloads
download_count = 0  # Download counter

# Initialize a list to save the detection results
detected_poles = []

for latitude, longitude in coordinates:
    if download_count >= max_downloads:
        print("Reached the maximum number of downloads, stopping.")
        break  # Stop if maximum downloads are reached

    print(f"Downloading map for coordinates: ({latitude}, {longitude})")

    # Use subprocess to run the download command
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        '--image_width', '1000',
        '--image_height', '1000',
        '-w', '35',
        '-h', '35'
    ]
    subprocess.run(command, check=True)

    # Generate the path for the downloaded image
    image_path = f"/content/aerialbot/aerialbot-{latitude}-{longitude}-35.0-35.0-0.035.jpg"

    # Use the trained model to detect poles
    results = model(image_path)  # Replace with your model detection code

    if results and results[0].boxes:  # If the model returns results with poles
        detected_poles.append({'Lat': latitude, 'Lon': longitude})
    else:
        # Handle the case where no poles are detected
        print(f"No poles detected at: ({latitude}, {longitude})")

    download_count += 1  # Increment the counter

    # Display the image with bounding boxes (optional)
    result_image = results[0].plot()  # Replace with the appropriate plotting code
    plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.show()

# Save the detected poles to a CSV file if needed
# df.to_csv('/content/Result7.csv', index=False)

# Function to plot detected poles on the map using Plotly
def mapplotpoints(poles, zoom=16, color='red'):
    latitudes = [pole['Lat'] for pole in poles]
    longitudes = [pole['Lon'] for pole in poles]

    fig = go.Figure(go.Scattermapbox(
        lat=latitudes,
        lon=longitudes,
        mode='markers',
        marker=go.scattermapbox.Marker(size=12, color=color),
        text=["Detected Pole" for _ in poles]
    ))

    fig.update_layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken="pk.eyJ1IjoiY2hpeWluZ2xpbiIsImEiOiJja24xNDB3eWkwaWh1Mm5vMnRud2cwdTZ1In0.mVM5aPE2TgbxeKo1il1CUQ",
            bearing=0,
            center=go.layout.mapbox.Center(
                lat=sum(latitudes) / len(latitudes),
                lon=sum(longitudes) / len(longitudes),
            ),
            pitch=0,
            zoom=zoom
        )
    )

    fig.show()

# Plot the detected poles on the map
if detected_poles:
    mapplotpoints(detected_poles)
else:
    print("No poles detected.")

"""# **Polygon Area from Google MAP API**

# **Capture the boundary of Jamaica beach from Mapbox and plot it**
"""

import overpy
from geopy.distance import geodesic
from geopy import Point
import matplotlib.pyplot as plt
import cv2
import subprocess

# 初始化 Overpass API
api = overpy.Overpass()

# 發送請求獲取 Jamaica Beach 的邊界數據
query = """
[out:json];
relation["name"="Jamaica Beach"];
out geom;
"""
result = api.query(query)

# 提取邊界座標
boundary_coordinates = []
for rel in result.relations:
    for member in rel.members:
        if member.geometry:
            boundary_coordinates.extend([(node.lat, node.lon) for node in member.geometry])

print(f"獲取到的邊界座標數量: {len(boundary_coordinates)}")

import matplotlib.pyplot as plt

# 提取邊界座標的經緯度列表
lats = [lat for lat, lon in boundary_coordinates]
lons = [lon for lat, lon in boundary_coordinates]

# 使用 Matplotlib 繪製邊界
plt.figure(figsize=(10, 6))
plt.plot(lons, lats, 'b-', marker='o', markersize=3)  # 'b-' 表示藍色實線
plt.fill(lons, lats, 'lightblue', alpha=0.4)  # 填充區域
plt.title("Jamaica Beach polygon area map")
plt.xlabel("經度")
plt.ylabel("緯度")
plt.grid(True)
plt.show()

"""# **Plot the Jamaica beach's polygon area on the map**"""

import folium
from shapely.geometry import Polygon

# 提取邊界座標 (之前獲取的)
boundary_coordinates = [(lat, lon) for lat, lon in boundary_coordinates]

# 創建中心點（可以選擇邊界內任意一個點作為中心）
center_lat = sum(lat for lat, lon in boundary_coordinates) / len(boundary_coordinates)
center_lon = sum(lon for lat, lon in boundary_coordinates) / len(boundary_coordinates)

# 創建 Folium 地圖，並將中心點設為 Jamaica Beach 的中心
m = folium.Map(location=[center_lat, center_lon], zoom_start=14)

# 將邊界添加到地圖上
folium.Polygon(boundary_coordinates, color="blue", fill=True, fill_opacity=0.4).add_to(m)

# 顯示地圖
m.save('jamaica_beach_map.html')

"""# **Create a rectangle that include all the entire Jamaica Beach and turn it into 35x35 distance meter small rectangle.**"""

from shapely.geometry import Polygon, Point

# 創建邊界多邊形
boundary_polygon = Polygon(boundary_coordinates)

# 獲取邊界的外接矩形
min_lat, min_lon, max_lat, max_lon = boundary_polygon.bounds

# 設置小矩形的大小
distance_meters = 35
lat_distance = distance_meters / 111320  # 緯度度數
lon_distance = distance_meters / (111320 * (max_lon - min_lon) / (max_lat - min_lat))  # 經度度數

# 生成小矩形的中心點
grid_coordinates = []
current_lat = min_lat + lat_distance / 2
while current_lat < max_lat:
    current_lon = min_lon + lon_distance / 2
    while current_lon < max_lon:
        center_point = (current_lat, current_lon)
        small_rectangle = Polygon([
            (current_lon - lon_distance / 2, current_lat - lat_distance / 2),
            (current_lon + lon_distance / 2, current_lat - lat_distance / 2),
            (current_lon + lon_distance / 2, current_lat + lat_distance / 2),
            (current_lon - lon_distance / 2, current_lat + lat_distance / 2),
        ])
        # 檢查小矩形是否與邊界相交若有就新增該點
        point = Point(center_point)
        if boundary_polygon.contains(point) or boundary_polygon.touches(point):
          grid_coordinates.append(center_point)
        current_lon += lon_distance
    current_lat += lat_distance

print(f"生成的坐標點數量: {len(grid_coordinates)}")

"""# **Get the center of each small rectangle as the coordinate and plot them.**"""

import plotly.graph_objects as go

# 假設你已經有 boundary_coordinates 和 grid_coordinates
# 將邊界座標分成經緯度列表
boundary_latitudes = [coord[0] for coord in boundary_coordinates]
boundary_longitudes = [coord[1] for coord in boundary_coordinates]

# 將小矩形的中心點分成經緯度列表
grid_latitudes = [coord[0] for coord in grid_coordinates]
grid_longitudes = [coord[1] for coord in grid_coordinates]

# 創建地圖
fig = go.Figure()

# 畫出邊界
fig.add_trace(go.Scattermapbox(
    lat=boundary_latitudes + [boundary_latitudes[0]],  # 關閉多邊形
    lon=boundary_longitudes + [boundary_longitudes[0]],
    mode='lines',
    name='Jamaica Beach Boundary',
    line=dict(width=2, color='blue')
))

# 畫出小矩形的中心點
fig.add_trace(go.Scattermapbox(
    lat=grid_latitudes,
    lon=grid_longitudes,
    mode='markers',
    marker=dict(size=8, color='red'),
    name='Grid Coordinates'
))

# 更新布局
fig.update_layout(
    mapbox=dict(
        accesstoken="pk.eyJ1IjoiY2luc2lhbmcwNDI5IiwiYSI6ImNtMWx4NjRoMzBlMDUyanB1OW45aWdtMTUifQ.eM_lp379UkizfnWrdEv8CA",  # 替換為你的 Mapbox Token
        center=dict(lat=sum(boundary_latitudes) / len(boundary_latitudes), lon=sum(boundary_longitudes) / len(boundary_longitudes)),
        zoom=14
    ),
    showlegend=True
)

# 顯示地圖
fig.show()

# 設置下載的限制
max_downloads = len(grid_coordinates)  # 最大下載數量
download_count = 0  # 下載計數器
detected_poles = []  # 儲存檢測到的點

for latitude, longitude in grid_coordinates:
    if download_count > max_downloads:
        print("已達到最大下載數量，停止下載。")
        print(f"已下載 {download_count} 張圖像。")
        break

    print(f"正在下載地圖: ({latitude}, {longitude})")

    # 使用 subprocess 下載圖像
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        '--image_width', '1000',
        '--image_height', '1000',
        '-w', '35',
        '-h', '35'
    ]
    subprocess.run(command, check=True)

    image_path = f"/content/aerialbot/aerialbot-{latitude}-{longitude}-35.0-35.0-0.035.jpg"

    # 模型檢測代碼，假設使用現有模型
    results = model(image_path)

    if results and results[0].boxes:
        detected_poles.append({'Lat': latitude, 'Lon': longitude})
    else:
        print(f"未檢測到任何物體: ({latitude}, {longitude})")

    download_count += 1  # 增加下載計數
    # Display the image with bounding boxes (optional)
    # result_image = results[0].plot()  # Replace with the appropriate plotting code
    # plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    # plt.axis('off')
    # plt.show()

print('downloaded_image=', download_count)

import plotly.graph_objects as go

def plot_detected_poles(poles, zoom=16, color='red'):
    latitudes = [pole['Lat'] for pole in poles]
    longitudes = [pole['Lon'] for pole in poles]

    fig = go.Figure(go.Scattermapbox(
        lat=latitudes,
        lon=longitudes,
        mode='markers',
        marker=go.scattermapbox.Marker(size=12, color=color),
        text=["Detected Pole" for _ in poles]
    ))

    fig.update_layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken="pk.eyJ1IjoiY2luc2lhbmcwNDI5IiwiYSI6ImNtMWx4NjRoMzBlMDUyanB1OW45aWdtMTUifQ.eM_lp379UkizfnWrdEv8CA",
            bearing=0,
            center=go.layout.mapbox.Center(
                lat=sum(latitudes) / len(latitudes),
                lon=sum(longitudes) / len(longitudes),
            ),
            pitch=0,
            zoom=zoom
        )
    )

    fig.show()

# 顯示檢測結果
if detected_poles:
    plot_detected_poles(detected_poles)
else:
    print("未檢測到任何桿子。")

"""# **Plot polygon area (update if overlapping)**"""

import subprocess
import plotly.graph_objects as go
import cv2
import matplotlib.pyplot as plt
from shapely.geometry import Point
from math import radians, cos
import torch

def calculate_actual_coordinates(center_lat, center_lon, image_width, image_height, pixel_x, pixel_y, image_geo_width, image_geo_height):
    """
    Calculate the actual geographic coordinates of a point in the image.

    :param center_lat: Latitude of the image center
    :param center_lon: Longitude of the image center
    :param image_width: Width of the image in pixels
    :param image_height: Height of the image in pixels
    :param pixel_x: X coordinate of the point in the image
    :param pixel_y: Y coordinate of the point in the image
    :param image_geo_width: Geographic width of the image in meters
    :param image_geo_height: Geographic height of the image in meters
    :return: (latitude, longitude) of the point
    """
    # Convert pixel coordinates to geographic offsets
    offset_x = (pixel_x - image_width / 2) / image_width * image_geo_width
    offset_y = (image_height / 2 - pixel_y) / image_height * image_geo_height

    # Calculate the actual coordinates
    actual_lon = center_lon + offset_x / (111320 * cos(radians(center_lat)))
    actual_lat = center_lat + offset_y / 111320

    return actual_lat, actual_lon


# 设置下载的限制
max_downloads = len(grid_coordinates)  # 最大下载数量
download_count = 0  # 下载计数器
detected_poles = []  # 存储检测到的点

for latitude, longitude in grid_coordinates:
    if download_count >= max_downloads:
        print(f"已达到最大下载数量，停止下载。已下载 {download_count} 张图像。")
        break

    print(f"正在下载地图: ({latitude}, {longitude})")

    # 使用 subprocess 下载图像
    command = [
        'python3', '/content/aerialbot/aerialbot.py',
        '/content/aerialbot/config.sample.ini',
        f'-p{latitude},{longitude}',
        '--image_width', '1000',
        '--image_height', '1000',
        '-w', '35',
        '-h', '35'
    ]
    subprocess.run(command, check=True)

    image_path = f"/content/aerialbot/aerialbot-{latitude}-{longitude}-35.0-35.0-0.035.jpg"

    # 模型检测代码，假设使用现有模型
    results = model(image_path)

    if results and results[0].boxes:
        for box in results[0].boxes:
            # 获取边界框的中心点
            x_center, y_center = box.xywh[0][:2]

            # 将张量转换为 Python 数值
            x_center = x_center.item() if isinstance(x_center, torch.Tensor) else x_center
            y_center = y_center.item() if isinstance(y_center, torch.Tensor) else y_center

            # 计算实际地理坐标
            actual_lat, actual_lon = calculate_actual_coordinates(
                latitude, longitude, 1000, 1000, x_center, y_center, 35, 35)

            detected_poles.append({'Lat': float(actual_lat), 'Lon': float(actual_lon)})

        print(f"检测到电线杆: ({latitude}, {longitude})")
    else:
        print(f"未检测到任何物体: ({latitude}, {longitude})")

    download_count += 1  # 增加下载计数

    # # 显示带有边界框的图像（可选）
    # result_image = results[0].plot()
    # plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    # plt.axis('off')
    # plt.show()

!pip install openpyxl

import pandas as pd
import openpyxl

detected_poles = pd.read_excel('/content/detected_poles_Yolo11.xlsx')
x = detected_poles['Lon']
y = detected_poles['Lat']

def plot_detected_poles(poles, zoom=15, color='red'):
    latitudes = [pole['Lat'] for pole in poles]
    longitudes = [pole['Lon'] for pole in poles]

    fig = go.Figure(go.Scattermapbox(
        lat=latitudes,
        lon=longitudes,
        mode='markers',
        marker=go.scattermapbox.Marker(size=12, color=color),
        text=["Detected Pole" for _ in poles]
    ))

    fig.update_layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken="pk.eyJ1IjoiY2luc2lhbmcwNDI5IiwiYSI6ImNtMWx4NjRoMzBlMDUyanB1OW45aWdtMTUifQ.eM_lp379UkizfnWrdEv8CA",
            bearing=0,
            center=go.layout.mapbox.Center(
                lat=sum(latitudes) / len(latitudes),
                lon=sum(longitudes) / len(longitudes),
            ),
            pitch=0,
            zoom=zoom
        )
    )

    fig.show()

# 显示检测结果
if detected_poles:
    plot_detected_poles(detected_poles)
else:
    print("未检测到任何电线杆。")

"""# **Save the predicted coordinate into excel file and export it to Google Drive.**"""

!pip install openpyxl
import pandas as pd
import os

# 將 detected_poles 轉換為 DataFrame
df = pd.DataFrame(detected_poles, columns=['Lat', 'Lon'])

# 設定 Excel 檔案的儲存路徑
excel_path = "/content/drive/MyDrive/黃俊翔_論文研究📚/Aerial_view/detected_poles_Yolo11.xlsx"

# 確保目標資料夾存在
os.makedirs(os.path.dirname(excel_path), exist_ok=True)

# 將 DataFrame 儲存為 Excel 檔案
df.to_excel(excel_path, index=False)

print(f"資料已成功儲存到 {excel_path}")