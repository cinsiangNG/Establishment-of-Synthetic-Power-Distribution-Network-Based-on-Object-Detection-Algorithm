# -*- coding: utf-8 -*-
"""YOLOv5 🚀 StreetView_image_detection 的副本

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18U2PqFYQNthrzT3mjHFhWBTn7ddGJxOi
"""

from google.colab import drive

drive.mount("/content/drive")

import torch

print('torch %s %s' % (torch.__version__, torch.cuda.get_device_properties(0) if torch.cuda.is_available() else 'CPU'))

import IPython
from google.colab import output

display(IPython.display.Javascript('''
 function ClickConnect(){
   btn = document.querySelector("colab-connect-button")
   if (btn != null){
     console.log("Click colab-connect-button");
     btn.click()
     }

   btn = document.getElementById('ok')
   if (btn != null){
     console.log("Click reconnect");
     btn.click()
     }
  }

setInterval(ClickConnect,60000)
'''))

print("Done.")

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/colab/detect/yolov5
!pip install -U -r requirements.txt

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/黃俊翔_論文研究📚/Street_view/Streetview from junior/detect
!pip install streetlevel

# prepare required functions
import math

def decode_polyline(polyline_str):
    '''Pass a Google Maps encoded polyline string; returns list of lat/lon pairs'''
    index, lat, lng = 0, 0, 0
    coordinates = []
    changes = {'latitude': 0, 'longitude': 0}

    # Coordinates have variable length when encoded, so just keep
    # track of whether we've hit the end of the string. In each
    # while loop iteration, a single coordinate is decoded.
    while index < len(polyline_str):
        # Gather lat/lon changes, store them in a dictionary to apply them later
        for unit in ['latitude', 'longitude']:
            shift, result = 0, 0
            while True:
                byte = ord(polyline_str[index]) - 63
                index += 1
                result |= (byte & 0x1f) << shift
                shift += 5
                if not byte >= 0x20:
                    break
            if (result & 1):
                changes[unit] = ~(result >> 1)
            else:
                changes[unit] = (result >> 1)
        lat += changes['latitude']
        lng += changes['longitude']
        coordinates.append((lat / 100000.0, lng / 100000.0))
    return coordinates

def getpathpoints(dirs,pts_distance=50):
  # polypath = dirs[0]['legs'][0]['steps'][0]['polyline']['points']
  polypath = dirs[0]['overview_polyline']['points']
  polypath_pts = decode_polyline(polypath)
  pts_coords = []
  for pt in range(1, len(polypath_pts)):
    lat1 = polypath_pts[pt-1][0]
    lng1 = polypath_pts[pt-1][1]
    lat2 = polypath_pts[pt][0]
    lng2 = polypath_pts[pt][1]
    azimuth = calculateBearing(lat1,lng1,lat2,lng2)
    coords = getInnerPoints(pts_distance,azimuth,lat1,lng1,lat2,lng2)
    if pt==1:
      pts_coords.append(coords)
    else:
      pts_coords.append(coords[1:])
  flatten_pts_coords = []
  for subl in pts_coords:
      for item in subl:
          flatten_pts_coords.append(item)
  return flatten_pts_coords

def getPathLength(lat1,lng1,lat2,lng2):
    '''calculates the distance between two lat, long coordinate pairs'''
    R = 6371000 # radius of earth in m
    lat1rads = math.radians(lat1)
    lat2rads = math.radians(lat2)
    deltaLat = math.radians((lat2-lat1))
    deltaLng = math.radians((lng2-lng1))
    a = math.sin(deltaLat/2) * math.sin(deltaLat/2) + math.cos(lat1rads) * math.cos(lat2rads) * math.sin(deltaLng/2) * math.sin(deltaLng/2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    d = R * c
    return d

def getDestinationLatLong(lat,lng,azimuth,distance):
    '''returns the lat an long of destination point
    given the start lat, long, aziuth, and distance'''
    R = 6378.1 #Radius of the Earth in km
    brng = math.radians(azimuth) #Bearing is degrees converted to radians.
    d = distance/1000 #Distance m converted to km
    lat1 = math.radians(lat) #Current dd lat point converted to radians
    lon1 = math.radians(lng) #Current dd long point converted to radians
    lat2 = math.asin(math.sin(lat1) * math.cos(d/R) + math.cos(lat1)* math.sin(d/R)* math.cos(brng))
    lon2 = lon1 + math.atan2(math.sin(brng) * math.sin(d/R)* math.cos(lat1), math.cos(d/R)- math.sin(lat1)* math.sin(lat2))
    #convert back to degrees
    lat2 = math.degrees(lat2)
    lon2 = math.degrees(lon2)
    return[lat2, lon2]

def calculateBearing(lat1,lng1,lat2,lng2):
    '''calculates the azimuth in degrees from start point to end point'''
    startLat = math.radians(lat1)
    startLong = math.radians(lng1)
    endLat = math.radians(lat2)
    endLong = math.radians(lng2)
    dLong = endLong - startLong
    dPhi = math.log(math.tan(endLat/2.0+math.pi/4.0)/math.tan(startLat/2.0+math.pi/4.0))
    if abs(dLong) > math.pi:
         if dLong > 0.0:
             dLong = -(2.0 * math.pi - dLong)
         else:
             dLong = (2.0 * math.pi + dLong)
    bearing = (math.degrees(math.atan2(dLong, dPhi)) + 360.0) % 360.0;
    return bearing

def getInnerPoints(interval,azimuth,lat1,lng1,lat2,lng2):
    '''returns every coordinate pair inbetween two coordinate
    pairs given the desired interval'''

    d = getPathLength(lat1,lng1,lat2,lng2)
    remainder, dist = math.modf((d / interval))
    counter = float(interval)
    coords = []
    coords.append([lat1,lng1])
    for distance in range(0,int(dist)):
        coord = getDestinationLatLong(lat1,lng1,azimuth,counter)
        counter = counter + float(interval)
        coords.append(coord)
    coords.append([lat2,lng2])
    return coords

def samepoint(line1, line2):
  result = False
  for x in line1:
    for y in line2:
      if x == y:
        result = True
        return x
        break
  return result

def find_intersection(p0, p1, p2, p3):
    # line1 = [p0.tolist(),p1.tolist()]
    # line2 = [p2.tolist(),p3.tolist()]
    line1 = [p0,p1]
    line2 = [p2,p3]
    samept = samepoint(line1,line2)
    if samept is not False:
      intersection_point = samept
    else:
      s10_x = p1[0] - p0[0]
      s10_y = p1[1] - p0[1]
      s32_x = p3[0] - p2[0]
      s32_y = p3[1] - p2[1]
      denom = s10_x * s32_y - s32_x * s10_y
      if denom == 0 : return math.nan # collinear
      denom_is_positive = denom > 0
      s02_x = p0[0] - p2[0]
      s02_y = p0[1] - p2[1]
      s_numer = s10_x * s02_y - s10_y * s02_x
      if (s_numer < 0) == denom_is_positive : return math.nan # no collision
      t_numer = s32_x * s02_y - s32_y * s02_x
      if (t_numer < 0) == denom_is_positive : return math.nan # no collision
      if (s_numer > denom) == denom_is_positive or (t_numer > denom) == denom_is_positive : return math.nan # no collision
      # collision detected
      t = t_numer / denom
      intersection_point = [ p0[0] + (t * s10_x), p0[1] + (t * s10_y) ]
    return intersection_point

import geopandas
import pandas as pd
import plotly.graph_objects as go
import random
# plot points on map
# pt1 = pd.DataFrame(Pts2downloadPano,columns=['lat','lon'])
# gdf = geopandas.GeoDataFrame(pt1, crs = {'init': 'epsg:4326'}, geometry=geopandas.points_from_xy(pt1.lon, pt1.lat)).to_crs(epsg=3857)
# gdf = geopandas.GeoDataFrame(pt1, geometry=geopandas.points_from_xy(pt1.lon, pt1.lat))

mapbox_access_token = "pk.eyJ1IjoiY2hpeWluZ2xpbiIsImEiOiJja24xNDB3eWkwaWh1Mm5vMnRud2cwdTZ1In0.mVM5aPE2TgbxeKo1il1CUQ"

## using plotly ##
def mapplotpoints(lat,lon,size=12,zoom=16,color='blue',name=None,text=None):
  # input gdf in ndarrays
  fig = go.Figure(go.Scattermapbox(
          lat= list(lat),
          lon= list(lon),
          mode='markers',
          name=name,
          marker=go.scattermapbox.Marker(
              size=size,
              color=color # named CSS color
          ),
          text=text
      ))
  fig.update_layout(
      autosize=True,
      hovermode='closest',
      mapbox=dict(
          accesstoken=mapbox_access_token,
          bearing=0,
          center=go.layout.mapbox.Center(
              # lat= np.mean(gdf['lat'].values),
              # lon= np.mean(gdf['lon'].values),
              lat= np.mean(lat),
              lon= np.mean(lon),
          ),
          pitch=0,
          zoom=zoom
      )
  )
  #fig.show()
  return fig

def plot_map(trajectory_points, grid_cells, pole_LOBs, PanoInfoFinal):
    """
    視覺化行駛軌跡、網格、電線桿 LOB 和 PanoInfoFinal

    Args:
        trajectory_points: 行駛軌跡點 (list of [lat, lon])
        grid_cells: 自適應網格划分的結果，每个单元是 [[lat1, lon1], [lat2, lon2], ...]
        pole_LOBs: 電線桿 LOB 線條 (list of [[start_lat, start_lon, end_lat, end_lon]])
        pano_info: PanoInfoFinal，包含街景全景點 (DataFrame: ['lat', 'lon'])
    """
    fig = go.Figure()

    # 1️⃣ 添加行駛軌跡 (藍色線條)
    fig.add_trace(go.Scattermapbox(
        lat=[pt[0] for pt in trajectory_points],
        lon=[pt[1] for pt in trajectory_points],
        mode='lines+markers',
        name='Trajectory',
        line=dict(width=2, color='blue'),
        marker=dict(size=5, color='blue')
    ))

    # 2️⃣ 畫網格 (不同顏色的多邊形)
    colors = ['red', 'green', 'purple', 'brown', 'pink', 'cyan', 'magenta', 'lime', 'teal', 'orange']

    for i, cell in enumerate(grid_cells):
        cell.append(cell[0])  # 闭合多边形
        grid_color = random.choice(colors)  # 隨機選擇顏色
        fig.add_trace(go.Scattermapbox(
            lat=[pt[0] for pt in cell],
            lon=[pt[1] for pt in cell],
            mode='lines',
            line=dict(width=2, color=grid_color),
            name=f'Grid {i+1}'
        ))

    # 3️⃣ 畫 Pole LOB (紅色線條)
    for lob_group in poleLOB:
        for lob in lob_group:
            lat1, lon1, lat2, lon2 = lob
            fig.add_trace(go.Scattermapbox(
                mode="lines",
                lon=[lon1, lon2],  # 经度
                lat=[lat1, lat2],  # 纬度
                line=dict(width=2, color="red"),  # 线条颜色
                name="LOB"
            ))

    # 4️⃣ 畫 PanoInfoFinal (黃色點標記街景全景點)
    fig.add_trace(go.Scattermapbox(
        lat=PanoInfoFinal['lat'],
        lon=PanoInfoFinal['lon'],
        mode='markers',
        marker=dict(size=8, color='yellow', opacity=0.8),
        name='Panorama Locations'
    ))

    # 5️⃣ 設定地圖樣式
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=16,
            center=dict(
                lat=sum(pt[0] for pt in trajectory_points) / len(trajectory_points),
                lon=sum(pt[1] for pt in trajectory_points) / len(trajectory_points)
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

import asyncio
from aiohttp import ClientSession
from streetlevel import streetview
import os
import math
from PIL import Image
import shutil

# Resize the downloaded image to 640x640 pixels
def resize_image(input_path, output_path, size):
    with Image.open(input_path) as img:
        img_resized = img.resize(size)
        img_resized.save(output_path)

# Asynchronous function to download and resize a street view image
async def download_and_resize_street_view(lat, lon, path1, path2, size):
    # Ensure the target folder exists
    if not os.path.exists(path1):
        os.makedirs(path1)
    if not os.path.exists(path2):
        os.makedirs(path2)

    async with ClientSession() as session:
        # Find the panorama
        pano = await streetview.find_panorama_async(lat, lon, session)
        # Define the file path for the original image
        original_image_path = os.path.join(path1, f"{pano.id}.jpg")
        # Check if the image already exists
        if os.path.exists(original_image_path):
            print(f"Image {pano.id}.jpg already exists. Using the existing image.")
        else:
            # Download the panorama image and save it
            await streetview.download_panorama_async(pano, original_image_path, session)
        # Resize the image after downloading
        resized_path = os.path.join(path2, f"{pano.id}resized.jpg")
        resize_image(original_image_path, resized_path, size)
        # Store the heading in degrees
        heading = pano.heading * 180 / math.pi

    return heading, resized_path

# Clean directory
def clean_directory(directory):
    if os.path.exists(directory):
        for file in os.listdir(directory):
            file_path = os.path.join(directory, file)
            try:
                if os.path.isfile(file_path):
                    os.unlink(file_path)
                elif os.path.isdir(file_path):
                    shutil.rmtree(file_path)
            except Exception as e:
                print(f"Failed to delete {file_path}. Reason: {e}")
        print(f"Successfully cleaned up the directory: {directory}")
    else:
        print(f"The directory does not exist: {directory}")

import requests
import matplotlib.image as mpimg
from matplotlib import gridspec
import io

#### Bounding boxes info extraction
def BBInfoExtraction(allbox,imgwidth,coor,dist_para,heading):
  # parameters for distance inferecing
  pole_Height = dist_para[0] # 40*304.8 set standard pole as 40 ft height above ground (mm)
  camera_fl = dist_para[1] # 1.5 camera focal length (mm)
  camera_sh = dist_para[2] # 4.55 camera sensor height (mm)
  searchdist = dist_para[3] # 10 distance coverage from the proposed pole distance (m)
  # extract pole info in a pano
  bearings = []
  LOB = []
  for bb in allbox:
    # bb = [x1, y1, x2, y2]
    dtheta = (bb[0]+bb[2])/2-imgwidth/2
    if dtheta > 0:
      bearing = dtheta/imgwidth*360
    else:
      bearing = 360 + dtheta/imgwidth*360
    bearing = (bearing + heading) %360
    bearings.append(bearing)

    pole_px = bb[3]-bb[1] # pixel height of detected pole bounding box
    if pole_px > 0:
      pole_dist = camera_fl*pole_Height*imageshape[0]/camera_sh/pole_px/1000 # calculated pole distance from camera (m)
      # compute LOB based on the proposed pole location +/- a search distance
      # LOBstart = getDestinationLatLong(coor[0], coor[1], bearing, max(0,pole_dist-searchdist))
      LOBstart = coor
      LOBend = getDestinationLatLong(coor[0], coor[1], bearing, pole_dist)
      # LOBend = getDestinationLatLong(coor[0], coor[1], bearing, min(80,pole_dist+searchdist))
      LOB.append([LOBstart[0],LOBstart[1],LOBend[0],LOBend[1]])
    else:
      LOB.append([])
  return LOB, bearings

#### find intersections of predicted line of bearings (LOBs)
def LOBintersections(poleLOB, startpoint, nvg = 4, plotresult=False):
  def unnestlist(alist):
    unnestedlist = []
    for subl in alist:
      for item in subl:
        unnestedlist.append(item)
    return unnestedlist

  allintxn = []
  for gg in range(0,len(poleLOB)-nvg+1):
    subLOB = poleLOB[gg:gg+nvg] # subset of LOB group
    intxninsub = [] # all intersections in this subgroup
    for sg in range(0,nvg-1):
      vc = subLOB[sg] # current LOB group
      vo_temp = [x for i,x in enumerate(subLOB) if i!=sg] # all other LOB groups
      vo = unnestlist(vo_temp) # all other LOBs
      for i in range(0,len(vc)):
        for j in range(0,len(vo)):
          intersect = find_intersection(vc[i][0:2], vc[i][2:], vo[j][0:2], vo[j][2:])
          if not intersect is math.nan:
            intxninsub.append(intersect)
    # a[gg] = intxninsub
    allintxn.append(intxninsub)

  # extract unique intersections
  intxn_unnest = unnestlist(allintxn)
  intxn_unique = [i for n, i in enumerate(intxn_unnest) if i not in intxn_unnest[:n]]
  intxn_array = np.array(intxn_unique)

  ## first grouping: combine intersection generated by prediction error
  distMax = 1
  intxngroup = []
  for i in range(0,len(intxn_array)):
    if i not in unnestlist(intxngroup):
      pt0 = intxn_array[i]
      dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in intxn_array]
      closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
      intxngroup.append(closepts)

  intxns = []
  for i in range(0,len(intxngroup)):
    lats = intxn_array[intxngroup[i],0]
    lons = intxn_array[intxngroup[i],1]
    intxns.append([np.mean(lats), np.mean(lons)])

  ## second grouping: combine intersections very close to each other
  distMax = 5
  intxngroup = []

  intxn_array2 = np.array(intxns)
  for i in range(0,len(intxn_array2)):
    if i not in unnestlist(intxngroup):
      pt0 = intxn_array2[i]
      dist = [(lambda x: getPathLength(pt0[0],pt0[1],x[0], x[1]))(x) for x in intxn_array2]
      closepts = [i for i, x in enumerate(np.array(dist) < distMax) if x]
      intxngroup.append(closepts)

  intxns2 = []
  for i in range(0,len(intxngroup)):
    lats = intxn_array2[intxngroup[i],0]
    lons = intxn_array2[intxngroup[i],1]
    intxns2.append([np.mean(lats), np.mean(lons)])

  ## check pole distance
  maxpoledist = 70 # maximum allowable distance b/t poles [urban: 125 ft (38 m); rural: 300 ft (91 m)]
  maxsegdist = 500 # maximum distance b/t route segments; output route points might be quite far away and belong to different road
  intxns_sorted = []
  intxns_index = []
  dist = [(lambda x: getPathLength(startpoint[0],startpoint[1],x[0],x[1]))(x) for x in intxns2]
  if dist:
    intxns_index.append(np.argmin(dist))
    intxns_sorted.append(intxns2[np.argmin(dist)])

  for i in range(1,len(intxns2)):
    prevpt = intxns_sorted[i-1]
    dist = np.array([[n, (lambda x: getPathLength(prevpt[0],prevpt[1],x[0],x[1]))(x)] for n, x in enumerate(intxns2) if n not in intxns_index])
    sortdist = dist[np.argsort(dist[:, 1])]
    intxns_index.append(sortdist[0,0])
    intxns_sorted.append(intxns2[int(sortdist[0,0])])

  intxns3 = intxns_sorted.copy()
  for i in range(1,len(intxns_sorted)-1):
    pt0 = intxns_sorted[i]
    pt1 = intxns_sorted[i+1]
    dist2next = getPathLength(pt0[0],pt0[1],pt1[0],pt1[1])
    if maxpoledist < dist2next < maxsegdist:
      n_pole_needed = int(dist2next // maxpoledist) # number of pole needed to insert
      dist2insertpole = dist2next/(n_pole_needed+1)
      bearing = calculateBearing(pt0[0],pt0[1],pt1[0],pt1[1])
      for j in range(0,n_pole_needed):
        intxns3.append(getDestinationLatLong(pt0[0],pt0[1],bearing,dist2insertpole*(j+1)))
  intxns_final = intxns3.copy()

  ## plot results
  if plotresult:
    finalintxns = intxns_final
    print('Number of intersections = {}'.format(len(finalintxns)))
    pointtext=[str(x) for x in PanoInfoFinal.index+1]

    fig = mapplotpoints(PanoInfoFinal['lat'],PanoInfoFinal['lon'],size = 8, name='street view location', color='DodgerBlue',text=pointtext)
    fig.add_trace(go.Scattermapbox(
            lat=np.array(finalintxns)[:,0],
            lon=np.array(finalintxns)[:,1],
            name='possible pole locations',
            mode='markers',
            marker=go.scattermapbox.Marker(
                size=10,
                color='red',
                opacity=0.9
            )))

    for i in range(0,len(poleLOB)):
      lob = poleLOB[i]
      for j in range(0,len(lob)):
        fig.add_trace(
            go.Scattermapbox(
                lon = [np.array(poleLOB[i][j])[1], np.array(poleLOB[i][j])[3]],
                lat = [np.array(poleLOB[i][j])[0], np.array(poleLOB[i][j])[2]],
                mode = 'lines',
                line = dict(width = 1,color = 'Dodgerblue'),
                opacity=0.5
            )
        )
    fig.update_layout(
        height=650
    )
    return fig

  return intxns_final

# read ROI route points (locations to download street view images)

workingdirectory = '/content/'

LumbertonRoutesPoints = pd.read_csv(workingdirectory + "dense_route_points_with_distance.csv",converters={'RouteID':str})
RouteIDs = LumbertonRoutesPoints['RTE_NM'].unique() # unique route ID
LumbertonRoutesPoints.info()

# Commented out IPython magic to ensure Python compatibility.
!pip install --upgrade numpy
# %cd /content/drive/MyDrive/黃俊翔_論文研究📚/Street_view/Streetview from junior/detect/yolov5
from detect import run

# 指定文件夹名称
folder_name = "/content/PolePredictionResults"

# 创建文件夹（如果文件夹已存在则不会报错）
os.makedirs(folder_name, exist_ok=True)

from pickle import FALSE
import numpy as np
import pandas as pd

# 参数设置
dist_para = [40*304.8, 1.5, 4.55, 10]
size = (640, 640)

workingdirectory = '/content/'
# 文件路径
path1 = workingdirectory + 'StreetViewImages/'
path2 = workingdirectory + 'resized/'
savepreddir = workingdirectory + 'PolePredictionResults/'

# 清理检测结果目录
clean_directory('/content/drive/MyDrive/論文研究📚/Street_view/Streetview from junior/detect/yolov5/runs/detect')

totaldownload = 0

for rr in range(0,len(RouteIDs)):
    routeid = RouteIDs[rr]
    routepoints = LumbertonRoutesPoints.loc[LumbertonRoutesPoints['RTE_NM'] == routeid]
    Pts2downloadPano = routepoints[['Lat','Lon']].values.tolist()

    # 获取街景全景信息
    allpanoid = []
    for panoLatLon in Pts2downloadPano:
        pano = streetview.find_panorama(lat=panoLatLon[0], lon=panoLatLon[1])
        if bool(pano):
            allpanoid.append([pano.id, pano.lat, pano.lon])
    PanoInfoFinal = pd.DataFrame(allpanoid,columns=['panoid','lat','lon']).drop_duplicates()
    # PanoInfoFinal.to_csv('/content/drive/MyDrive/黃俊翔_論文研究📚/PanoInfoFinal.csv', mode='a', index=False, header=False)

    # 只处理超过3个全景点的路段
    if len(PanoInfoFinal) > 3:
        poleview = []  # 路径上的结果 [相机坐标, 杆体方位角]
        poleLOB = []   # 建议的LOB [起点坐标(相机), 终点坐标]

        # 处理每个全景点
        for pp in PanoInfoFinal.index:
            print('\r','Progress: route = {}/{}; pano = {}/{}; download = {}'.format(
                rr+1, len(RouteIDs), pp+1, len(PanoInfoFinal.index), totaldownload), end='')

            # 获取全景图像
            lat = PanoInfoFinal['lat'][pp]
            lon = PanoInfoFinal['lon'][pp]
            pano_coor = [lat, lon]
            heading, source = await download_and_resize_street_view(lat, lon, path1, path2, size)
            totaldownload += 1

            # 目标检测
            weights = '/content/drive/MyDrive/黃俊翔_論文研究📚/Street_view/Streetview from junior/detect/yolov5/runs/train/exp_J/best.pt'
            bounding_boxes = run(weights, source)

            # 提取图像尺寸
            image = Image.open(source)
            imageshape = np.shape(image)
            clean_directory(path2)

            # 提取预测结果并计算方位线
            LOB, bearings = BBInfoExtraction(bounding_boxes, imageshape[1], pano_coor, dist_para, heading)
            poleview.append([pano_coor, bearings])
            poleLOB.append(LOB)
            flat_LOB = [entry for sublist in poleLOB for entry in sublist]
            # print(poleLOB)
            poleLOB_df = pd.DataFrame(flat_LOB, columns=["start_lat", "start_lon", "end_lat", "end_lon"])
            poleLOB_df.to_csv('/content/drive/MyDrive/黃俊翔_論文研究📚/poleLOB_original2.csv', mode='a', index=False, header=False)
            print(flat_LOB)

        # # 自适应网格划分
        # trajectory_points = PanoInfoFinal[['lat','lon']].values.tolist()
        # grid_cells = adaptive_grid_division(trajectory_points, EFFECTIVE_DISTANCE)
        # baseline = calculate_baseline_length(trajectory_points)
        # fig = plot_map(trajectory_points, grid_cells, poleLOB, PanoInfoFinal)
        # fig.show()

        # # 计算LOB交点
        # intersections = calculate_LOB_intersections(poleLOB, grid_cells)

        # # 保存结果
        # if intersections:
        #     poleLocations = pd.DataFrame(intersections, columns=['lat','lon'])
        #     poleLocations.to_excel(
        #         savepreddir + f'Pred_r{rr+1:04d}.xlsx',
        #         index=False
        #     )

# import plotly.graph_objects as go

# def visualize_LOB_with_pano(poleLOB, PanoInfoFinal):
#     """
#     在地图上可视化 LOB 线段（红色）和 PanoInfoFinal 点（黄色）

#     Args:
#         poleLOB: List of LOB lines, each as [lat1, lon1, lat2, lon2]
#         PanoInfoFinal: DataFrame with columns ['panoid', 'lat', 'lon']
#     """
#     fig = go.Figure()

#     # 绘制 LOB 线段
#     for lob_group in poleLOB:
#         for lob in lob_group:
#             lat1, lon1, lat2, lon2 = lob
#             fig.add_trace(go.Scattermapbox(
#                 mode="lines",
#                 lon=[lon1, lon2],  # 经度
#                 lat=[lat1, lat2],  # 纬度
#                 line=dict(width=2, color="red"),  # 线条颜色
#                 name="LOB"
#             ))

#     # 绘制 PanoInfoFinal 位置（黄色点）
#     fig.add_trace(go.Scattermapbox(
#         mode="markers",
#         lon=PanoInfoFinal["lon"],
#         lat=PanoInfoFinal["lat"],
#         marker=dict(size=8, color="yellow", opacity=0.8),
#         name="Panorama Locations"
#     ))

#     # 设置地图属性
#     fig.update_layout(
#         mapbox=dict(
#             style="open-street-map",  # 底图样式，可改为 "satellite-streets"
#             center=dict(lat=PanoInfoFinal["lat"].iloc[0], lon=PanoInfoFinal["lon"].iloc[0]),  # 以第一点为中心
#             zoom=17
#         ),
#         margin=dict(l=0, r=0, t=0, b=0)
#     )

#     fig.show()

# # 调用函数
# visualize_LOB_with_pano(poleLOB, PanoInfoFinal)

print(len(Pts2downloadPano))
print(PanoInfoFinal)

def plot_detection_results(savepreddir):
    """
    绘制检测结果

    Args:
        savepreddir: 预测结果保存目录
    """
    # 读取所有预测结果
    PredResultList = os.listdir(savepreddir)
    allprediction = []

    def unnestlist(alist):
        return [item for subl in alist for item in subl]

    # 合并所有预测结果
    for pred_file in PredResultList:
        pred_temp = pd.read_excel(os.path.join(savepreddir, pred_file))
        allprediction.append(pred_temp.values.tolist())

    # 转换为DataFrame
    allprediction_T = pd.DataFrame(
        unnestlist(allprediction),
        columns=['Lat','Lon']
    )

    # 保存合并后的预测结果
    output_path = os.path.join(
        workingdirectory,
        'drive/MyDrive/黃俊翔_論文研究📚/Street_view/adaptive_constrained_result.xlsx'
    )
    allprediction_T.to_excel(output_path, index=False)

    # 创建地图
    fig = go.Figure()

    # 添加预测点
    fig.add_trace(go.Scattermapbox(
        lat=allprediction_T['Lat'],
        lon=allprediction_T['Lon'],
        mode='markers',
        name='Predicted pole locations',
        marker=dict(
            size=7,
            color='orange',
            opacity=0.8
        )
    ))

    # 更新布局
    fig.update_layout(
        mapbox=dict(
            style='carto-positron',
            zoom=15,
            center=dict(
                lat=allprediction_T['Lat'].mean(),
                lon=allprediction_T['Lon'].mean()
            )
        ),
        height=1200,
        margin=dict(l=0, r=0, t=0, b=0),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor='rgba(255,255,255,0.8)'
        )
    )

    return fig

# 使用示例
fig = plot_detection_results(savepreddir)
fig.show()

"""# **Compare with Ground truth dataset(For verifying)**"""

fig = mapplotpoints(PanoInfoFinal['lat'][0:1],PanoInfoFinal['lon'][0:1],size = 1, name='Street view location', color='DodgerBlue')

# fig = mapplotpoints(np.array(WHPoleLoc)[:,0],np.array(WHPoleLoc)[:,1],size = 8, name='Actual pole locations', color='orange')

fig.add_trace(go.Scattermapbox(
        lat=np.array(WHPoleLoc)[:,0],
        lon=np.array(WHPoleLoc)[:,1],
        name='Actual pole locations',
        mode='markers',
        marker=go.scattermapbox.Marker(
            size=15,
            color='orange',
            opacity=0.6
        )))

fig.add_trace(go.Scattermapbox(
        lat=np.array(polepredgroup_final)[:,0],
        lon=np.array(polepredgroup_final)[:,1],
        name='Predicted pole locations',
        mode='markers',
        marker=go.scattermapbox.Marker(
            size=10,
            color='red',
            opacity=0.9
        )))


fig.update_layout(
    height=800
)

import pandas as pd
import numpy as np
import os

point = pd.read_excel(workingdirectory + "JamaicaBeachRoutePoints.xlsx")
point.info()
fig = mapplotpoints(point['Lat'][0:1],point['Lon'][0:1],size = 1, name='Street view location', color='DodgerBlue')

# fig = mapplotpoints(np.array(WHPoleLoc)[:,0],np.array(WHPoleLoc)[:,1],size = 8, name='Actual pole locations', color='orange')

fig.add_trace(go.Scattermapbox(
        lat=point['Lat'][0:],
        lon=point['Lon'][0:],
        name='Actual pole locations',
        mode='markers',
        marker=go.scattermapbox.Marker(
            size=15,
            color='orange',
            opacity=0.6
        )))

# fig.add_trace(go.Scattermapbox(
#         lat=np.array(polepredgroup_final)[:,0],
#         lon=np.array(polepredgroup_final)[:,1],
#         name='Predicted pole locations',
#         mode='markers',
#         marker=go.scattermapbox.Marker(
#             size=10,
#             color='red',
#             opacity=0.9
#         )))


fig.update_layout(
    height=800
)

import pandas as pd
import numpy as np
from geopy.distance import geodesic

def interpolate_points(lat1, lon1, lat2, lon2, rte_nm, num_points=4):
    lats = np.linspace(lat1, lat2, num_points)
    lons = np.linspace(lon1, lon2, num_points)
    rte_nms = [rte_nm] * num_points
    return list(zip(lats, lons, rte_nms))

# 讀取原始CSV
df = pd.read_csv('/content/JamaicaBeachRoutePoints.csv')

# 按照道路分組並進行插值
dense_points = []
for name, group in df.groupby('RTE_NM'):
    for i in range(len(group)-1):
        lat1, lon1 = group.iloc[i][['Lat', 'Lon']]
        lat2, lon2 = group.iloc[i+1][['Lat', 'Lon']]
        rte_nm = group.iloc[i]['RTE_NM']
        new_points = interpolate_points(lat1, lon1, lat2, lon2, rte_nm, num_points=4)
        dense_points.extend(new_points)

# 創建新的數據框
df_dense = pd.DataFrame(dense_points, columns=['Lat', 'Lon', 'RTE_NM'])

# 計算相鄰點之間的距離
distances = [0]  # 第一個點沒有距離
for i in range(1, len(df_dense)):
    coord1 = (df_dense.iloc[i-1]['Lat'], df_dense.iloc[i-1]['Lon'])
    coord2 = (df_dense.iloc[i]['Lat'], df_dense.iloc[i]['Lon'])
    distances.append(geodesic(coord1, coord2).meters)  # 計算距離（單位：公尺）

df_dense['Distance_m'] = distances

# 顯示結果
print(df_dense)

# 保存結果
df_dense.to_csv('/content/dense_route_points_with_distance.csv', index=False)

print(df_dense[100:1000])

import pandas as pd
import numpy as np
import os

point = pd.read_csv(workingdirectory + "dense_route_points_with_distance.csv")
point.info()
fig = mapplotpoints(point['Lat'][0:1],point['Lon'][0:1],size = 1, name='Street view location', color='DodgerBlue')

# fig = mapplotpoints(np.array(WHPoleLoc)[:,0],np.array(WHPoleLoc)[:,1],size = 8, name='Actual pole locations', color='orange')

fig.add_trace(go.Scattermapbox(
        lat=point['Lat'][0:],
        lon=point['Lon'][0:],
        name='Actual pole locations',
        mode='markers',
        marker=go.scattermapbox.Marker(
            size=15,
            color='orange',
            opacity=0.6
        )))

# fig.add_trace(go.Scattermapbox(
#         lat=np.array(polepredgroup_final)[:,0],
#         lon=np.array(polepredgroup_final)[:,1],
#         name='Predicted pole locations',
#         mode='markers',
#         marker=go.scattermapbox.Marker(
#             size=10,
#             color='red',
#             opacity=0.9
#         )))


fig.update_layout(
    height=800
)