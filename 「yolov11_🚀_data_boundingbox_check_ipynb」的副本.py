# -*- coding: utf-8 -*-
"""ã€ŒYOLOv11 ğŸš€ data_boundingbox_check.ipynbã€çš„å‰¯æœ¬

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m5uw29oivhhlpqAG7Dx1D3TdzNAqFRdE
"""

!pip install ultralytics

"""## **Link to GOOGLE CLOUD**"""

from google.colab import drive
drive.mount('/content/drive')

import os
os.environ["DATASET_DIRECTORY"] = "/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/Aerial_view"

!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="Vn498XKl5WTFBXnBmcWP")
project = rf.workspace("erhu25-hesib").project("poledetect_final")
version = project.version(2)
dataset = version.download("yolo11x")

"""### Create model by using **YOLOv8ğŸš€**"""

from ultralytics import YOLO

#Load a model
model = YOLO("/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/Aerial_view/best.pt")
# model = YOLO() #load existing model

import torch
print("CUDA available:", torch.cuda.is_available())
print("GPU Name:", torch.cuda.get_device_name(0) if torch.cuda.is_available() else "No GPU found")

"""## **Trainning.........**"""

model.train(
    data="/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/Aerial_view/PoleDetect_final-2/data.yaml",
    epochs=1000,
    batch=16,
    imgsz=640,
    workers=4,  # æ•¸æ“šåŠ è¼‰çš„å·¥ä½œç·šç¨‹æ•¸
    augment=True,
    half=True,
    iou=0.6,
)

metric=model.val()

"""## **Testing**"""

results = model("/content/20_png.rf.209170bddd4d755cee9b64032e137317.jpg")

"""## **Show Result**"""

import matplotlib.pyplot as plt
import cv2

# Get the result image with bounding boxes
result_image = results[0].plot()

# Display the result image
plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
plt.axis('off')
plt.show()

import os
import matplotlib.pyplot as plt
import cv2

# Directory containing images
image_dir = "/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/XML-to-TXT-1/train/images"

# Get all image paths in the directory
image_paths = [os.path.join(image_dir, img) for img in os.listdir(image_dir) if img.endswith(('.jpg', '.jpeg', '.png'))]

# Iterate through each image, make predictions, and display results
for image_path in image_paths:
    # Make a prediction
    results = model(image_path)

    # Get the result image with bounding boxes
    result_image = results[0].plot()

    # Display the result image
    plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    plt.axis('off')
    plt.title(image_path)
    plt.show()

import matplotlib.pyplot as plt
import cv2

results = model("/content/aerialbot-38.88586051--76.92986965.jpg")

# Get the result image with bounding boxes
result_image = results[0].plot()

# Display the result image
plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
plt.axis('off')
plt.show()

"""## **Download model**"""

import shutil
import os

source_file = '/content/runs/detect/train/weights/best.pt'
destination_folder = '/content/drive/MyDrive/é»ƒä¿Šç¿”_è«–æ–‡ç ”ç©¶ğŸ“š/Aerial_view'
destination_file = os.path.join(destination_folder, 'best.pt')

# ç¡®ä¿ç›®æ ‡æ–‡ä»¶å¤¹å­˜åœ¨
os.makedirs(destination_folder, exist_ok=True)

# å¦‚æœç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤å®ƒ
if os.path.exists(destination_file):
    os.remove(destination_file)

# ç§»åŠ¨æ–‡ä»¶
shutil.move(source_file, destination_file)

print(f'File moved to: {destination_file}')